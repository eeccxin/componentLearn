MySQL 45讲

# 0 课程介绍

> 极客时间  MySQL 实战 45 讲 https://time.geekbang.org/column/intro/100020801

## 你将获得

- 前腾讯云数据库负责人独家经验分享；
- MySQL 核心技术详解与原理说明；
- 36 个 MySQL 常见痛点问题解析；
- 完整的 MySQL 学习路径。

## 课程介绍

MySQL 使用和面试中遇到的问题，很多人会通过搜索别人的经验来解决 ，零散不成体系。实际上只要理解了 MySQL 的底层工作原理，就能很快地直戳问题的本质。

本专栏一共 **45** 讲，**全集**更新完毕，通过探讨 MySQL 实战中最常见的 **36 个** 痛点问题，串起各个零散的知识点，配合 **100+** 手绘详解图，由线到面带你构建 MySQL 系统的学习路径。

在专栏中，丁奇结合自己十多年来，通过 MySQL 源码找答案的经历，梳理了 **MySQL 的主线知识**，比如**事务、索引、锁**等；并基于这条主线，带你缕清**概念、机制、原理、案例分析**以及本质，让你真正能掌握 **MySQL 核心技术与底层原理。**

值得一提的是，每篇文章中都附有**实践案例**，给你从理论到实战的系统性指导，让你少走弯路，彻底搞懂 MySQL。

本课程共包括两大模块。

**模块一，基础篇**。为你深入浅出地讲述 MySQL 核心知识，涵盖 MySQL 基础架构、日志系统、事务隔离、锁等内容。

**模块二，实践篇**。将从一个个关键的数据库问题出发，分析数据库原理，并给出实践指导。每个问题，都不只是简单地给出答案，而是从为什么要这么想、到底该怎样做出发，让你能够知其所以然，都将能够解决你平时工作中的一个疑惑点。

## 课程目录

<img src="MYSQL实战45讲.assets/b736f37014d28199c2457a67ed669bc2.jpg" alt="img" style="zoom:33%;" />





# 00 安装mysql

> 详见：https://www.runoob.com/mysql/mysql-install.html

```bash
# 下载
wget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpm
rpm -ivh mysql-community-release-el7-5.noarch.rpm
yum update
yum install mysql-server
```

权限设置：

```
chown -R mysql:mysql /var/lib/mysql/
```

初始化 MySQL：

```
mysqld --initialize
```

启动 MySQL：

```
systemctl start mysqld
```

查看 MySQL 运行状态：

```
systemctl status mysqld
```



查看初始密码：

```
grep password /var/log/mysql/mysqld.log 
2024-05-14T11:48:54.670531Z 6 [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: 3d:Aw9u?-Tp!
```



登录后修改密码：

```bash
mysql -u root -p 3d:Aw9u?-Tp!
#修改密码
alter user 'root'@'localhost' identified by 'xxxxxx密码'
```



# 01 | 基础架构：一条SQL查询语句是如何执行的？

> https://juejin.cn/post/7130258357184626724 这篇文章更详细

下面是MySQL的基本架构示意图，从中你可以清楚地看到SQL语句在MySQL的各个功能模块中的执行过程。

<img src="MYSQL实战45讲.assets/image-20240428175938023.png" alt="image-20240428175938023" style="zoom:50%;" />

<center>MySQL的逻辑架构图</center>

​		大体来说，MySQL可以分为Server层和存储引擎层两部分。

-  Server层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。
- 而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎。现在最常用的存储引擎是InnoDB，它从**MySQL 5.5.5**版本开始成为了默认存储引擎。

 以1条SQL语句，带你走一遍整个执行流程，依次看下每个组件的作用。       

```sql
mysql> select * from T where ID=10；
```

![未命名绘图.png](MYSQL实战45讲.assets/73b4a36d35c3439694d0a29c20b880d9tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-17143044539905.webp)

## 连接器

第一步，你会先连接到这个数据库上，这时候接待你的就是连接器。连接器负责跟客户端建立连接、获取权限、维持和管理连接。连接命令一般是这么写的：

```sql
mysql -h $ip -P $port -u $user -p
```

连接命令中的mysql是客户端工具，用来跟服务端建立连接。在完成经典的TCP握手后，连接器就要开始认证你的身份，这个时候用的就是你输入的用户名和密码。

- 如果用户名或密码不对，你就会收到一个"Access denied for user"的错误，然后客户端程序结束执行。
- 如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限

这就意味着，一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。**修改完成后，只有再新建的连接才会使用新的权限设置**。  

连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，你可以在**showprocesslist命令**中看到它。文本中这个图是showprocesslist的结果，其中的Command列显示为“Sleep”的这一行，就表示现在系统里面有一个空闲连接。

​                                                       <img src="MYSQL实战45讲.assets/image-20240428193357383.png" alt="image-20240428193357383" style="zoom:50%;" />

> 空闲连接会一直占用着吗？

客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数**wait_timeout（等待超时）**控制的，默认值是8小时。

```sql
mysql> show variables like 'wait_timeout';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| wait_timeout  | 28800 |
+---------------+-------+
1 row in set (0.00 sec)
```

当然，我们自己也可以手动断开空闲的连接，使用的是 kill connection + id 的命令。

```sql
mysql> kill connection +6;
Query OK, 0 rows affected (0.00 sec)
```

如果在连接被断开之后，客户端再次发送请求的话，就会收到一个错误提醒： Lost connectionto MySQL server during query。这时候如果你要继续，就需要重连，然后再执行请求了。

数据库里面，**长连接**是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。**短连接**则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。

建立连接的过程通常是比较复杂的，所以我建议你在使用中要尽量减少建立连接的动作，也就是**尽量使用长连接**。但是全部使用长连接后，你可能会发现，有些时候MySQL占用**内存涨得特别快**，这是因为MySQL在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（**OOM**），从现象看就是MySQL异常重启了。

> 怎么解决长连接长期占用内存这个问题呢？你可以考虑以下两种方案。

1. 定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。

2. **客户端主动重置连接**。MySQL 5.7 版本实现了 `mysql_reset_connection()` 函数的接口，注意这是接口函数不是命令，那么当客户端执行了一个很大的操作后，在代码里调用 mysql_reset_connection 函数来重置连接，达到释放内存的效果。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。

   

> MySQL 的连接数有限制吗？

MySQL 服务支持的最大连接数由 **max_connections** 参数控制，比如我的 MySQL 服务默认是 151 个,超过这个值，系统就会拒绝接下来的连接请求，并报错提示“Too many connections”。

```sql
mysql> show variables like 'max_connections';
+-----------------+-------+
| Variable_name   | Value |
+-----------------+-------+
| max_connections | 151   |
+-----------------+-------+
1 row in set (0.00 sec)
```



## 查询缓存

连接建立完成后，你就可以执行select语句了。执行逻辑就会来到第二步：查询缓存。

MySQL拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以key-value对的形式，被直接缓存在内存中。key是查询的语句，value是查询的结果。如果你的查询能够直接在这个缓存中找到key，那么这个value就会被直接返回给客户端。

如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。你可以看到，如果查询命中缓存，MySQL不需要执行后面的复杂操作，就可以直接返回结果，这个效率会很高。

> 但是大多数情况下我会建议你不要使用查询缓存，为什么呢？

因为查询缓存往往弊大于利。**查询缓存的失效非常频繁**，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据库来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。

好在MySQL也提供了这种“按需使用”的方式。你可以将参数**query_cache_type设置成DEMAND**，这样对于默认的SQL语句都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以用SQL_CACHE显式指定，像下面这个语句一样：

```sql
mysql> select SQL_CACHE * from T where ID=10;
```

需要注意的是，MySQL 8.0版本直接将查询缓存的整块功能删掉了，也就是说8.0开始彻底没有这个功能了。



## 分析器

如果没有命中查询缓存，就要开始真正执行语句了。首先，MySQL需要知道你要做什么，因此需要对SQL语句做解析。

1、词法分析

分析器先会做“词法分析”。你输入的是由多个字符串和空格组成的一条SQL语句，MySQL需要识别出里面的字符串分别是什么，代表什么。

MySQL从你输入的"select"这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名T”，把字符串“ID”识别成“列ID”。



2、语法分析

做完了这些识别以后，就要做“语法分析”。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个SQL语句是否满足MySQL语法。

如果你的语句不对，就会收到**“You have an error in your SQL syntax”的错误提醒**，比如下面这个语句select少打了开头的字母“s”。

```sql
mysql> elect * from t where ID=1;
ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'elect * from t where ID=1' at line 1
```

一般语法错误会提示第一个出现错误的位置，所以你要关注的是紧接“use near”的内容。



## 优化器 

经过了分析器，MySQL就知道你要做什么了。在开始执行之前，还要先经过优化器的处理。

**优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序**。

比如你执行下面这样的语句，这个语句是执行两个表的join：

```sql
mysql> select * from t1 join t2 using(ID) where t1.c=10 and t2.d=20;
```

- 既可以先从表t1里面取出c=10的记录的ID值，再根据ID值关联到表t2，再判断t2里面d的值是否等于20。
- 也可以先从表t2里面取出d=20的记录的ID值，再根据ID值关联到t1，再判断t1里面c的值是否等于10。

这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。

优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。如果你还有一些疑问，比如优化器是怎么选择索引的，有没有可能选择错等等，没关系，在后面的文章中单独展开说明优化器的内容。

（小表驱动大表会好点？）



## 执行器

MySQL通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。

开始执行的时候，要先判断一下你对这个表T有没有执行查询的**权限**，如果没有，就会返回没有权限的错误，如下所示：

```sql
mysql> select * from T where ID=10;
ERROR 1142 (42000): SELECT command denied to user 'b'@'localhost' for table 'T'
```

如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。

比如我们这个例子中的表T中，ID字段没有索引，那么执行器的执行流程是这样的（全表查询）：

1. 调用InnoDB引擎接口取这个表的第一行，判断ID值是不是10，如果不是则跳过，如果是则

将这行存在结果集中；

2. 调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。

3. 执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。

至此，这个语句就执行完成了，

对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。



你会在数据库的慢查询日志中看到一个**rows_examined的字段，表示这个语句执行过程中扫描了多少行**。这个值就是在执行器每次调用引擎获取数据行的时候累加的。

在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟rows_examined 并不是完全相同的。 后面会专门有一篇文章来讲存储引擎的内部机制，里面会有详细的说明。



## 思考题

如果表T中没有字段k，而你执行了这个语句 select *fromTwhere k=1, 那肯定是会报“不存在这个列”的错误： “Unknown column ‘k’ in ‘where clause’”。你觉得这个错误是在我们上面提到的哪个阶段报出来的呢？

（分析器？

查询解析阶段：在这个阶段，MySQL 解析查询语句的语法和语义，检查语句的正确性，并生成相应的查询执行计划。在这个阶段，MySQL 会检查表和列是否存在，但不会检查列的值）



# 02 | 日志系统：一条SQL更新语句是如何执行的？

一条更新语句的执行流程又是怎样的呢？

**之前你可能经常听DBA同事说，MySQL可以恢复到半个月内任意一秒的状态**，惊叹的同时，你是不是心中也会不免会好奇，这是怎样做到的呢？

我们还是从一个表的一条更新语句说起，下面是这个表的创建语句，这个表有一个主键ID和一个整型字段c：

```sql
mysql> create table T(ID int primary key, c int);
```

如果要将ID=2这一行的值加1，SQL语句就会这么写：

```sql
mysql> update T set c=c+1 where ID=2;
```

<img src="MYSQL实战45讲.assets/image-20240429180703572.png" alt="image-20240429180703572" style="zoom:50%;" />

还是看这个架构图。

你执行语句前要先连接数据库，这是连接器的工作。

前面我们说过，在一个表上有更新的时候，跟这个表有关的查询缓存会失效，所以这条语句就会把表T上所有缓存结果都清空。这也就是我们一般不建议使用查询缓存的原因。

接下来，分析器会通过词法和语法解析知道这是一条更新语句。优化器决定要使用ID这个索引。然后，执行器负责具体执行，找到这一行，然后更新。

**与查询流程不一样的是，更新流程还涉及两个重要的日志模块，它们正是我们今天要讨论的主角：redo log（重做日志）和 binlog（归档日志）**。



## **redo log**（重做日志）

在MySQL里，如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程IO成本、查找成本都很高。

为了解决这个问题，MySQL的设计者就用了类似酒店掌柜粉板（临时记录，最后再一起核算）的思路来提升更新效率。

而粉板和账本配合的整个过程，其实就是MySQL里经常说到的WAL技术，WAL的全称是**Write Ahead Logging（写前日志）**，它的关键点就是先写日志，再写磁盘，也就是先写粉板，等不忙的时候再写账本。



具体来说，当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log（粉板）里面，**并更新内存**，这个时候更新就算完成了。同时，InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做，这就像打烊以后掌柜做的事。



InnoDB的redo log是固定大小的，比如可以配置为一组4个文件，每个文件的大小是1GB，那么这块“粉板”总共就可以记录4GB的操作。从头开始写，写到末尾就又回到开头循环写，如下面这个图所示。

<img src="MYSQL实战45讲.assets/image-20240429190635968.png" alt="image-20240429190635968" style="zoom:50%;" />

**write pos**是当前记录的位置，一边写一边后移，写到第3号文件末尾后就回到0号文件开头。**checkpoint**是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。

write pos和checkpoint之间的是“粉板”上还空着的部分，可以用来记录新的操作。如果write pos追上checkpoint，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把checkpoint推进一下。（双指针设计得很合理）

有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为**crash-safe**（奔溃安全）。

**innodb_flush_log_at_trx_commit这个参数设置成1的时候，表示每次事务的redo log都直接持久化到磁盘。**这个参数我建议你设置成1，这样可以保证MySQL异常重启之后数据不丢失。



这个Redo Log 是在磁盘上存储的，而不是在内存中。

Redo Log 记录了对数据库进行的修改操作，例如插入、更新和删除操作。当事务提交时，相关的 Redo Log 记录会被写入磁盘，以确保在数据库崩溃或故障恢复时，可以通过重放 Redo Log 来恢复未完成的事务。

尽管 Redo Log 是在磁盘上存储的，但在实际操作中，MySQL 会**使用缓冲区（Buffer）来管理 Redo Log 的写入**。这是为了提高性能，避免每次修改都直接写入磁盘。MySQL 会将 Redo Log 记录先写入到内存的缓冲区中，然后根据一定的策略将缓冲区中的内容刷新到磁盘上的 Redo Log 文件中。





## **binlog（归档日志）**

MySQL整体来看，其实就有两块：一块是Server层，它主要做的是MySQL功能

层面的事情；还有一块是引擎层，负责存储相关的具体事宜。上面我们聊到的粉板redo log是InnoDB引擎特有的日志，而**Server层也有自己的日志，称为binlog（归档日志）**

你肯定会问，为什么会有两份日志呢？

因为最开始MySQL里并没有InnoDB引擎。MySQL自带的引擎是MyISAM，但是MyISAM没有crash-safe的能力，binlog日志只能用于归档。而InnoDB是另一个公司以插件形式引入MySQL的，既然只依靠binlog是没有crash-safe能力的，所以InnoDB使用另外一套日志系统— — 也就是redo log来实现crash-safe能力。

**sync_binlog这个参数设置成1的时候，表示每次事务的binlog都持久化到磁盘。**这个参数我也建议你设置成1，这样可以保证MySQL异常重启之后binlog不丢失



这两种日志有以下三点不同。

1. redo log是InnoDB引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使用。

2. redo log是物理日志，记录的是“在某个数据页上做了什么修改”；binlog是逻辑日志，记录的是这个语句的原始逻辑，比如“给ID=2这一行的c字段加1 ”。

3. redo log是循环写的，空间固定会用完；binlog是可以追加写入的。“追加写”是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。



有了对这两个日志的概念性理解，我们再来看执行器和InnoDB引擎在执行这个简单的update语句时的内部流程：

1. 执行器先找引擎取ID=2这一行。ID是主键，引擎直接用树搜索找到这一行。如果ID=2这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。

2. 执行器拿到引擎给的行数据，把这个值加上1，比如原来是N，现在就是N+1，得到新的一行数据，再调用引擎接口写入这行新数据。

3. 引擎将这行新数据更新到内存中，同时将这个更新操作**记录到redo log里面**，此时redo log处于prepare状态。然后**告知执行器执行完成了**，随时可以提交事务。

4. 执行器生成这个操作的binlog，并把binlog写入磁盘.(异步的？)

5. 执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交（commit）状态，更新完成。

下面是update语句的执行流程图，图中浅色框表示是在InnoDB内部执行的，深色框表示是在执行器中执行的。

<img src="MYSQL实战45讲.assets/image-20240429192224620.png" alt="image-20240429192224620" style="zoom:50%;" />

<center>update语句执行流程</center>

你可能注意到了，最后三步看上去有点“绕”，**将redo log的写入拆成了两个步骤：prepare和commit**，这就是"两阶段提交"。



## 两阶段提交

为什么必须有“两阶段提交”呢？这是为了让两份日志之间的逻辑一致。要说明这个问题，我们得

从文章开头的那个问题说起：怎么让数据库恢复到半个月内任意一秒的状态？

前面我们说过了，**binlog会记录所有的逻辑操作**，并且是采用“追加写”的形式。如**果你的DBA承诺说半个月内可以恢复，那么备份系统中一定会保存最近半个月的所有binlog，同时系统会定期做整库备份。**这里的“定期”取决于系统的重要性，可以是一天一备，也可以是一周一备

当需要恢复到指定的某一秒时，比如某天下午两点发现中午十二点有一次误删表，需要找回数据，那你可以这么做：

- 首先，找到最近的一次全量备份，如果你运气好，可能就是昨天晚上的一个备份，从这个备份恢复到临时库；
- 然后，从备份的时间点开始，将备份的binlog依次取出来，重放到中午误删表之前的那个时刻。

这样你的临时库就跟误删之前的线上库一样了，然后你可以把表数据从临时库取出来，按需要恢复到线上库去。

好了，说完了数据恢复过程，我们回来说说，为什么日志需要“**两阶段提交**”。这里不妨用反证法来进行解释。

由于redo log和binlog是两个独立的逻辑，如果不用两阶段提交，要么就是先写完redo log再写binlog，或者采用反过来的顺序。我们看看这两种方式会有什么问题。仍然用前面的update语句来做例子。假设当前ID=2的行，字段c的值是0，再假设执行update语句过程中在写完第一个日志后，第二个日志还没有写完期间发生了crash，会出现什么情况呢？

（数据以redo log为准，这个WAL写了就表示操作成功了）

**1、先写redo log在写binlog 会造成恢复数据时的数据缺失。**假设在redo log写完，binlog还没有写完的时候，MySQL进程异常重启。由于我们前面说过的，redo log写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行c的值是1。但是由于binlog没写完就crash了，这时候binlog里面就没有记录这个语句。因此，之后备份日志的时候，存起来的binlog里面就没有这条语句。然后你会发现，如果需要用这个binlog来恢复临时库的话，由于这个语句的binlog丢失，这个临时库就会少了这一次更新，恢复出来的这一行c的值就是0，与原库的值不同

2、先写binlog在写redo log 。如果在binlog写完之后crash，由于redo log还没写，崩溃恢复以后这个事务无效，所以这一行c的值是0。但是binlog里面已经记录了“把c从0改成1”这个日志。所以，在之后用binlog来恢复的时候就多了一个事务出来，恢复出来的这一行c的值就是1，与原库的值不同



可以看到，如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。

你可能会说，这个概率是不是很低，平时也没有什么动不动就需要恢复临时库的场景呀？

其实不是的，不只是误操作后需要用这个过程来恢复数据。当你需要**扩容的时候**，也就是需要再多搭建一些备库来增加系统的读能力的时候，**现在常见的做法也是用全量备份加上应用binlog来实现的**，这个“不一致”就会导致你的线上出现主从数据库不一致的情况。

简单说，redo log和binlog都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。



**两阶段提交是==跨系统==维持数据逻辑一致性时常用的一个方案，即使你不做数据库内核开发，日常开发中也有可能会用到**。



## 思考题

定期全量备份的周期“取决于系统重要性，有的是一天一备，有的是一周一备”。那么在什么场景下，一天一备会比一周一备更有优势呢？或者说，它影响了这个数据库系统的哪个指标？

> chatGPT回答

一天一备的优势：

1. 数据恢复点更近：一天一备意味着在发生故障或数据丢失时，可以恢复到最近一天的备份。**这可以减少数据丢失的程度，尤其是对于频繁发生数据变更的系统**。
2. 数据恢复时间较短：由于备份频率较高，恢复数据所需的时间相对较短。这对于需要快速恢复数据库的系统非常重要，以减少业务中断时间。

一周一备的优势：

1. 节省存储空间：一周一备相对于一天一备可以减少备份数据的存储需求。如果数据量庞大，每天进行全量备份可能会占用大量的存储空间。一周一备可以在一定程度上减少存储成本。
2. 减少备份过程对系统性能的影响：进行全量备份可能会对数据库系统的性能产生一定的影响。一周一备相对于一天一备可以减少备份过程对系统性能的影响，尤其是对于大型数据库系统。

备份策略的选择会影响数据库系统的可恢复性和可用性指标。一天一备可以提供更近的数据恢复点和较短的恢复时间，从而减少数据丢失和业务中断时间。而一周一备可以节省存储空间和减少备份过程对系统性能的影响。

需要根据具体的业务需求、数据变更频率和系统重要性来评估并选择适合的备份策略。有些系统可能需要更频繁的备份以确保数据的安全性和可恢复性，而对于其他系统，一周一备可能已经足够满足需求。

> 作者回答

好处是“最长恢复时间”更短。

在一天一备的模式里，最坏情况下需要应用一天的binlog。比如，你每天0点做一次全量备份，

而要恢复出一个到昨天晚上23点的备份。

一周一备最坏情况就要应用一周的binlog了。

系统的对应指标就是 RTO（**Recovery Time Objective**，恢复时间目标），具体见[这里](https://www.dell.com/community/zh/conversations/%E6%95%B0%E6%8D%AE%E4%BF%9D%E6%8A%A4%E8%AE%A8%E8%AE%BA%E5%8C%BA/%E6%81%A2%E5%A4%8D%E6%97%B6%E9%97%B4%E7%9B%AE%E6%A0%87rto%E5%92%8C%E6%81%A2%E5%A4%8D%E7%82%B9%E7%9B%AE%E6%A0%87rpo/647f86edf4ccf8a8de60d31e)。

当然这个是有成本的，因为更频繁全量备份需要消耗更多存储空间，所以这个RTO是成本换来

的，就需要你根据业务重要性来评估了





# 03 | 事务隔离：为什么你改了我还看不见？

事务就是要保证一组数据库操作，要么全部成功，要么全部失败（原子性）。在MySQL中，**事务支持是在引擎层实现的**。

道，MySQL是一个支持多引擎的系统，但并不是所有的引擎都支持事务。比如M**ySQL原生的MyISAM引擎就不支持事务，这也是MyISAM被InnoDB取代**

**的重要原因之一**。

今天的文章以InnoDB为例，剖析MySQL在事务支持方面的特定实现，并基于原理给出相应的实践建议，希望这些案例能加深你对MySQL事务原理的理解



## 隔离性与隔离级别

提到事务，你肯定会想到ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性），今天我们就来说说其中I，也就是“隔离性”。

当数据库上有多个事务同时执行的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、**幻读（phantomread）**的问题，为了解决这些问题，就有了“隔离级别”的概念。



隔离得越严实，效率就会越低。因此很多时候，我们都要在二者之间寻找一个平衡点。SQL标准的事务隔离级别包括：读未提交（read uncommitted）、

读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）。下面逐一为你解释：

- 读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。
- 读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。
- 可重复读是指，**一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的**。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。
- 串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。



其中“读提交”和“可重复读”比较难理解，下面一个例子说明这几种隔离级别。假设数据表T中只有一列，其中一行的值为1，下面是按照时间顺序执行两个事务的行为。

```bash
mysql> create table T(c int) engine=InnoDB;
insert into T(c) values(1);
```

<img src="MYSQL实战45讲.assets/image-20240511174838564.png" alt="image-20240511174838564" style="zoom:50%;" />



在不同的隔离级别下，事务A会有哪些不同的返回结果，也就是图里面V1、V2、V3的返回值分别是什么。

- 若隔离级别是“读未提交”， 则V1的值就是2。这时候事务B虽然还没有提交，但是结果已经被A看到了。因此，V2、V3也都是2。
- 若隔离级别是“读提交”，则V1是1，V2的值是2。事务B的更新在提交后才能被A看到。所以，V3的值也是2。
- 若隔离级别是“可重复读”，则V1、V2是1，V3是2。之所以V2还是1，遵循的就是这个要求：事务在执行期间看到的数据前后必须是一致的。
- **若隔离级别是“串行化”，则在事务B执行“将1改成2”的时候，会被锁住**。直到事务A提交后，事务B才可以继续执行。所以从A的角度看， V1、V2值是1，V3的值是2。

**在实现上，数据库里面会创建一个视图**，访问的时候以视图的逻辑结果为准。

- 在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。
- 在“读提交”隔离级别下，这个视图是在每个SQL语句开始执行的时候创建的
- “读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；
- 而“串行化”隔离级别下直接用加锁的方式来避免并行访问

在不同的隔离级别下，数据库行为是有所不同的。Oracle数据库的默认隔离级别其实就是“读提交”，因此对于一些从Oracle迁移到MySQL的应用，为保证数据库隔离级别的一致，你一定要记得将MySQL的隔离级别设置为“读提交”。

配置的方式是，将启动参数transaction-isolation的值设置成READ-COMMITTED。你可以用showvariables来查看当前的值

```bash
mysql> show variables like 'transaction_isolation';
+-----------------------+----------------+
| Variable_name | Value |
+-----------------------+----------------+
| transaction_isolation | READ-COMMITTED |
+-----------------------+----------------+
```



总结来说，存在即合理，哪个隔离级别都有它自己的使用场景，你要根据自己的业务情况来定。

什么情况下会用到“可重复读“的场景？

假设你在管理一个个人银行账户表。一个表存了每个月月底的余额，一个表存了账单明细。这时候你要做数据校对，也就是判断上个月的余额和当前余额的差额，是否与本月的账单明细一致。你一定希望在校对过程中，即使有用户发生了一笔新的交易，也不影响你的校对结果。这时候使用“可重复读”隔离级别就很方便。事务启动时的视图可以认为是静态的，不受其他事务更新的影响。



## 事务隔离的实现

理解了事务的隔离级别，我们再来看看事务隔离具体是怎么实现的。这里我们展开说明“可重复读”。

在MySQL中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。

假设一个值从1被按顺序改成了2、3、4，在回滚日志里面就会有类似下面的记录。

<img src="MYSQL实战45讲.assets/image-20240511175531780.png" alt="image-20240511175531780" style="zoom:50%;" />

当前值是4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的read-view。如图中看到的，在视图A、B、C里面，这一个记录的值分别是1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。对于read-viewA，要得到1，就必须将当前值依次执行图中所有的回滚操作得到。



同时你会发现，即使现在有另外一个事务正在将4改成5，这个事务跟read-viewA、B、C对应的事务是不会冲突的。

你一定会问，回滚日志总不能一直保留吧，什么时候删除呢？答案是，在不需要的时候才删除。也就是说，**系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除**。

什么时候才不需要了呢？**就是当系统里没有比这个回滚日志更早的read-view的时候**。



基于上面的说明，我们来讨论一下为什么建议你尽量不要使用长事务。

1、**长事务意味着系统里面会存在很老的事务视图**。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。

**在MySQL 5.5及以前的版本，回滚日志是跟数据字典一起放在ibdata文件里的，即使长事务最终提交，回滚段被清理，文件也不会变小**。我见过数据只有20GB，而回滚段有200GB的库。最终只好为了清理回滚段，重建整个库。

2、除了对回滚段的影响，**长事务还占用锁资源**，也可能拖垮整个库，这个我们会在后面讲锁的时候展开。



## 事务的启动方式

如前面所述，长事务有这些潜在风险，我当然是建议你尽量避免。其实很多时候业务开发同学并不是有意使用长事务，通常是由于误用所致。MySQL的事务启动方式有以下几种：

1. **显式启动事务语句**， begin 或 start transaction。配套的提交语句是commit，回滚语句是rollback。

2. **set autocommit=0**，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个select语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行commit 或 rollback 语句，或者断开连接。

有些客户端连接框架会默认连接成功后先执行一个set autocommit=0的命令。这就导致接下来的查询都在事务中，如果是长连接，就导致了意外的长事务。

因此，建议你总是使用set autocommit=1, 并通过显式语句的方式来启动事务。

PS: 客户端请求时总会新建一个事务， autocommit只是设置了是否自动提交事务。且当begin显式开启事务时，只有commit才会提交事务（无关autocommit设置）



但是有的开发同学会**纠结“多一次交互”的问题**。对于一个需要频繁使用事务的业务，第二种方式每个事务在开始时都不需要主动执行一次 “begin”，减少了语句的交互次数。如果你也有这个顾虑，**建议你使用commit work and chain语法**。

在autocommit为1的情况下，用begin显式启动的事务，如果执行commit则提交事务。**如果执行commit work and chain，则是提交事务并自动启动下一个事务，这样也省去了再次执行begin语句的开销**。同时带来的好处是从程序开发的角度明确地知道每个语句是否处于事务中。



你可以在information_schema库的innodb_trx这个表中查询长事务，比如下面这个语句，用于查找持续时间超过60s的事务。

```mysql
select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>60;
```

PS：事务表表结构

```mysql
mysql> describe information_schema.innodb_trx;
+----------------------------+---------------------+------+-----+---------------------+-------+
| Field                      | Type                | Null | Key | Default             | Extra |
+----------------------------+---------------------+------+-----+---------------------+-------+
| trx_id                     | varchar(18)         | NO   |     |                     |       |
| trx_state                  | varchar(13)         | NO   |     |                     |       |
| trx_started                | datetime            | NO   |     | 0000-00-00 00:00:00 |       |
| trx_requested_lock_id      | varchar(81)         | YES  |     | NULL                |       |
| trx_wait_started           | datetime            | YES  |     | NULL                |       |
| trx_weight                 | bigint(21) unsigned | NO   |     | 0                   |       |
| trx_mysql_thread_id        | bigint(21) unsigned | NO   |     | 0                   |       |
| trx_query                  | varchar(1024)       | YES  |     | NULL                |       |
| trx_operation_state        | varchar(64)         | YES  |     | NULL                |       |
| trx_tables_in_use          | bigint(21) unsigned | NO   |     | 0                   |       |
| trx_tables_locked          | bigint(21) unsigned | NO   |     | 0                   |       |
| trx_lock_structs           | bigint(21) unsigned | NO   |     | 0                   |       |
| trx_lock_memory_bytes      | bigint(21) unsigned | NO   |     | 0                   |       |
| trx_rows_locked            | bigint(21) unsigned | NO   |     | 0                   |       |
| trx_rows_modified          | bigint(21) unsigned | NO   |     | 0                   |       |
| trx_concurrency_tickets    | bigint(21) unsigned | NO   |     | 0                   |       |
| trx_isolation_level        | varchar(16)         | NO   |     |                     |       |
| trx_unique_checks          | int(1)              | NO   |     | 0                   |       |
| trx_foreign_key_checks     | int(1)              | NO   |     | 0                   |       |
| trx_last_foreign_key_error | varchar(256)        | YES  |     | NULL                |       |
| trx_adaptive_hash_latched  | int(1)              | NO   |     | 0                   |       |
| trx_adaptive_hash_timeout  | bigint(21) unsigned | NO   |     | 0                   |       |
| trx_is_read_only           | int(1)              | NO   |     | 0                   |       |
| trx_autocommit_non_locking | int(1)              | NO   |     | 0                   |       |
+----------------------------+---------------------+------+-----+---------------------+-------+
24 rows in set (0.00 sec)
```

## 思考题

你现在知道了系统里面应该避免长事务，如果你是业务开发负责人同时也是数据库负责人，你会有什么方案来避免出现或者处理这种情况呢？

> chatGPT回答

作为业务开发负责人和数据库负责人，以下是一些方案来避免或处理长事务的情况：

1. 优化查询和事务逻辑：通过优化查询语句和事务逻辑，可以减少事务的执行时间。这包括使用合适的索引、避免全表扫描、减少不必要的查询和锁定等。定期进行性能优化和代码审查，确保查询和事务逻辑的效率和合理性。
2. 分批处理和批量提交：对于大批量的数据操作，可以将其分批处理，避免一次性处理过多的数据。同时，可以使用批量提交的方式，将多个操作合并为一个事务，减少事务的数量和执行时间。
3. 合理设置事务超时时间：设置适当的事务超时时间，避免长时间占用数据库资源。如果事务执行时间超过设定的超时时间，可以主动回滚事务并记录相关日志，以便后续分析和处理。
4. 监控和报警：建立监控系统，实时监测数据库的事务执行情况和性能指标。设置合适的阈值和报警规则，及时发现长事务的存在，并采取相应的措施进行处理。
5. 分布式事务管理：对于分布式系统中的事务，可以采用分布式事务管理方案，如使用消息队列、分布式事务协调器等，确保事务的一致性和可靠性。
6. 定期维护和优化数据库：定期进行数据库维护和优化工作，包括索引重建、统计信息更新、碎片整理等，以提高数据库的性能和稳定性。
7. 数据库复制和备份：使用数据库复制和备份机制，确保数据的可靠性和可恢复性。在出现长事务或其他故障时，可以通过备份数据进行恢复，避免数据丢失和业务中断。

总之，通过优化查询和事务逻辑、分批处理和批量提交、合理设置事务超时时间、监控和报警、分布式事务管理、定期维护和优化数据库以及数据库复制和备份等方案，可以有效地避免或处理长事务的情况，提高数据库的性能和可靠性。

> 作者回答

首先，从应用开发端来看：

1. 确认是sdk否使用了set autocommit=0。这个确认工作可以在测试环境中开展，把MySQL的**general_log**开起来，然后随便跑一个业务逻辑，通过general_log的日志来确认。一般框架如果会设置这个值，也就会提供参数来控制行为，你的目标就是把它改成1。

2. 确认是否有不必要的只读事务。有些框架会习惯不管什么语句先用begin/commit框起来。我见过有些是业务并没有这个需要，但是也把好几个select语句放到了事务中。这种只读事务可以去掉。

3. 业务连接数据库的时候，根据业务本身的预估，通过**SETMAX_EXECUTION_TIME**命令，来控制每个语句执行的最长时间，避免单个语句意外执行太长时间。（为什么会意外？在后续的文章中会提到这类案例）

其次，从数据库端来看：

1. 监控 information_schema.Innodb_trx表，设置长事务阈值，超过就报警/或者kill；

2. Percona的pt-kill这个工具不错，推荐使用；

3. 在业务功能测试阶段要求输出所有的general_log，分析日志行为提前发现问题；

4. 如果使用的是MySQL 5.6或者更新版本，把innodb_undo_tablespaces设置成2（或更大的值）。如果真的出现大事务导致回滚段过大，这样设置后清理起来更方便。



## 补充

### 事务相关指令

1. 显示当前事务状态：

   ```
   SHOW ENGINE INNODB STATUS;
   ```

   这个命令将显示InnoDB存储引擎的状态信息，其中包含了当前事务的相关信息，如事务ID、事务状态等。

2. 开启事务：

   ```
   START TRANSACTION;
   ```

   这个命令用于显式地开启一个事务。在事务中执行的SQL语句将被视为一个原子操作，要么全部执行成功，要么全部回滚。

3. 提交事务：

   ```
   COMMIT;
   ```

   这个命令用于提交当前事务，将之前在事务中执行的SQL语句永久保存到数据库中。

4. 回滚事务：

   ```
   ROLLBACK;
   ```

   这个命令用于回滚当前事务，撤销之前在事务中执行的SQL语句对数据库的修改。

需要注意的是，MySQL默认情况下处于自动提交模式（autocommit），即每个SQL语句都被视为一个独立的事务并自动提交。如果要使用显式事务管理，可以通过设置`autocommit`参数为0来禁用自动提交：

```
SET autocommit = 0;
```

这样，在执行SQL语句时，~~需要显式地使用`START TRANSACTION`来开启事务，并~~使用`COMMIT`或`ROLLBACK`来结束事务。



### 开启general_log

MySQL的general_log是一种日志记录功能，它可以记录MySQL服务器上执行的所有SQL语句，包括查询、更新、事务等操作。通过开启general_log，可以详细了解MySQL服务器上的数据库操作情况，方便进行故障排查、性能分析和安全审计等工作。

要开启MySQL的general_log，可以按照以下步骤进行：

0、查看开启情况

```sql
mysql> show variables like '%general_log%';
+------------------+-------------------------------------+
| Variable_name    | Value                               |
+------------------+-------------------------------------+
| general_log      | OFF                                 |
| general_log_file | /var/lib/mysql/VM-32-165-centos.log |
+------------------+-------------------------------------+

## 临时生效
mysql> set global general_log=on;
```

1、编辑MySQL的配置文件（my.cnf或my.ini），找到并修改以下参数：

```
general_log = on
general_log_file = /data/mysql/log/general.log
```

将general_log设置为1表示开启general_log功能，将general_log_file设置为指定的日志文件路径。

2、重启MySQL服务器，使配置生效。

```bash
systemctl restart mysqld.service 
```

3、执行业务逻辑或操作数据库，MySQL将会将所有的SQL语句记录到指定的general_log文件中。

```bash
cat  /data/mysql/log/general.log 
/usr/libexec/mysqld, Version: 8.0.36 (Source distribution). started with:
Tcp port: 3306  Unix socket: /var/lib/mysql/mysql.sock
Time                 Id Command    Argument
2024-05-14T12:23:10.904093Z         8 Query     show variables like '%general_log%'
2024-05-14T12:24:10.710862Z         8 Quit
```



请注意，开启general_log会产生大量的日志记录，因此在生产环境中应谨慎使用，以免对性能产生负面影响。在测试环境中使用general_log进行确认工作是一种常见的做法，但在生产环境中，应该根据具体需求和安全考虑来决定是否开启general_log。

另外，为了避免general_log文件过大，可以定期清理或限制其大小，以免占用过多的磁盘空间。



# 04 | 深入浅出索引（上）

提到数据库索引，我想你并不陌生，在日常工作中会经常接触到。比如某一个SQL查询比较慢， 分析完原因之后，你可能就会说“给某个字段加个索引吧”之类的解决方案。但到底什么是索引， 索引又是如何工作的呢？今天就让我们一起来聊聊这个话题吧。



数据库索引的内容比较多，我分成了上下两篇文章。索引是数据库系统里面最重要的概念之一， 所以我希望你能够耐心看完。在后面的实战文章中，我也会经常引用这两篇文章中提到的知识 点，加深你对数据库索引的理解。



一句话简单来说，**索引的出现其实就是为了提高数据查询的效率，就像书的目录index一样**。一本500 页的书，如果你想快速找到其中的某一个知识点，在不借助目录的情况下，那我估计你可得找一 会儿。同样，对于数据库的表而言，索引其实就是它的“目录”。



## 索引的常见模型 

索引的出现是为了提高查询效率，但是实现索引的方式却有很多种，所以这里也就引入了**索引模型**的概念。

可以用于提高读写效率的数据结构很多，这里我先给你介绍三种常见、也比较简单的数据结构，它们分别是**哈希表、有序数组和搜索树**。



### 哈希表

下面我主要从使用的角度，为你简单分析一下这三种模型的区别。 

**哈希表**是一种以键-值（key-value）存储数据的结构，我们只要输入待查找的值即key，就可以找 到其对应的值即Value。哈希的思路很简单，把值放在数组里，用一个哈希函数把key换算成一个确定的位置，然后把value放在数组的这个位置。

不可避免地，多个key值经过哈希函数的换算，会出现同一个值的情况。处理这种情况的一种方 法是，拉出一个链表。 假设，你现在维护着一个身份证信息和姓名的表，需要根据身份证号查找对应的名字，这时对应 的哈希索引的示意图如下所示：

<img src="MYSQL实战45讲.assets/image-20241227122512264.png" alt="image-20241227122512264" style="zoom:50%;" />



图中，User2和User4根据身份证号算出来的值都是N，但没关系，后面还跟了一个链表。假设， 这时候你要查ID_card_n2对应的名字是什么，处理步骤就是：首先，将ID_card_n2通过哈希函 数算出N；然后，按顺序遍历，找到User2。

需要注意的是，图中四个ID_card_n的值并不是递增的，这样做的好处是增加新的User时速度会 很快，只需要往后追加。但缺点是，因为不是有序的，所以**哈希索引做区间查询的速度是很慢的**。

你可以设想下，如果你现在要找身份证号在[ID_card_X, ID_card_Y]这个区间的所有用户，就必须全部扫描一遍了。 

所以，**哈希表这种结构适用于只有等值查询的场景**，比如Memcached及其他一些NoSQL引擎。



### 有序数组

而有序数组在等值查询和范围查询场景中的性能就都非常优秀。还是上面这个根据身份证号 查名字的例子，如果我们使用有序数组来实现的话，示意图如下所示：

<img src="MYSQL实战45讲.assets/image-20241227122829283.png" alt="image-20241227122829283" style="zoom: 50%;" />



这里我们假设身份证号没有重复，这个数组就是按照身份证号递增的顺序保存的。这时候如果你要查ID_card_n2对应的名字，用二分法就可以快速得到，这个时间复杂度是O(log(N))。

同时很显然，这个索引结构支持范围查询。你要查身份证号在[ID_card_X, ID_card_Y]区间的 User，可以先用二分法找到ID_card_X（如果不存在ID_card_X，就找到大于ID_card_X的第一 个User），然后向右遍历，直到查到第一个大于ID_card_Y的身份证号，退出循环。 如果**仅仅看查询效率，有序数组就是最好的数据结构**了。但是，在需要**更新数据的时候就麻烦**了，你往中间插入一个记录就必须得挪动后面所有的记录，成本太高。



所以，**有序数组索引只适用于静态存储引擎**，比如你要保存的是2017年某个城市的所有人口 信息，这类不会再修改的数据。



### 二叉搜索树

二叉搜索树也是课本里的经典数据结构了。还是上面根据**身份证号查名字**的例子，如果我们用二叉搜索树来实现的话，示意图如下所示：

<img src="MYSQL实战45讲.assets/image-20241227123154069.png" alt="image-20241227123154069" style="zoom:50%;" />

二叉搜索树的特点是：每个节点的左儿子小于父节点，父节点又小于右儿子。这样如果你要查 ID_card_n2的话，按照图中的搜索顺序就是按照UserA ->UserC->UserF ->User2这个路径得 到。这个时间复杂度是O(log(N))。

当然为了维持O(log(N))的查询复杂度，你就需要**保持这棵树是平衡二叉树**。为了做这个保证，更新的时间复杂度也是O(log(N))。



树可以有二叉，也可以有多叉。多叉树就是每个节点有多个儿子，儿子之间的大小保证从左到右 递增。

二叉树是搜索效率最高的，但是实际上大多数的数据库存储却并不使用二叉树。其原因是，索引不止存在内存中，还要写到磁盘上。



你可以想象一下一棵100万节点的平衡二叉树，树高20。一次查询可能需要访问20个数据块。在 机械硬盘时代，从磁盘随机读一个数据块需要10 ms左右的寻址时间。也就是说，对于一个100 万行的表，如果使用二叉树来存储，单独访问一个行可能需要20个10 ms的时间，这个查询可真够慢的。



为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该 使用二叉树，而是要使用“N叉”树。这里，“N叉”树中的“N”取决于**数据块**的大小。



以InnoDB的一个整数字段索引为例，这个N差不多是1200。这棵树高是4的时候，就可以存 1200的3次方个值，这已经17亿了。考虑到树根的数据块总是在内存中的，一个10亿行的表上一 个整数字段的索引，查找一个值最多只需要访问3次磁盘。其实，树的第二层也有很大概率在内 存中，那么访问磁盘的平均次数就更少了。



N叉树由于在读写上的性能优点，以及适配磁盘的访问模式，已经被广泛应用在数据库引擎中 了。 不管是哈希还是有序数组，或者N叉树，它们都是不断迭代、不断优化的产物或者解决方案。数 据库技术发展到今天，跳表、LSM树等数据结构也被用于引擎设计中，这里我就不再一一展开 了。



你心里要有个概念，数据库底层存储的核心就是基于这些数据模型的。每碰到一个新数据库，我 们需要先关注它的数据模型，这样才能从理论上分析出这个数据库的适用场景。 截止到这里，我用了半篇文章的篇幅和你介绍了不同的数据结构，以及它们的适用场景，你可能 会觉得有些枯燥。但是，我建议你还是要多花一些时间来理解这部分内容，毕竟这是数据库处理 数据的核心概念之一，在分析问题的时候会经常用到。当你理解了索引的模型后，就会发现在分 析问题的时候会有一个更清晰的视角，体会到引擎设计的精妙之处。 



## InnoDB 的索引模型

现在，我们一起进入相对偏实战的内容吧。在MySQL中，索引是在存储引擎层实现的，所以并没有统一的索引标准，即不同存储引擎的索 引的工作方式并不一样。而即使多个存储引擎支持同一种类型的索引，其底层的实现也可能不 同。由于InnoDB存储引擎在MySQL数据库中使用最为广泛，所以下面我就以InnoDB为例，和 你分析一下其中的索引模型。



在InnoDB中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。 又因为前面我们提到的，InnoDB使用了B+树索引模型，所以数据都是存储在B+树中的。 每一个索引在InnoDB里面对应一棵B+树。 假设，我们有一个主键列为ID的表，表中有字段k，并且在k上有索引。



这个表的建表语句是：

```mysql
mysql> create table T (
    id int primary key,
    k int not null,
    name varchar(16),
    index (k))engine=InnoDB;
```



表中R1~R5的(id,k)值分别为(100,1)、(200,2)、(300,3)、(500,5)和(600,6)，两棵树的示例示意 图如下。

<img src="MYSQL实战45讲.assets/image-20241227174542135.png" alt="image-20241227174542135" style="zoom:50%;" />

从图中不难看出，根据叶子节点的内容，索引类型分为主键索引和非主键索引。 主键索引的叶子节点存的是整行数据。

在InnoDB里，主键索引也被称为聚簇索引（clustered index）。 

非主键索引的叶子节点内容是主键的值。在InnoDB里，非主键索引也被称为二级索引 （secondary index）。



根据上面的索引结构说明，我们来讨论一个问题：基于主键索引和普通索引的查询有什么区别？

- 如果语句是select *fromTwhere ID=500，即主键查询方式，则只需要搜索ID这棵B+树； 
- 如果语句是select *fromTwhere k=5，即普通索引查询方式，则需要先搜索k索引树，得到ID 的值为500，再到ID索引树搜索一次。这个过程称为**回表**。 

也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主 键查询。



## 索引维护(更新)

B+树为了维护**索引有序性**，在插入新值的时候需要做必要的维护。



以上面这个图为例，如果插 入新的行ID值为700，则只需要在R5的记录后面插入一个新记录。

如果新插入的ID值为400，就 相对麻烦了，需要逻辑上挪动后面的数据，空出位置。

而更糟的情况是，如果R5所在的数据页已经满了，根据B+树的算法，这时候需要申请一个新的 数据页，然后挪动部分数据过去。这个过程称为**页分裂**。在这种情况下，性能自然会受影响。



除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中， 整体空间利用率降低大约50%。



当然有分裂就有合并。当相邻两个页由于删除了数据，利用率很低之后，会将数据页做**合并**。合并的过程，可以认为是分裂过程的逆过程。 基于上面的索引维护过程说明，我们来讨论一个案例：

> 你可能在一些建表规范里面见到过类似的描述，要求建表语句里一定要有自增主键。当然事无 绝对，我们来分析一下哪些场景下应该使用自增主键，而哪些场景下不应该。

自增主键是指自增列上定义的主键，在建表语句中一般是这么定义的： NOT NULL PRIMARY KEY AUTO_INCREMENT。

插入新记录的时候可以不指定ID的值，系统会获取当前ID最大值加1作为下一条记录的ID值。 也就是说，自增主键的插入数据模式，正符合了我们前面提到的递增插入的场景。每次插入一条 新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。



而有业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。

除了考虑性能外，我们还可以从存储空间的角度来看。假设你的表中确实有一个唯一字段，比如 字符串类型的身份证号，那应该用身份证号做主键，还是用自增字段做主键呢？ 

由于每个非主键索引的叶子节点上都是主键的值。如果用身份证号做主键，那么每个二级索引的 叶子节点占用约20个字节，而如果用整型做主键，则只要4个字节，如果是长整型（bigint）则是8个字节。 显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。 所以，**从性能和存储空间方面考量，自增主键往往是更合理的选择**。



有没有什么场景适合用业务字段直接做主键的呢？还是有的。比如，有些业务的场景需求是这样 的： 1. 只有一个索引； 2. 该索引必须是唯一索引。 你一定看出来了，这就是典型的KV场景。 由于没有其他索引，所以也就不用考虑其他索引的叶子节点大小的问题。 这时候我们就要优先考虑上一段提到的“尽量使用主键查询”原则，直接将这个索引设置为主键， 可以避免每次查询需要搜索两棵树。



## 小结

今天，我跟你分析了数据库引擎可用的数据结构，介绍了InnoDB采用的B+树结构，以及为什么 InnoDB要这么选择。

B+树能够很好地配合磁盘的读写特性，减少单次查询的磁盘访问次数。 

由于InnoDB是索引组织表，一般情况下我会建议你创建一个自增主键，这样非主键索引占用的 空间最小。

但事无绝对，我也跟你讨论了使用业务逻辑字段做主键的应用场景。 



## 问题

最后，我给你留下一个问题吧。对于上面例子中的InnoDB表T，如果你要重建索引 k，你的两个 SQL语句可以这么写：

```
alter table T drop index k;
alter table T add index(k);
```

如果你要重建主键索引，也可以这么写：

```
alter table T drop primary key;
alter table T add primary key(id);
```

我的问题是，对于上面这两个重建索引的作法，说出你的理解。如果有不合适的，为什么，更好 的方法是什么？

你可以把你的思考和观点写在留言区里，我会在下一篇文章的末尾给出我的参考答案。感谢你的 收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。



### 回答

在评论区，有同学问到为什么要重建索引。我们文章里面有提到，索引可能因为删除，或者页分 裂等原因，导致数据页有空洞，重建索引的过程会创建一个新的索引，把数据按顺序插入，这样 页面的利用率最高，也就是索引更紧凑、更省空间。 

这道题目，我给你的“参考答案”是： 重建索引k的做法是合理的，可以达到省空间的目的。但是，重建主键的过程不合理。不论是删 除主键还是创建主键，都会将整个表重建。所以连着执行这两个语句的话，第一个语句就白做 了。这两个语句，你可以用这个语句代替 ： `alter table T engine=InnoDB`





### chatGPT

不合适的地方

1. **性能问题**：
   - 在删除索引和重新添加索引的过程中，表会被锁定，可能会导致长时间的写入延迟，影响应用程序的性能。
   - 对于大型表，删除和重新创建索引可能会消耗大量的时间和资源。
2. **数据完整性**：
   - 在删除主键索引期间，表的完整性可能会受到影响，尤其是如果有外键依赖于该主键。
3. **事务安全性**：
   - 如果在删除索引和添加索引之间发生错误，可能会导致表处于不一致状态。

更好的方法

1. **使用 `ALTER TABLE ... DROP INDEX ... ADD INDEX ...` 一次性重建索引**：

   - MySQL 允许在同一个 `ALTER TABLE` 语句中同时删除和添加索引，这样可以减少锁定时间和资源消耗。

   ```sql
   ALTER TABLE T DROP INDEX k, ADD INDEX  k_name(k);
   ```

   ![image-20241227181041450](MYSQL实战45讲.assets/image-20241227181041450.png)

2. **使用 `ALTER TABLE ... CHANGE` 或 `MODIFY`**：

   - 对于主键索引，可以使用 `CHANGE` 或 `MODIFY` 来重建主键，而不需要显式地删除它。

   ```sql
   ALTER TABLE employees CHANGE id id INT NOT NULL PRIMARY KEY;
   ALTER TABLE employees MODIFY id INT NOT NULL PRIMARY KEY;
   
   ```

3. **使用 `ONLINE` 选项**（如果使用的是 MySQL 5.6 及以上版本）：

   - 在某些情况下，可以使用 `ONLINE` 选项来重建索引而不锁定表。

   ```
   ALTER TABLE T ADD INDEX k (column_name) ALGORITHM=INPLACE, LOCK=NONE;
   ```





# 05 | 深入浅出索引（下）

今天我们再继续聊聊跟MySQL索 引有关的概念。 

在开始这篇文章之前，我们先来看一下这个问题： 在下面这个表T中，如果我执行 `select * from T where k between 3 and 5`，需要执行几次树的搜索操作，会扫描多少行？ 下面是这个表的初始化语句。

```sql
mysql> create table T (
ID int primary key,
k int NOT NULL DEFAULT 0,
s varchar(16) NOT NULL DEFAULT '',
index k(k))
engine=InnoDB;


insert into T values(100,1, 'aa'),(200,2,'bb'),(300,3,'cc'),(500,5,'ee'),(600,6,'ff'),(700,7,'gg')
```

<img src="MYSQL实战45讲.assets/image-20241227200431625.png" alt="image-20241227200431625" style="zoom:50%;" />



现在，我们一起来看看这条SQL查询语句的执行流程： 

1. 在k索引树上找到k=3的记录，取得 ID = 300； 
2.  再到ID索引树查到ID=300对应的R3； 
3. 在k索引树取下一个值k=5，取得ID=500； 
4. 再回到ID索引树查到ID=500对应的R4； 
5. 在k索引树取下一个值k=6，不满足条件，循环结束。



在这个过程中，回到主键索引树搜索的过程，我们称为回表。

可以看到，这个查询过程读了k 索引树的3条记录（步骤1、3和5），回表了两次（步骤2和4）。 在这个例子中，由于查询结果所需要的数据只在主键索引上有，所以不得不回表。那么，有没有可能经过索引优化，避免回表过程呢？



## 覆盖索引

如果执行的语句是select ID fromTwhere k between 3 and 5，这时只需要查ID的值，而ID的值 已经在k索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，**在这个查询里面， 索引k已经“覆盖了”我们的查询需求，我们称为覆盖索引**。



由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。 

需要注意的是，在引擎内部使用覆盖索引在索引k上其实读了三个记录，R3~R5（对应的索引k 上的记录项），但**是对于MySQL的Server层来说，它就是找引擎拿到了两条记录，因此MySQL 认为扫描行数是2(两次回表）**。

> 备注：关于如何查看扫描行数的问题，我将会在第16文章《如何正确地显示随机消息？》 中，和你详细讨论。



基于上面覆盖索引的说明，我们来讨论一个问题：在一个市民信息表上，是否有必要将身份证号和名字建立联合索引？ 假设这个市民表的定义是这样的：

```sql
CREATE TABLE `tuser` (
    `id` int(11) NOT NULL,
    `id_card` varchar(32) DEFAULT NULL,
    `name` varchar(32) DEFAULT NULL,
    `age` int(11) DEFAULT NULL,
    `ismale` tinyint(1) DEFAULT NULL,
    PRIMARY KEY (`id`),
    KEY `id_card` (`id_card`),
    KEY `name_age` (`name`,`age`)
) ENGINE=InnoDB

```



我们知道，身份证号是市民的唯一标识。也就是说，如果有根据身份证号查询市民信息的需求， 我们只要在身份证号字段上建立索引就够了。而再建立一个（身份证号、姓名）的联合索引，是 不是浪费空间？

如果现在有一个高频请求，要根据市民的身份证号查询他的姓名，这个联合索引就有意义了。它 可以在这个高频请求上用到覆盖索引，不再需要回表查整行记录，减少语句的执行时间。

当然，索引字段的维护总是有代价的。因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑 了。这正是业务DBA，或者称为业务数据架构师的工作。



## 最左前缀原则

看到这里你一定有一个疑问，如果为每一种查询都设计一个索引，索引是不是太多了。如果我现 在要按照市民的身份证号去查他的家庭地址呢？虽然这个查询需求在业务中出现的概率不高，但 总不能让它走全表扫描吧？反过来说，单独为一个不频繁的请求创建一个（身份证号，地址）的 索引又感觉有点浪费。应该怎么做呢？ 

这里，我先和你说结论吧。**B+树这种索引结构，可以利用索引的“最左前缀”，来定位记录。** 为了直观地说明这个概念，我们用（name，age）这个联合索引来分析。

<img src="MYSQL实战45讲.assets/image-20250102122626442.png" alt="image-20250102122626442" style="zoom: 50%;" />



可以看到，索引项是按照索引定义里面出现的字段顺序排序的。 当你的逻辑需求是查到所有名字是“张三”的人时，可以快速定位到ID4，然后向后遍历得到所有 需要的结果。

如果你要查的是所有名字第一个字是“张”的人，你的SQL语句的条件是"where name like ‘张%’"。这时，你也能够用上这个索引，查找到第一个符合条件的记录是ID3，然后向后遍历， 直到不满足条件为止。 

可以看到，不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。**这个最左 前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符**。



基于上面对最左前缀索引的说明，我们来讨论一个问题：在建立联合索引的时候，**如何安排索 引内的字段顺序**。 

这里我们的评估标准是，索引的复用能力。因为可以支持最左前缀，所以当已经有了(a,b)这个联 合索引后，一般就不需要单独在a上建立索引了。

因此，**第一原则是，如果通过调整顺序，可 以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的**。



所以现在你知道了，这段开头的问题里，我们要为高频请求创建(身份证号，姓名）这个联合索 引，并用这个索引支持“根据身份证号查询地址”的需求。 

那么，如果既有联合查询，又有基于a、b各自的查询呢？查询条件里面只有b的语句，是无法使 用(a,b)这个联合索引的，这时候你不得不维护另外一个索引，也就是说你**需要同时维护(a,b)、 (b)** 这两个索引。

这时候，我们要考虑的原则就是空间了。比如上面这个市民表的情况，name字段是比age字段 大的 ，那我就建议你创建一个（name,age)的联合索引和一个(age)的单字段索引。



## 索引下推

上一段我们说到满足最左前缀原则的时候，最左前缀可以用于在索引中定位记录。这时，你可能 要问，那些不符合最左前缀的部分，会怎么样呢？ 

我们还是以市民表的联合索引（name, age）为例。如果现在有一个需求：检索出表中“名字第一 个字是张，而且年龄是10岁的所有男孩”。那么，SQL语句是这么写的：

```sql
mysql> select * from tuser where name like '张%' and age=10 and ismale=1;
```



你已经知道了前缀索引规则，所以这个语句在搜索索引树的时候，只能用 “张”，找到第一个满足 条件的记录ID3。当然，这还不错，总比全表扫描要好。



然后呢？ 当然是判断其他条件是否满足。 在MySQL 5.6之前，只能从ID3开始一个个回表。到主键索引上找出数据行，再对比字段值。



而MySQL 5.6 引入的**索引下推优化（index condition pushdown)**， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。



图3和图4，是这两个过程的执行流程图。

<img src="MYSQL实战45讲.assets/image-20250103121301961.png" alt="image-20250103121301961" style="zoom: 50%;" />

<img src="MYSQL实战45讲.assets/image-20250103121414858.png" alt="image-20250103121414858" style="zoom:50%;" />



在图3和4这两个图里面，每一个虚线箭头表示回表一次。

图3中，在(name,age)索引里面我特意去掉了age的值，这个过程InnoDB并不会去看age的值， 只是按顺序把“name第一个字是’张’”的记录一条条取出来回表。因此，需要回表4次。 

图4跟图3的区别是，InnoDB在(name,age)索引内部就判断了age是否等于10，对于不等于10的 记录，直接判断并跳过。

在我们的这个例子中，只需要对ID4、ID5这两条记录回表取数据判 断，就只需要回表2次。



## 小结 

今天这篇文章，我和你继续讨论了数据库索引的概念，包括了**覆盖索引、前缀索引、索引下推**。 你可以看到，在满足语句需求的情况下， 尽量少地访问资源是数据库设计的重要原则之一。我 们在使用数据库的时候，尤其是在设计表结构时，也要以减少资源消耗作为目标。



### 问题

接下来我给你留下一个问题吧。 实际上主键索引也是可以使用多个字段的。DBA小吕在入职新公司的时候，就发现自己接手维 护的库里面，有这么一个表，表结构定义类似这样的：

```sql
CREATE TABLE `geek` (
    `a` int(11) NOT NULL,
    `b` int(11) NOT NULL,
    `c` int(11) NOT NULL,
    `d` int(11) NOT NULL,
    PRIMARY KEY (`a`,`b`),
    KEY `c` (`c`),
    KEY `ca` (`c`,`a`),
    KEY `cb` (`c`,`b`)
) ENGINE=InnoDB;

```

公司的同事告诉他说，由于历史原因，这个表需要a、b做联合主键，这个小吕理解了。 但是，学过本章内容的小吕又纳闷了，既然主键包含了a、b这两个字段，那意味着单独在字段c 上创建一个索引，就已经包含了三个字段了呀，为什么要创建“ca”“cb”这两个索引？ 同事告诉他，是因为他们的业务里面有这样的两种语句：

```
select * from geek where c=N order by a limit 1;
select * from geek where c=N order by b limit 1;
```

我给你的问题是，这位同事的解释对吗，为了这两个查询模式，这两个索引是否都是必须的？为 什么呢？



### 回答

上期的问题是关于对联合主键索引和InnoDB索引组织表的理解。

我直接贴@老杨同志 的回复略作修改如下（我修改的部分用橙色标出）： 

表记录

```
–a--|–b--|–c--|–d--
1 2 3 d
1 3 2 d
1 4 3 d
2 1 3 d
2 2 2 d
2 3 4 d
```

主键 a，b的聚簇索引组织顺序相当于 order bya,b ，也就是先按a排序，再按b排序，c无序。



索引 ca 的组织是先按c排序，再按a排序，同时记录主键

```
–c--|–a--|–主键部分b-- （注意，这里不是ab，而是只有b）
2 1 3
2 2 2
3 1 2
3 1 4
3 2 1
4 2 3
```

这个跟索引c的数据是一模一样的。



索引 cb 的组织是先按c排序，在按b排序，同时记录主键

```
–c--|–b--|–主键部分a-- （同上）
2 2 2
2 3 1
3 1 2
3 2 1
3 4 1
4 3 2
```

所以，结论是ca可以去掉，cb需要保留。

> PS：索引可以加快排序速度

如果您在MySQL中创建了一个索引，例如`KEY('a', 'b')`，并且您的SQL语句中包含了`ORDER BY b`子句，那么这个索引可以提高查询语句的性能。

索引的作用是加快数据库的查询速度，通过创建索引，MySQL可以更快地定位到满足查询条件的数据行。当您在索引中包含了`b`列，并且查询语句中使用了`ORDER BY b`进行排序时，MySQL可以直接利用索引中的排序信息，避免对所有数据进行排序操作。

具体来说，当查询语句包含`ORDER BY b`时，MySQL可以使用索引中的排序顺序来直接返回按照`b`列排序的结果，而无需额外的排序操作。这样可以大大减少查询的时间和资源消耗，提高查询性能。









# 06 | 全局锁和表锁 ：给表加个字段怎么有这么多阻碍？

数据库锁设计的初衷是处理并发问题。

作为多用户共享的资源，当出现并发访问的时候，数据库需要合理地控制资源的访问规则。而锁就是用来实现这些访问规则的重要数据结构。

根据加锁的范围，MySQL中的锁大致可以分为**全局锁、表级锁和行锁**。

这篇文章分享全局锁和表级锁。

需要说明的是，锁的设计比较复杂，这两篇文章不会涉及锁的具体实现细节，主要介绍的是碰到锁时的现象和其背后的原理。



## 全局锁

顾名思义，全局锁就是对整个数据库实例加锁。

### FTWRL

MySQL提供了一个加全局读锁的方法，命令是**Flush tables with read lock (FTWRL)**。

当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句

**全局锁的典型使用场景是，做全库逻辑备份。也就是把整库每个表都select出来存成文本。**

以前有一种做法，是通过FTWRL确保不会有其他线程对数据库做更新，然后对整个库做备份。

注意，在备份过程中整个库完全处于只读状态。但是让整库都只读，听上去就很危险（有以下问题）：

- 如果你在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆；
- 如果你在从库上备份，那么备份期间从库不能执行主库同步过来的binlog，会导致主从延迟。

看来加全局锁不太好。但是细想一下，备份为什么要加锁呢？我们来看一下不加锁会有什么问题。

假设你现在要维护“极客时间”的购买系统，关注的是用户账户余额表和用户课程表。

 现在发起一个逻辑备份。假设备份期间，有一个用户，他购买了一门课程，业务逻辑里就要扣掉 他的余额，然后往已购课程里面加上一门课。 如果时间顺序上是先备份账户余额表(u_account)，然后用户购买，然后备份用户课程表 (u_course)，会怎么样呢？你可以看一下这个图：

<img src="MYSQL实战45讲.assets/image-20250103193922935.png" alt="image-20250103193922935" style="zoom:50%;" />



可以看到，这个备份结果里，用户A的数据状态是“账户余额没扣，但是用户课程表里面已经多了一门课”。如果后面用这个备份来恢复数据的话，用户A就发现，自己赚了。

作为用户可别觉得这样可真好啊，你可以试想一下：如果备份表的顺序反过来，先备份用户课程表再备份账户余额表，又可能会出现什么结果？ 



也就是说，不加锁的话，备份系统备份得到的库（不同的表）不是一个逻辑时间点，这个视图是逻辑不一致的。

说到视图你肯定想起来了，我们在前面讲事务隔离的时候，其实是有一个方法能够拿到一致性视图的，对吧？是的，就是**在可重复读隔离级别下开启一个事务**。



### mysqldump工具

官方自带的逻辑备份工具是mysqldump。

**当mysqldump使用参数–single-transaction的时候**，导数据之前就会启动一个事务，来确保拿到一致性视图。

而由于MVCC的支持，这个过程中数据是可以正常更新的。

为什么还需要FTWRL呢？

一致性读是好，但前提是引擎要支持这个隔离级别。 

比如，对于MyISAM这种不支持事务的引擎，如果备份过程中有更新，总是只能取到最新的数据，那么就破坏了备份的一致性。

这时，我们就需要使用FTWRL命令了。如果有的表使用了不支持事务的引擎，那么备份就只能通过FTWRL方法。这往往是DBA要求业务开发人员使用InnoDB替代MyISAM的原因之一。



你也许会问，既然要全库只读，为什么不使用 既 set global readonly=true 的方式呢 的 ？确实readonly方式也可以让全库进入只读状态，但还是会建议你用FTWRL方式，主要有两个原因：

- 一是，在有些系统中，**readonly的值会被用来做其他逻辑**，比如用来判断一个库是主库还是备库。因此，修改global变量的方式影响面更大，我不建议你使用。
- 二是，**在异常处理机制上有差异**。如果执行FTWRL命令之后由于客户端发生异常断开，那么MySQL会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为readonly之后，如果客户端发生异常，则数据库就会一直保持readonly状态，这样会导致整个库长时间处于不可写状态，风险较高。

**业务的更新不只是增删改数据（DML)，还有可能是加字段等修改表结构的操作（DDL）。**不论是哪种方法，一个库被全局锁上以后，你要对里面任何一个表做加字段操作，都是会被锁住的。但是，即使没有被全局锁住，加字段也不是就能一帆风顺的，因为你还会碰到接下来我们要介绍的表级锁



## 表级锁

MySQL里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。

### 表锁

表锁的语法是 `lock tables ... read/write`.

与FTWRL类似，可以用`unlock tables`主动释放锁，也可以在客户端断开的时候自动释放。

需要注意，lock tables语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。

举个例子, 如果在某个线程A中执行**lock tables t1 read, t2 write;** 这个语句，则其他线程写t1、读写t2的语句都会被阻塞。同时，线程A在执行unlock tables之前，也只能执行读t1、读写t2的操作。连写t1都不允许，自然也不能访问其他表。

在还没有出现更细粒度的锁的时候，表锁是最常用的处理并发的方式。

而对于InnoDB这种支持**行锁**的引擎，一般不使用lock tables命令来控制并发，毕竟锁住整个表的影响面还是太大。



### 元数据锁（meta data lock，MDL)

MDL不需要显式使用，在访问一个表的时候会被自动加上。MDL的作用是，保证读写的正确性。你可以想象一下，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。

因此，**在MySQL 5.5版本中引入了MDL，当对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁**。

- 读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。(互斥的意思是只有一个锁)
- 读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行

虽然MDL锁是系统默认会加的，但却是你不能忽略的一个机制。比如下面这个例子，**经常看到有人掉到这个坑里：给一个小表加个字段，导致整个库挂了**。

**给一个表加字段，或者修改字段，或者加索引，需要扫描全表的数据**。

在对大表操作的时候，你肯定会特别小心，以免对线上服务造成影响。而实际上，即使是小表，操作不慎也会出问题。我们来看一下下面的操作序列，假设表t是一个小表。

<img src="MYSQL实战45讲.assets/image-20240604194259700.png" alt="image-20240604194259700" style="zoom:50%;" />

我们可以看到session A先启动，这时候会对表t加一个MDL读锁。由于session B需要的也是MDL读锁，因此可以正常执行。

之后session C会被blocked，是因为session A的MDL读锁还没有释放，而session C需要MDL写锁，因此只能被阻塞。



如果只有session C自己被阻塞还没什么关系，但是之后所有要在表t上新申请MDL读锁的请求也会被session C阻塞。前面我们说了，所有对表的增删改查操作都需要先申请MDL读锁，就都被锁住，等于这个表现在完全不可读写了。

如果某个表上的查询语句频繁，而且客户端有重试机制，也就是说超时后会再起一个新session

再请求的话，这个库的线程很快就会爆满。

你现在应该知道了，事务中的MDL锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。



基于上面的分析，我们来讨论一个问题，

**首先我们要解决掉长事务，事务不提交，就会一直占着MDL锁。**在MySQL的information_schema库的 innodb_trx表中，你可以查到当前执行中的事务。如果你要做DDL变更的表刚好有长事务在执行，要考虑先暂停DDL，或者kill掉这个长事务。



但考虑一下这个场景。如果你要变更的表是一个热点表，虽然数据量不大，但是上面的请求很频繁，而你不得不加个字段，你该怎么做呢？

这时候kill可能未必管用，因为新的请求马上就来了。

比较理想的机制是，在alter table语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到MDL写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。之后开发人员或者DBA再通过重试命令重复这个过程。

MariaDB已经合并了AliSQL的这个功能，所以这两个开源分支目前都支持DDL NOWAIT/WAITn这个语法

```
ALTER TABLE tbl_name NOWAIT add column ...
ALTER TABLE tbl_name WAIT N add column ...
```

## 小结

全局锁主要用在逻辑备份过程中。对于全部是InnoDB引擎的库，我建议你选择使用–singletransaction参数，对应用会更友好

表锁一般是在数据库引擎不支持行锁的时候才会被用到的。如果你发现你的应用程序里有lock tables这样的语句，你需要追查一下，比较可能的情况是： 要么是你的系统现在还在用MyISAM这类不支持事务的引擎，那要安排升级换引擎； 要么是你的引擎升级了，但是代码还没升级。我见过这样的情况，最后业务开发就是把lock tables 和 unlock tables 改成 begin 和 commit，问题就解决了。

MDL会直到事务提交才释放，在做表结构变更的时候，你一定要小心不要导致锁住线上查询和 更新。

### 问题

最后，我给你留一个问题吧。备份一般都会在备库上执行，你在用–single-transaction方法做逻 辑备份的过程中，如果主库上的一个小表做了一个DDL，比如给一个表上加了一列。这时候，从 备库上会看到什么现象呢？

> 回答

假设这个DDL是针对表t1的， 这里我把备份过程中几个关键的语句列出来：

```
Q1:SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;
Q2:START TRANSACTION WITH CONSISTENT SNAPSHOT；
/* other tables */
Q3:SAVEPOINT sp;
/* 时刻 1 */
Q4:show create table `t1`;
/* 时刻 2 */
Q5:SELECT * FROM `t1`;
/* 时刻 3 */
Q6:ROLLBACK TO SAVEPOINT sp;
/* 时刻 4 */
/* other tables */

```

1、在备份开始的时候，为了确保RR（可重复读）隔离级别，再设置一次RR隔离级别(Q1); 

2、启动事务，这里用 WITH CONSISTENTSNAPSHOT确保这个语句执行完就可以得到一个一致性 视图（Q2)；

3、设置一个保存点，这个很重要（Q3）；

4、showcreate 是为了拿到表结构(Q4)，然后正式导数据 （Q5），回滚到SAVEPOINTsp，在这里的作用是释放 t1的MDL锁 （Q6）。当然这部分属于“超纲”，上文正文里面都没提到。



DDL从主库传过来的时间按照效果不同，我打了四个时刻。题目设定为小表，我们假定到达后， 如果开始执行，则很快能够执行完成。

参考答案如下： 

1. 如果在Q4语句执行之前到达，现象：没有影响，备份拿到的是DDL后的表结构。 
2. 如果在“时刻 2”到达，则表结构被改过，Q5执行的时候，报 Table definition has changed, please retry transaction，现象：mysqldump终止； 
3. 如果在“时刻2”和“时刻3”之间到达，mysqldump占着t1的MDL读锁，binlog被阻塞，**现象： 主从延迟**，直到Q6执行完成。 
4. 从“时刻4”开始，mysqldump释放了MDL读锁，现象：没有影响，备份拿到的是DDL前的表结构。





# 07 | 行锁功过：怎么减少行锁对性能的影响？



在上一篇文章中，我跟你介绍了MySQL的全局锁和表级锁，今天我们就来讲讲MySQL的**行锁**。

MySQL的行锁是在引擎层由各个引擎自己实现的。但并不是所有的引擎都支持行锁，比如 **MyISAM引擎就不支持行锁**。

不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。

InnoDB是支持行锁的， 这也是MyISAM被InnoDB替代的重要原因之一。



我们今天就主要来聊聊InnoDB的行锁，以及如何通过减少锁冲突来提升业务并发度。

顾名思义，行锁就是针对数据表中行记录的锁。这很好理解，比如事务A更新了一行，而这时候 事务B也要更新同一行，则必须等事务A的操作完成后才能进行更新。



当然，数据库中还有一些没那么一目了然的概念和设计，这些概念如果理解和使用不当，容易导 致程序出现非预期行为，比如两阶段锁。



## 从两阶段锁说起

我先给你举个例子。在下面的操作序列中，事务B的update语句执行时会是什么现象呢？假设字 段id是表t的主键。

<img src="MYSQL实战45讲.assets/image-20250108181942677.png" alt="image-20250108181942677" style="zoom: 50%;" />

这个问题的结论取决于事务A在执行完两条update语句后，持有哪些锁，以及在什么时候释放。 你可以验证一下：实际上事务B的update语句会被阻塞，直到事务A执行commit之后，事务B才 能继续执行。



知道了这个答案，你一定知道了**事务A持有的两个记录的行锁，都是在commit的时候才释放的**。



也就是说，**在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放**。这个就是**两阶段锁协议**。



知道了这个设定，对我们使用事务有什么帮助呢？

那就是，如果你的事务中需要锁多个行，要**把最可能造成锁冲突、最可能影响并发度的锁尽量往后放**。我给你举个例子。



假设你负责实现一个电影票在线交易业务，顾客A要在影院B购买电影票。我们简化一点，这个 业务需要涉及到以下操作：

1. 从顾客A账户余额中扣除电影票价； 
2. 给影院B的账户余额增加这张电影票价；
3. 记录一条交易日志。

也就是说，要完成这个交易，我们需要update两条记录，并insert一条记录。当然，为了保证交易的原子性，我们要把这三个操作放在一个事务中。那么，你会怎样安排这三个语句在事务中的 顺序呢？

试想如果同时有另外一个顾客C要在影院B买票，那么这两个事务冲突的部分就是语句2了。因为 它们要更新同一个影院账户的余额，需要修改同一行数据。



根据两阶段锁协议，不论你怎样安排语句顺序，所有的操作需要的行锁都是在事务提交的时候才释放的。所以，如果你**把语句2安排在最后**，比如按照3、1、2这样的顺序，那么影院账户余额 这一行的锁时间就最少。这就最大程度地减少了事务之间的锁等待，提升了并发度。



好了，现在由于你的正确设计，影院余额这一行的行锁在一个事务中不会停留很长时间。但是， 这并没有完全解决你的困扰。



如果这个影院做活动，可以低价预售一年内所有的电影票，而且这个活动只做一天。于是在活动 时间开始的时候，你的MySQL就挂了。你登上服务器一看，CPU消耗接近100%，但整个数据库每秒就执行不到100个事务。这是什么原因呢？



这里，我就要说到死锁和死锁检测了。



## 死锁和死锁检测

当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致 这几个线程都进入无限等待的状态，称为死锁。这里我用数据库中的行锁举个例子。

<img src="MYSQL实战45讲.assets/image-20250108182637092.png" alt="image-20250108182637092" style="zoom:50%;" />

这时候，事务A在等待事务B释放id=2的行锁，而事务B在等待事务A释放id=1的行锁。 事务A和 事务B在互相等待对方的资源释放，就是进入了死锁状态。当出现死锁以后，有两种策略：

- 一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数 **innodb_lock_wait_timeout**来设置。 
- 另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数**innodb_deadlock_detect**设置为on，表示开启这个逻辑。

在InnoDB中，innodb_lock_wait_timeout的默认值是50s，意味着如果采用第一个策略，当出现 死锁以后，第一个被锁住的线程要过50s才会超时退出，然后其他线程才有可能继续执行。对于 在线服务来说，这个等待时间往往是无法接受的。

但是，我们又不可能直接把这个时间设置成一个很小的值，比如1s。这样当出现死锁的时候，确 实很快就可以解开，但如果不是死锁，而是简单的锁等待呢？所以，超时时间设置太短的话，会 出现很多误伤。



所以，正常情况下我们还是要采用第二种策略，即：主动死锁检测，而且 innodb_deadlock_detect的默认值本身就是on。主动死锁检测在发生死锁的时候，是能够快速发 现并进行处理的，但是它也是有额外负担的。



你可以想象一下这个过程：每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁。

那如果是我们上面说到的所有事务都要更新同一行的场景呢？



每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁，这是一个时间复杂度是 O(n)的操作。假设有1000个并发线程要同时更新同一行，那么死锁检测操作就是100万这个量级 的。虽然最终检测的结果是没有死锁，但是这期间要消耗大量的CPU资源。因此，你就会看到 CPU利用率很高，但是每秒却执行不了几个事务。



根据上面的分析，我们来讨论一下，**怎么解决由这种热点行更新导致的性能问题呢**？问题的**症结在于，死锁检测要耗费大量的CPU资源**。



**一种头痛医头的方法，就是如果你能确保这个业务一定不会出现死锁，可以临时把死锁检测关掉**。但是这种操作本身带有一定的风险，因为业务设计的时候一般不会把死锁当做一个严 重错误，毕竟出现死锁了，就回滚，然后通过业务重试一般就没问题了，这是业务无损的。而关 掉死锁检测意味着可能会出现大量的超时，这是业务有损的。



**另一个思路是控制并发度**。根据上面的分析，你会发现如果并发能够控制住，比如同一行同时最多只有10个线程在更新，那么死锁检测的成本很低，就不会出现这个问题。一个直接的想法就是，在客户端做并发控制。但是，你会很快发现这个方法不太可行，因为客户端很多。我见过一个应用，有600个客户端，这样即使每个客户端控制到只有5个并发线程，汇总到数据库服务端以后，峰值并发数也可能要达到3000。

因此，这个并发控制要做在数据库服务端。如果你有中间件，可以考虑在中间件实现；如果你的 团队有能修改MySQL源码的人，也可以做在MySQL里面。**基本思路就是，对于相同行的更新， 在进入引擎之前排队。**这样在InnoDB内部就不会有大量的死锁检测工作了。



可能你会问，如果团队里暂时没有数据库方面的专家，不能实现这样的方案，能不能从设 计上优化这个问题呢？

**你可以考虑通过将一行改成逻辑上的多行来减少锁冲突**。还是以影院账户为例，可以考虑放在多 条记录上，比如10个记录，影院的账户总额等于这10个记录的值的总和。这样每次要给影院账 户加金额的时候，随机选其中一条记录来加。这样每次冲突概率变成原来的1/10，可以减少锁等 待个数，也就减少了死锁检测的CPU消耗。

这个方案看上去是无损的，但其实这类方案需要根据业务逻辑做详细设计。如果账户余额可能会 减少，比如退票逻辑，那么这时候就需要考虑当一部分行记录变成0的时候，代码要有特殊处理。



## 小结

今天，我和你介绍了MySQL的行锁，涉及了两阶段锁协议、死锁和死锁检测这两大部分内容。

其中，我以两阶段协议为起点，和你一起讨论了在开发的时候如何安排正确的事务语句。这里的 原则/我给你的建议是：如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并 发度的锁的申请时机尽量往后放。

但是，调整语句顺序并不能完全避免死锁。所以我们引入了死锁和死锁检测的概念，以及提供了 三个方案，来减少死锁对数据库的影响。减少死锁的主要方向，就是控制访问相同资源的并发事 务量。



### 问题

最后，我给你留下一个问题吧。如果你要删除一个表里面的前10000行数据，有以下三种方法可 以做到：

- 第一种，直接执行delete fromTlimit 10000; 
- 第二种，在一个连接中循环执行20次 delete fromTlimit 500; 
- 第三种，在20个连接中同时执行delete fromTlimit 500。

你会选择哪一种方法呢？为什么呢？



### 回答

比较多的留言都选择了第二 种方式，即：在一个连接中循环执行20次 delete fromTlimit 500。 确实是这样的，第二种方式是相对较好的。

第一种方式（即：直接执行delete fromTlimit 10000）里面，单个语句占用时间长，锁的时间也 比较长；而且大事务还会导致主从延迟。

第三种方式（即：在20个连接中同时执行delete fromTlimit 500），会人为造成锁冲突（并发大）。



# 08 | 事务到底是隔离的还是不隔离的？



我在第3篇文章和你讲事务隔离级别的时候提到过，如果是可重复读隔离级别，事务T启动的时 候会创建一个视图read-view，之后事务T执行期间，即使有其他事务修改了数据，事务T看到的 仍然跟在启动时看到的一样。也就是说，一个在可重复读隔离级别下执行的事务，好像与世无争，不受外界影响。



但是，我在上一篇文章中，和你分享行锁的时候又提到，一个事务要更新一行，如果刚好有另外 一个事务拥有这一行的行锁，它又不能这么超然了，会被锁住，进入等待状态。问题是，既然进 入了等待状态，那么等到这个事务自己获取到行锁要更新数据的时候，它读到的值又是什么呢？



我给你举一个例子吧。下面是一个只有两行的表的初始化语句。

```sql
mysql> CREATE TABLE `t` (
`id` int(11) NOT NULL,
`k` int(11) DEFAULT NULL,
PRIMARY KEY (`id`)
) ENGINE=InnoDB;

insert into t(id, k) values(1,1),(2,2);
```



<img src="MYSQL实战45讲.assets/image-20250108192740451.png" alt="image-20250108192740451" style="zoom: 50%;" />

这里，我们需要注意的是**事务的启动时机**。

**begin/start transaction 命令**并不是一个事务的起点，**在执行到它们之后的第一个操作InnoDB表的语句，事务才真正启动（包括select语句）**。如果你想要马上启动一个事务，可以使用`start transaction with consistent snapshot` 这个命令。

还需要注意的是，在整个专栏里面，我们的例子中如果没有特别说明，都是默认 autocommit=1。

```mysql
mysql> SHOW VARIABLES like 'autocommit';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| autocommit    | ON    |
+---------------+-------+
```



在这个例子中，事务C没有显式地使用begin/commit，表示这个update语句本身就是一个事务， 语句完成的时候会自动提交。

事务B在更新了行之后查询; 

事务A在一个只读事务中查询，并且时间顺序上是在事务B的查询之后。



这时，如果我告诉你**事务B查到的k的值是3，而事务A查到的k的值是1**，你是不是感觉有点晕呢？



所以，今天这篇文章，我其实就是想和你说明白这个问题，希望借由把这个疑惑解开的过程，能 够帮助你对InnoDB的事务和锁有更进一步的理解。 在MySQL里，有两个“视图”的概念：

- 一个是view。它是一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。 创建视图的语法是create view…，而它的查询方法与表一样(一旦视图创建成功，您可以像查询表一样使用它)。

```mysql
mysql> CREATE VIEW v1 AS select * from T where id = 1;
Query OK, 0 rows affected (0.00 sec)


mysql> select * from v1 where id = 1;
+----+---+------+
| id | k | name |
+----+---+------+
|  1 | 1 | NULL |
+----+---+------+
1 row in set (0.00 sec)

mysql> SELECT TABLE_NAME
    -> FROM INFORMATION_SCHEMA.VIEWS
    -> WHERE TABLE_SCHEMA = 'test'
    -> ;
+------------+
| TABLE_NAME |
+------------+
| v1         |
+------------+

```



- 另一个是InnoDB在实现MVCC时用到的一致性读视图，即consistent read view，用于支持 RC（Read Committed，读提交）和RR（Repeatable Read，可重复读）隔离级别的实现。它没有物理结构，作用是事务执行期间用来定义“我能看到什么数据”。

在第3篇文章《事务隔离：为什么你改了我还看不见？》中，我跟你解释过一遍MVCC的实现逻 辑。今天为了说明查询和更新的区别，我换一个方式来说明，把read view拆开。你可以结合这 两篇文章的说明来更深一步地理解MVCC。



## “快照”在MVCC里是怎么工作的？

在可重复读隔离级别下，事务在启动的时候就“拍了个快照”。注意，这个快照是基于整库的。



这时，你会说这看上去不太现实啊。如果一个库有100G，那么我启动一个事务，MySQL就要拷 贝100G的数据出来，这个过程得多慢啊。可是，我平时的事务执行起来很快啊。 

实际上，我们并不需要拷贝出这100G的数据。我们先来看看这个快照是怎么实现的。

InnoDB里面每个事务有一个唯一的事务ID，叫作transaction id。它是在事务开始的时候向 InnoDB的事务系统申请的，是按申请顺序严格递增的。



而每行数据也都是有多个版本的。每次事务更新数据的时候，都会生成一个新的数据版本，并且 把t**ransaction id**赋值给这个数据版本的事务ID，记为**row trx_id**。同时，旧的数据版本要保留， 并且在新的数据版本中，能够有信息可以直接拿到它。



也就是说，数据表中的一行记录，其实可能有多个版本(row)，每个版本有自己的rowtrx_id。



如图2所示，就是一个记录被多个事务连续更新后的状态。

<img src="MYSQL实战45讲.assets/image-20250108193748598.png" alt="image-20250108193748598" style="zoom:50%;" />



图中虚线框里是同一行数据的4个版本，当前最新版本是V4，k的值是22，它是被transaction id 为25的事务更新的，因此它的rowtrx_id也是25。

你可能会问，前面的文章不是说，语句更新会生成undo log（回滚日志）吗？那么，undo log 在哪呢？

实际上，图2中的三个虚线箭头，就是undo log；而V1、V2、V3并不是物理上真实存在的，而 是每次需要的时候根据当前版本和undo log计算出来的。比如，需要V2的时候，就是通过V4依 次执行U3、U2算出来。



明白了多版本和rowtrx_id的概念后，我们再来想一下，InnoDB是怎么定义那个“100G”的快照 的。

按照可重复读的定义，一个事务启动的时候，能够看到所有已经提交的事务结果。但是之后，这 个事务执行期间，其他事务的更新对它不可见。



因此，一个事务只需要在启动的时候声明说，“以我启动的时刻为准，如果一个数据版本是在我启动之前生成的，就认；

如果是我启动以后才生成的，我就不认，我必须要找到它的上一个版本”。

当然，如果“上一个版本”也不可见，那就得继续往前找。还有，如果是这个事务自己更新的数据，它自己还是要认的。



在实现上， **InnoDB为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务ID。“活跃”指的就是，启动了但还没提交**。

**数组里面事务ID的最小值记为低水位，当前系统里面已经创建过的事务ID的最大值加1记为高水位**。

这个视图数组和高水位，就组成了**当前事务的一致性视图（read-view）**。

而数据版本的可见性规则，就是基于数据的rowtrx_id和这个一致性视图的对比结果得到的。



这个视图数组把所有的rowtrx_id 分成了几种不同的情况。

<img src="MYSQL实战45讲.assets/image-20250108194420594.png" alt="image-20250108194420594" style="zoom:50%;" />



这样，对于当前事务的启动瞬间来说，一个数据版本的row trx_id，有以下几种可能：

1. 如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；
2. 如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；

3. 如果落在黄色部分，那就包括两种情况
   1. 若 rowtrx_id在数组中，表示这个版本是由还没提交的事务生成的，不可见；
   2. 若 rowtrx_id不在数组中，表示这个版本是已经提交了的事务生成的，可见。

比如，对于图2中的数据来说，如果有一个事务，它的低水位是18，那么当它访问这一行数据 时，就会从V4通过U3计算出V3，所以在它看来，这一行的值是11。



你看，有了这个声明后，系统里面随后发生的更新，是不是就跟这个事务看到的内容无关了呢？ 因为之后的更新，生成的版本一定属于上面的2或者3(a)的情况，而对它来说，这些新的数据版本是不存在的，所以这个事务的快照，就是“静态”的了。



所以你现在知道了，**InnoDB利用了“所有数据都有多个版本”(版本链)的这个特性，实现了“秒级创建快照”的能力**。



接下来，我们继续看一下图1中的三个事务，**分析下事务A的语句返回的结果，为什么是k=1**。

<img src="MYSQL实战45讲.assets/image-20250108192740451.png" alt="image-20250108192740451" style="zoom: 50%;" />



```mysql
start transaction with consistent snapshot;
                                             update T set k=k+1 where id=1;
update T set k=k+1 where id=1;
select * from T where id =1;

commit;
```



这里，我们不妨做如下假设：

1. 事务A开始前，系统里面只有一个活跃事务ID是99；

2. 事务A、B、C的版本号分别是100、101、102，且当前系统里只有这四个事务；

3. 三个事务开始前，(1,1）这一行数据的rowtrx_id是90。

这样，事务A的视图数组就是[99,100], 事务B的视图数组是[99,100,101], 事务C的视图数组是 [99,100,101,102]。



为了简化分析，我先把其他干扰语句去掉，只画出跟事务A查询逻辑有关的操作：

<img src="MYSQL实战45讲.assets/image-20250108195034604.png" alt="image-20250108195034604" style="zoom:50%;" />

从图中可以看到，第一个有效更新是事务C，把数据从(1,1)改成了(1,2)。这时候，这个数据的最 新版本的rowtrx_id是102，而90这个版本已经成为了历史版本。

第二个有效更新是事务B，把数据从(1,2)改成了(1,3)。这时候，这个数据的最新版本（即row trx_id）是101，而102又成为了历史版本。

你可能注意到了，在事务A查询的时候，其实事务B还没有提交，但是它生成的(1,3)这个版本已经变成当前版本了。但这个版本对事务A必须是不可见的，否则就变成脏读了。

好，现在事务A要来读数据了，它的视图数组是[99,100]。当然了，**读数据都是从当前版本读起的**。所以，事务A查询语句的读数据流程是这样的： 找到(1,3)的时候，判断出rowtrx_id=101，比高水位大，处于红色区域，不可见； 接着，找到上一个历史版本，一看rowtrx_id=102，比高水位大，处于红色区域，不可见； 再往前找，终于找到了（1,1)，它的rowtrx_id=90，比低水位小，处于绿色区域，可见。



这样执行下来，虽然期间这一行数据被修改过，但是事务A不论在什么时候查询，看到这行数据的结果都是一致的，所以我们称之为一致性读。



这个判断规则是从代码逻辑直接转译过来的，但是正如你所见，用于人肉分析可见性很麻烦。 所以，我来给你翻译一下。

一个数据版本，对于一个事务视图来说，除了自己的更新总是可见以外，有三种情况： 

1. 版本未提交，不可见； 
2. 版本已提交，但是是在视图创建后提交的，不可见； 
3. 版本已提交，而且是在视图创建前提交的，可见。

现在，我们用这个规则来判断图4中的查询结果，事务A的查询语句的视图数组是在事务A启动的 时候生成的，这时候：

-  (1,3)还没提交，属于情况1，不可见；
-  (1,2)虽然提交了，但是是在视图数组创建之后提交的，属于情况2，不可见； 
- (1,1)是在视图数组创建之前提交的，可见。 

你看，去掉数字对比后，只用时间先后顺序来判断，分析起来是不是轻松多了。所以，后面我们 就都用这个规则来分析。



## 更新逻辑

细心的同学可能有疑问了：事务B的update语句，如果按照一致性读，好像结果不对哦？ 你看图5中，事务B的视图数组是先生成的，之后事务C才提交，不是应该看不见(1,2)吗，怎么能 算出(1,3)来?

<img src="MYSQL实战45讲.assets/image-20250205182207775.png" alt="image-20250205182207775" style="zoom:50%;" />



是的，如果事务B在更新之前查询一次数据，这个查询返回的k的值确实是1。

但是，当它要去更新数据的时候，就不能再在历史版本上更新了，否则事务C的更新就丢失了。 因此，事务B此时的set k=k+1是在（1,2）的基础上进行的操作。



所以，这里就用到了这样一条规则：更新数据都是先读后写的，而这个读，只能读当前的 值，称为**“当前读”（current read）**。



因此，在更新的时候，当前读拿到的数据是(1,2)，更新后生成了新版本的数据(1,3)，这个新版本 的rowtrx_id是101。 所以，在执行事务B查询语句的时候，一看自己的版本号是101，最新数据的版本号也是101，是 自己的更新，可以直接使用，所以查询得到的k的值是3。 

这里我们提到了一个概念，叫作当前读。

其实，**除了update语句外，select语句如果加锁，也是 当前读**。



所以，如果把事务A的查询语句`select * fromt where id=1`修改一下，加上`lock in share mode` 或 `for update`，也都可以读到版本号是101的数据，返回的k的值是3。

下面这两个select语句，就是 分别加了读锁（S锁，共享锁）和写锁（X锁，排他锁）。

```sql
mysql> select k from t where id=1 lock in share mode;
mysql> select k from t where id=1 for update;
```

再往前一步，假设事务C不是马上提交的，而是变成了下面的事务C’，会怎么样呢？ (A-1 B-3)

<img src="MYSQL实战45讲.assets/image-20250205194557380.png" alt="image-20250205194557380" style="zoom:50%;" />

事务C’的不同是，更新后并没有马上提交，在它提交前，事务B的更新语句先发起了。

前面说过 了，虽然事务C’还没提交，但是(1,2)这个版本也已经生成了，并且是当前的最新版本。

那么，事 务B的更新语句会怎么处理呢？ 

这时候，我们在上一篇文章中提到的**“两阶段锁协议”**就要上场了。

事务C’没提交，也就是说(1,2) 这个版本上的写锁还没释放。而事务B是当前读，必须要读最新版本，而且必须加锁，因此就被 锁住了，必须等到事务C’释放这个锁，才能继续它的当前读。

<img src="MYSQL实战45讲.assets/image-20250205194902332.png" alt="image-20250205194902332" style="zoom:50%;" />



到这里，我们把一致性读、当前读和行锁就串起来了。 

现在，我们再回到文章开头的问题：事务的可重复读的能力是怎么实现的？ 

可重复读的核心就是一致性读（consistent read）；而事务更新数据的时候，只能用当前读。

**如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待**。 

而读提交的逻辑和可重复读的逻辑类似，它们最主要的区别是：

- **在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图**，之后事务里的其他查询都共用这个一致性视图；
- 在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。



那么，我们再看一下，在读提交隔离级别下，事务A和事务B的查询语句查到的k，分别应该是多 少呢？ 

这里需要说明一下，“start transaction with consistent snapshot; ”的意思是从这个语句开始，创 建一个持续整个事务的一致性快照。所以，在读提交隔离级别下，这个用法就没意义了，等效于 普通的start transaction。

下面是读提交时的状态图，可以看到这两个查询语句的创建视图数组的时机发生了变化，就是图 中的read view框。（注意：这里，我们用的还是事务C的逻辑直接提交，而不是事务C’）

<img src="MYSQL实战45讲.assets/image-20250205195536661.png" alt="image-20250205195536661" style="zoom:50%;" />



<img src="MYSQL实战45讲.assets/image-20250205195554358.png" alt="image-20250205195554358" style="zoom: 50%;" />



这时，事务A的查询语句的视图数组是在执行这个语句的时候创建的，时序上(1,2)、(1,3)的生成 时间都在创建这个视图数组的时刻之前。但是，在这个时刻：

-  (1,3)还没提交，属于情况1，不可见；
-  (1,2)提交了，属于情况3，可见。



所以，这时候事务A查询语句返回的是k=2。 显然地，事务B查询结果k=3。





## 小结

InnoDB的行数据有多个版本，每个数据版本有自己的rowtrx_id，每个事务或者语句有自己的一 致性视图。

普通查询语句是一致性读，一致性读会根据rowtrx_id和一致性视图确定数据版本的 可见性。

- 对于可重复读，查询只承认在事务启动前就已经提交完成的数据； 
- 对于读提交，查询只承认在语句启动前就已经提交完成的数据；

你也可以想一下，为什么表结构不支持“可重复读”？这是因为表结构没有对应的行数据，也没有 rowtrx_id，因此只能遵循当前读的逻辑。

当然，MySQL 8.0已经可以把表结构放在InnoDB字典里了，也许以后会支持表结构的可重复 读。



### 思考题

又到思考题时间了。我用下面的表结构和初始化语句作为试验环境，事务隔离级别是**可重复读**。 现在，我要把所有“字段c和id值相等的行”的c值清零，但是却发现了一个“诡异”的、改不掉的情 况。请你构造出这种情况，并说明其原理。

```sql
mysql> CREATE TABLE `t` (
`id` int(11) NOT NULL,
`c` int(11) DEFAULT NULL,
PRIMARY KEY (`id`)
) ENGINE=InnoDB;
insert into t(id, c) values(1,1),(2,2),(3,3),(4,4);

```

<img src="MYSQL实战45讲.assets/image-20250205200514535.png" alt="image-20250205200514535" style="zoom:50%;" />

复现出来以后，请你再思考一下，在实际的业务开发中有没有可能碰到这种情况？你的应用代码会不会掉进这个“坑”里，你又是怎么解决的呢？



回答：

在单前读情况下数据改变了，满足不了==的条件了。

<img src="MYSQL实战45讲.assets/image-20250205200539952.png" alt="image-20250205200539952" style="zoom:50%;" />

- 第二种是事务B早开启并提交了结果（不commit的话，A的update会等待锁）。

这个操作序列跑出来，session A看的内容也是能够复现我截图的效果的。这个session B’启动的 事务比A要早，其实是上期我们描述事务版本的可见性规则时留的彩蛋，因为规则里还有一个“活 跃事务的判断”，我是准备留到这里再补充的。



**用新的方式来分析session B’的更新为什么对session A不可见就是：在session A视图数组创建 的瞬间，session B’是活跃的，属于“版本未提交，不可见”这种情况**。（beigin/start transaction时，在第一个操作表的语句（包括select）就生成视图了）



业务中如果要绕过这类问题，@约书亚提供了一个“乐观锁”的解法，大家可以去上一篇的留言区看一下。



# 09 | 普通索引和唯一索引，应该怎么选择？

在前面的基础篇文章中，我给你介绍过索引的基本概念，相信你已经了解了唯一索引和普通索引 的区别。今天我们就继续来谈谈，在不同的业务场景下，应该选择普通索引，还是唯一索引？

假设你在维护一个市民系统，每个人都有一个唯一的身份证号，而且业务代码已经保证了不会写 入两个重复的身份证号。如果市民系统需要按照身份证号查姓名，就会执行类似这样的SQL语 句：

```sql
select name from CUser where id_card = 'xxxxxxxyyyyyyzzzzz';
```

所以，你一定会考虑在id_card字段上建索引。

由于身份证号字段比较大，我不建议你把身份证号当做主键，那么现在你有两个选择，要么给 id_card字段创建唯一索引，要么创建一个普通索引。如果业务代码已经保证了不会写入重复的 身份证号，那么这两个选择逻辑上都是正确的。



现在我要问你的是，从性能的角度考虑，你选择唯一索引还是普通索引呢？选择的依据是什么呢？



简单起见，我们还是用第4篇文章《深入浅出索引（上）》中的例子来说明，假设字段 k 上的值 都不重复。

<img src="MYSQL实战45讲.assets/image-20250206115204121.png" alt="image-20250206115204121" style="zoom:50%;" />

接下来，我们就从这两种索引对查询语句和更新语句的性能影响来进行分析。



## 查询过程

假设，执行查询的语句是 select id fromTwhere k=5。这个查询语句在索引树上查找的过程，先 是通过B+树从树根开始，按层搜索到叶子节点，也就是图中右下角的这个数据页，然后可以认 为数据页内部通过二分法来定位记录。

- 对于普通索引来说，查找到满足条件的第一个记录(5,500)后，需要查找下一个记录，直到碰 到第一个不满足k=5条件的记录。 
- 对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继 续检索。

那么，这个不同带来的性能差距会有多少呢？

答案是，微乎其微。 你知道的，**InnoDB的数据是按数据页为单位来读写的。也就是说，当需要读一条记录的时候， 并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。**在InnoDB中，每 个数据页的大小默认是16KB。



因为引擎是按页读写的，所以说，当找到k=5的记录的时候，它所在的数据页就都在内存里了。 那么，对于普通索引来说，要多做的那一次“查找和判断下一条记录”的操作，就只需要一次指针 寻找和一次计算。



当然，如果k=5这个记录刚好是这个数据页的最后一个记录，那么要取下一个记录，必须读取下 一个数据页，这个操作会稍微复杂一些。 但是，我们之前计算过，对于整型字段，一个数据页可以放近千个key，因此出现这种情况的概 率会很低。所以，我们计算平均性能差异时，仍可以认为这个操作成本对于现在的CPU来说可以 忽略不计。



## 更新过程

为了说明普通索引和唯一索引对更新语句性能的影响这个问题，我需要先跟你介绍一下**change buffer**。



当需要更新一个数据页时，**如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话**，在不影响数据一致性的前提下，InooDB会将这些更新操作缓存在change buffer中，这样 就不需要从磁盘中读入这个数据页了。

在下次查询需要访问这个数据页的时候，将数据页读入内 存，然后执行change buffer中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。



需要说明的是，虽然名字叫作change buffer，实际上它是可以**持久化的数据**。也就是 说，change buffer在内存中有拷贝，也会被写入到磁盘上。



**将change buffer中的操作应用到原数据页，得到最新结果的过程称为merge。**除了访问这个数据页会触发merge外，系统有后台线程会定期merge。在数据库正常关闭（shutdown）的过程中，也会执行merge操作。



显然，如果能够将更新操作先记录在change buffer，减少读磁盘，语句的执行速度会得到明显 的提升。而且，数据读入内存是需要占用buffer pool的，所以这种方式还能够避免占用内存，提高内存利用率。



那么，什么条件下可以使用change buffer呢？

对于唯一索引来说，所有的更新操作都要先判断这个操作是否违反唯一性约束。比如，要插入 (4,400)这个记录，就要先判断现在表中是否已经存在k=4的记录，而这必须要将数据页读入内存才能判断。如果都已经读入到内存了，那直接更新内存会更快，就没必要使用change buffer 了。



因此，**唯一索引的更新就不能使用change buffer，实际上也只有普通索引可以使用**。



change buffer用的是buffer pool里的内存，因此不能无限增大。change buffer的大小，可以通 过参数`innodb_change_buffer_max_size`来动态设置。这个参数设置为50的时候，表示change buffer的大小最多只能占用buffer pool的50%。



现在，你已经理解了change buffer的机制，那么我们再一起来看看如果要在这张表中插入一个 新记录(4,400)的话，InnoDB的处理流程是怎样的。



第一种情况是，这个记录要更新的目标页在内存中。

这时，InnoDB的处理流程如下： 

- 对于唯一索引来说，找到3和5之间的位置，判断到没有冲突，插入这个值，语句执行结束； 
- 对于普通索引来说，找到3和5之间的位置，插入这个值，语句执行结束。

 这样看来，普通索引和唯一索引对更新语句性能影响的差别，只是一个判断，只会耗费微小的 CPU时间。



但这不是我们关注的重点。 第二种情况是，这个记录要更新的目标页不在内存中。这时，InnoDB的处理流程如下：

- 对于唯一索引来说，需要将数据页读入内存，判断到没有冲突，插入这个值，语句执行结束；
- 对于普通索引来说，则是将更新记录在change buffer，语句执行就结束了。

将数据从磁盘读入内存涉及随机IO的访问，是数据库里面成本最高的操作之一。

**change buffer 因为减少了随机磁盘访问，所以对更新性能的提升是会很明显的**。



之前我就碰到过一件事儿，有个DBA的同学跟我反馈说，他负责的某个业务的库内存命中率突 然从99%降低到了75%，整个系统处于阻塞状态，更新语句全部堵住。

而探究其原因后，我发现 这个业务有大量插入数据的操作，而他在前一天把其中的某个普通索引改成了唯一索引。



## change buffer的使用场景

通过上面的分析，你已经清楚了使用change buffer对更新过程的加速作用，也清楚了change buffer只限于用在普通索引的场景下，而不适用于唯一索引。那么，现在有一个问题就是：普通 索引的所有场景，使用change buffer都可以起到加速作用吗？



因为merge的时候是真正进行数据更新的时刻，而change buffer的主要目的就是将记录的变更动作缓存下来，

所以**在一个数据页做merge之前，change buffer记录的变更越多（也就是这个页面 上要更新的次数越多），收益就越大**。



因此，**对于写多读少的业务来说**，页面在写完以后马上被访问到的概率比较小，此时change buffer的使用效果最好。

这种业务模型常见的就是**账单类、日志类**的系统。



反过来，假设一个业务的更新模式是写入之后马上会做查询，那么即使满足了条件，将更新先记 录在change buffer，但之后由于马上要访问这个数据页，会立即触发merge过程。这样随机访问 IO的次数不会减少，反而增加了change buffer的维护代价。所以，对于这种业务模式来说，change buffer反而起到了副作用。



## 索引选择和实践

回到我们文章开头的问题，普通索引和唯一索引应该怎么选择。

其实，这两类索引在查询能力上 是没差别的，主要考虑的是对更新性能的影响。所以，我**建议你尽量选择普通索引**。

**如果所有的更新后面，都马上伴随着对这个记录的查询，那么你应该关闭change buffer。**而在 其他情况下，change buffer都能提升更新性能。

在实际使用中，你会发现，普通索引和change buffer的配合使用，对于数据量大的表的更新优 化还是很明显的。



特别地，在使用机械硬盘时，change buffer这个机制的收效是非常显著的。所以，当你有一个 类似“历史数据”的库，并且出于成本考虑用的是机械硬盘时，那你应该特别关注这些表里的索 引，尽量使用普通索引，然后把change buffer 尽量开大，以确保这个“历史数据”表的数据写入 速度。



## change buffer 和 redo log

理解了change buffer的原理，你可能会联想到我在前面文章中和你介绍过的redo log和WAL。

在前面文章的评论中，我发现有同学混淆了redo log和change buffer。WAL 提升性能的核心机 制，也的确是尽量减少随机读写，这两个概念确实容易混淆。所以，这里我把它们放到了同一个 流程里来说明，便于你区分这两个概念

> 备注：这里，你可以再回顾下第2篇文章《日志系统：一条SQL更新语句是如何执行的？》中 的相关内容。



现在，我们要在表上执行这个插入语句：

```
mysql> insert into t(id,k) values(id1,k1),(id2,k2);
```

这里，我们假设当前k索引树的状态，查找到位置后，k1所在的数据页在内存(InnoDB buffer pool)中，k2所在的数据页不在内存中。如图2所示是带change buffer的更新状态图。

<img src="MYSQL实战45讲.assets/image-20250206120816268.png" alt="image-20250206120816268" style="zoom:67%;" />



分析这条更新语句，你会发现它涉及了四个部分：内存、redo log（ib_log_fileX）、 数据表空间 （t.ibd）、系统表空间（ibdata1）。

这条更新语句做了如下的操作（按照图中的数字顺序）：

1. Page 1在内存中，直接更新内存；
2. Page 2没有在内存中，就在内存的change buffer区域，记录下“我要往Page 2插入一行”这个 信息
3. 将上述两个动作记入redo log中（图中3和4）。

做完上面这些，事务就可以完成了。所以，你会看到，执行这条更新语句的成本很低，就是写了两处内存，然后写了一处磁盘（写redo log，两次操作合在一起写了一次磁盘），而且还是顺序写的。



同时，图中的两个虚线箭头，是后台操作，不影响更新的响应时间。



那在这之后的读请求，要怎么处理呢？ 

比如，我们现在要执行 select *fromt where k in (k1, k2)。这里，我画了这两个读请求的流程 图。

如果读语句发生在更新语句后不久，内存中的数据都还在，那么此时的这两个读操作就与系统表 空间（ibdata1）和 redo log（ib_log_fileX）无关了。所以，我在图中就没画出这两部分。



<img src="MYSQL实战45讲.assets/image-20250206121123774.png" alt="image-20250206121123774" style="zoom:50%;" />



从图中可以看到：

1. 读Page 1的时候，直接从内存返回。有几位同学在前面文章的评论中问到，WAL之后如果 读数据，是不是一定要读盘，是不是一定要从redo log里面把数据更新以后才可以返回？其 实是不用的。你可以看一下图3的这个状态，虽然磁盘上还是之前的数据，但是这里直接从 内存返回结果，结果是正确的。
2. 要读Page 2的时候，需要把Page 2从磁盘读入内存中，然后应用change buffer里面的操作日志，生成一个正确的版本并返回结果。



可以看到，直到需要读Page 2的时候，这个数据页才会被读入内存。

 所以，如果要简单地对比这两个机制在提升更新性能上的收益的话，

- redo log 主要节省的是随机写磁盘的IO消耗（转成顺序写）
- 而change buffer主要节省的则是随机读磁盘的IO消耗。（减少读次数）



## 小结

今天，我从普通索引和唯一索引的选择开始，和你分享了数据的查询和更新过程，然后说明了 change buffer的机制以及应用场景，最后讲到了索引选择的实践。

由于唯一索引用不上change buffer的优化机制，因此如果业务可以接受，从性能角度出发我建 议你优先考虑非唯一索引。



### 思考题

最后，又到了思考题时间。 通过图2你可以看到，change buffer一开始是写内存的，那么如果这个时候机器掉电重启，会不 会导致change buffer丢失呢？change buffer丢失可不是小事儿，再从磁盘读入数据可就没有了 merge过程，就等于是数据丢失了。会不会出现这种情况呢？



你可以把你的思考和观点写在留言区里，我会在下一篇文章的末尾和你讨论这个问题。



回答：

我在上一篇文章最后留给你的问题是，如果某次写入使用了change buffer机制，之后主机异常 重启，是否会丢失change buffer和数据。 

这个问题的答案是**不会丢失**，留言区的很多同学都回答对了。虽然是只更新内存，但是在事务提 交的时候，我们把change buffer的操作也记录到redo log里了，所以崩溃恢复的时候，change buffer也能找回来。 

在评论区有同学问到，merge的过程是否会把数据直接写回磁盘，这是个好问题。这里，我再为你分析一下。

merge的执行流程是这样的： 

1. 从磁盘读入数据页到内存（老版本的数据页）； 
2. 从change buffer里找出这个数据页的change buffer 记录(可能有多个），依次应用，得到新版数据页； 
3. **写redo log**。这个redo log包含了数据的变更和change buffer的变更。

到这里merge过程就结束了。这时候，数据页和内存中change buffer对应的磁盘位置都还没有修 改，属于脏页，之后各自刷回自己的物理数据，就是另外一个过程了。



### 补充

评论区大家对“是否使用唯一索引”有比较多的讨论，主要是纠结在“业务可能无法确保”的情况。 这里，我再说明一下：

- 首先，业务正确性优先。咱们这篇文章的前提是“业务代码已经保证不会写入重复数据”的情况 下，讨论性能问题。如果业务不能保证，或者业务就是要求数据库来做约束，那么没得选， 必须创建唯一索引。这种情况下，本篇文章的意义在于，如果碰上了大量插入数据慢、内存 命中率低的时候，可以给你多提供一个排查思路。 
- 然后，在一些“归档库”的场景，你是可以考虑使用唯一索引的。比如，线上数据只需要保留半 年，然后历史数据保存在归档库。这时候，归档数据已经是确保没有唯一键冲突了。要提高归档效率，可以考虑把表里面的唯一索引改成普通索引。



# 10 | MySQL为什么有时候会选错索引？



前面我们介绍过索引，你已经知道了在MySQL中一张表其实是可以支持多个索引的。但是，你 写SQL语句的时候，并没有主动指定使用哪个索引。也就是说，使用哪个索引是由MySQL来确定的。 

不知道你有没有碰到过这种情况，一条本来可以执行得很快的语句，却由于MySQL选错了索 引，而导致执行速度变得很慢？



我们一起来看一个例子吧。 我们先建一个简单的表，表里有a、b两个字段，并分别建上索引：

```sql
CREATE TABLE `t` (
`id` int(11) NOT NULL,
`a` int(11) DEFAULT NULL,
`b` int(11) DEFAULT NULL,
PRIMARY KEY (`id`),
KEY `a` (`a`),
KEY `b` (`b`)
) ENGINE=InnoDB;

```

然后，我们往表t中插入10万行记录，取值按整数递增，即：(1,1,1)，(2,2,2)，(3,3,3) 直到 (100000,100000,100000)。 我是用存储过程来插入数据的，这里我贴出来方便你复现：

```sql
delimiter ;;
create procedure idata()
begin
    declare i int;
    set i=1;
    while(i<=100000) do
        insert into t values(i, i, i);
        set i=i+1;
    end while;
end;;
delimiter ;
call idata();

```



接下来，我们分析一条SQL语句：

```
mysql> select * from t where a between 10000 and 20000;
```

你一定会说，这个语句还用分析吗，很简单呀，a上有索引，肯定是要使用索引a的。 你说得没错，图1显示的就是使用explain命令看到的这条语句的执行情况。

<img src="MYSQL实战45讲.assets/image-20250207194130079.png" alt="image-20250207194130079" style="zoom: 67%;" />



从图1看上去，这条查询语句的执行也确实符合预期，**key这个字段值是’a’**，表示优化器选择了索引a。

 不过别急，这个案例不会这么简单。在我们已经准备好的包含了10万行数据的表上，我们再做 如下操作。

<img src="MYSQL实战45讲.assets/image-20250207194253237.png" alt="image-20250207194253237" style="zoom:50%;" />



```
start transaction with consistent snapshot;
   -- delete from t;
   -- call idata();
   -- explain select * from t where a between 10000 and 20000;
   
commit;
```



这里，session A的操作你已经很熟悉了，它就是开启了一个事务。随后，session B把数据都删 除后，又调用了 idata这个存储过程，插入了10万行数据。



这时候，session B的查询语句select * fromt where a between 10000 and 20000就不会再选择索引a了。我们可以通过慢查询日志（slowlog）来查看一下具体的执行情况。

```
SELECT * FROM mysql.slow_log;
```

为了说明优化器选择的结果是否正确，我增加了一个对照，即：使用`force index(a)`来让优化器强 制使用索引a（这部分内容，我还会在这篇文章的后半部分中提到）。

下面的三条SQL语句，就是这个实验过程。

```
set long_query_time=0;
select * from t where a between 10000 and 20000; /*Q1*/
select * from t force index(a) where a between 10000 and 20000;/*Q2*/
```

- 第一句，是将慢查询日志的阈值设置为0，表示这个线程接下来的语句都会被记录入慢查询日 志中； 
- 第二句，Q1是session B原来的查询； 
- 第三句，Q2是加了force index(a)来和session B原来的查询语句执行情况对比。

如图3所示是这三条SQL语句执行完成后的慢查询日志。

<img src="MYSQL实战45讲.assets/image-20250207195823573.png" alt="image-20250207195823573" style="zoom: 67%;" />

可以看到，Q1扫描了10万行，显然是走了全表扫描，执行时间是40毫秒。Q2扫描了10001行， 执行了21毫秒。也就是说，我们在没有使用force index的时候，MySQL用错了索引，导致了更长的执行时间。

**(mysql 8.0 没有复现，可能是新版本给优化了)**

![image-20250207201651164](MYSQL实战45讲.assets/image-20250207201651164.png)

这个例子对应的是我们平常不断地删除历史数据和新增数据的场景。这时，MySQL竟然会选错 索引，是不是有点奇怪呢？今天，我们就从这个奇怪的结果说起吧。

## 优化器的逻辑

在第一篇文章中，我们就提到过，选择索引是优化器的工作。

而优化器选择索引的目的，是找到一个最优的执行方案，并用最小的代价去执行语句。在数据库 里面，扫描行数是影响执行代价的因素之一。扫描的行数越少，意味着访问磁盘数据的次数越 少，消耗的CPU资源越少。

当然，扫描行数并不是唯一的判断标准，优化器还会结合是否使用**临时表**、**是否排序**等因素进行 综合判断。

我们这个简单的查询语句并没有涉及到临时表和排序，所以MySQL选错索引肯定是在判断扫描 行数的时候出问题了。

那么，问题就是：扫描行数是怎么判断的？

MySQL在真正开始执行语句之前，并不能精确地知道满足这个条件的记录有多少条，而**只能根据统计信息来估算记录数。**



这个统计信息就是索引的“区分度”。显然，一个索引上不同的值越多，这个索引的区分度就越 好。而一个索引上不同的值的个数，我们称之为**“基数”（cardinality）**。也就是说，这个基数越 大，索引的区分度越好。（索引选择性）



我们可以使用show index方法，看到一个索引的基数。如图4所示，就是表t的show index的结果 。虽然这个表的每一行的三个字段值都是一样的，但是在统计信息中，这三个索引的基数值并不 同，而且其实都不准确。

```
show index from t;
```

![image-20250207201950352](MYSQL实战45讲.assets/image-20250207201950352.png)

那么，MySQL是怎样得到索引的基数的呢？这里，我给你简单介绍一下MySQL**采样统计**的方法。



为什么要采样统计呢？因为把整张表取出来一行行统计，虽然可以得到精确的结果，但是代价太 高了，所以只能选择“采样统计”。



采样统计的时候，**InnoDB默认会选择N个数据页，统计这些页面上的不同值**，得到一个平均 值，然后乘以这个索引的页面数，就得到了这个索引的基数。

而数据表是会持续更新的，索引统计信息也不会固定不变。所以，**当变更的数据行数超过1/M的时候**，会自动触发重新做一次索引统计。



在MySQL中，有两种存储索引统计的方式，可以通过设置参数`innodb_stats_persistent`的值来选 择：

- 设置为on的时候，表示统计信息会持久化存储。这时，默认的N是20，M是10。 
- 设置为off的时候，表示统计信息只存储在内存中。这时，默认的N是8，M是16。



由于是采样统计，所以不管N是20还是8，这个基数都是很容易不准的。 但，这还不是全部。



你可以从图4中看到，这次的索引统计值（cardinality列）虽然不够精确，但大体上还是差不多 的，选错索引一定还有别的原因。



其实索引统计只是一个输入，对于一个具体的语句来说，**优化器还要判断，执行这个语句本身要扫描多少行**。



接下来，我们再一起看看优化器预估的，这两个语句的扫描行数是多少。**rows**这个字段表示的是预计扫描行数。



![image-20250207202318317](MYSQL实战45讲.assets/image-20250207202318317.png)





其中，Q1的结果还是符合预期的，rows的值是104620；但是Q2的rows值是37116，偏差就大 了。而图1中我们用explain命令看到的rows是只有10001行，是这个偏差误导了优化器的判断。



到这里，可能你的第一个疑问不是为什么不准，而是优化器为什么放着扫描37000行的执行计划 不用，却选择了扫描行数是100000的执行计划呢？



这是因为，如果使用索引a，每次从索引a上拿到一个值，都要回到主键索引上查出整行数据， 这个代价优化器也要算进去的。而如果选择扫描10万行，是直接在主键索引上扫描的，没有额外的代价。

优化器会估算这两个选择的代价，从结果看来，优化器认为直接扫描主键索引更快。当然，从执 行时间看来，这个选择并不是最优的。



使用普通索引需要把回表的代价算进去，在图1执行explain的时候，也考虑了这个策略的代价 ， 但图1的选择是对的。也就是说，这个策略并没有问题。



所以冤有头债有主，MySQL选错索引，这件事儿还得归咎到没能准确地判断出扫描行数。至于 为什么会得到错误的扫描行数，这个原因就作为课后问题，留给你去分析了。



既然是统计信息不对，那就修正。`analyze table t` 命令，可以用来重新统计索引信息。我们来看 一下执行效果。

<img src="MYSQL实战45讲.assets/image-20250207202606343.png" alt="image-20250207202606343" style="zoom:50%;" />

这回对了。

所以在实践中，如果你发现explain的结果预估的rows值跟实际情况差距比较大，可以采用这个 方法来处理。



其实，如果只是索引统计不准确，通过analyze命令可以解决很多问题，但是前面我们说了，优 化器可不止是看扫描行数。

依然是基于这个表t，我们看看另外一个语句：

```
mysql> select * from t where (a between 1 and 1000) and (b between 50000 and 100000) order by b limit 1;
```

从条件上看，这个查询没有符合条件的记录，因此会返回空集合。 在开始执行这条语句之前，你可以先设想一下，如果你来选择索引，会选择哪一个呢？



为了便于分析，我们先来看一下a、b这两个索引的结构图。

<img src="MYSQL实战45讲.assets/image-20250207202829883.png" alt="image-20250207202829883" style="zoom:50%;" />

如果使用索引a进行查询，那么就是扫描索引a的前1000个值，然后取到对应的id，再到主键索 引上去查出每一行，然后根据字段b来过滤。显然这样需要扫描1000行。



如果使用索引b进行查询，那么就是扫描索引b的最后50001个值，与上面的执行过程相同，也是 需要回到主键索引上取值再判断，所以需要扫描50001行。



所以你一定会想，如果使用索引a的话，执行速度明显会快很多。那么，下面我们就来看看到底 是不是这么一回事儿。

图8是执行explain的结果。

![image-20250207202912863](MYSQL实战45讲.assets/image-20250207202912863.png)



可以看到，返回结果中key字段显示，这次优化器选择了索引b，而rows字段显示需要扫描的行 数是50198。

从这个结果中，你可以得到两个结论： 1. 扫描行数的估计值依然不准确； 2. 这个例子里MySQL又选错了索引。



## 索引选择异常和处理

一种方法是，像我们第一个例子一样，采用force index强行选择一个索引。MySQL会根据 词法解析的结果分析出可能可以使用的索引作为候选项，然后在候选列表中依次判断每个索引需 要扫描多少行。如果force index指定的索引在候选索引列表中，就直接选择这个索引，不再评估 其他索引的执行代价。



我们来看看第二个例子。刚开始分析时，我们认为选择索引a会更好。现在，我们就来看看执行 效果：

![image-20250208192653031](MYSQL实战45讲.assets/image-20250208192653031.png)



可以看到，原本语句需要执行2.23秒，而当你使用force index(a)的时候，只用了0.05秒，比优化 器的选择快了40多倍。



也就是说，优化器没有选择正确的索引，force index起到了“矫正”的作用。



不过很多程序员不喜欢使用force index，一来这么写不优美，二来如果索引改了名字，这个语句 也得改，显得很麻烦。而且如果以后迁移到别的数据库的话，这个语法还可能会不兼容。

但其实使用force index最主要的问题还是变更的及时性。因为选错索引的情况还是比较少出现 的，所以开发的时候通常不会先写上force index。而是等到线上出现问题的时候，你才会再去修 改SQL语句、加上force index。但是修改之后还要测试和发布，对于生产系统来说，这个过程不 够敏捷。

所以，数据库的问题最好还是在数据库内部来解决。那么，在数据库里面该怎样解决呢？



既然优化器放弃了使用索引a，说明a还不够合适，所以第二种方法就是，我们可以考虑修改 语句，引导MySQL使用我们期望的索引。比如，在这个例子里，显然把“order byb limit 1” 改 成 “order byb,a limit 1” ，语义的逻辑是相同的。

我们来看看改之后的效果：

![image-20250208192837078](MYSQL实战45讲.assets/image-20250208192837078.png)



之前优化器选择使用索引b，是因为它认为使用索引b可以避免排序（b本身是索引，已经是有序 的了，如果选择索引b的话，不需要再做排序，只需要遍历），所以即使扫描行数多，也判定为 代价更小。 

现在order byb,a 这种写法，要求按照b,a排序，就意味着使用这两个索引都需要排序。因此，扫 描行数成了影响决策的主要条件，于是此时优化器选了只需要扫描1000行的索引a。



当然，这种修改并不是通用的优化手段，只是刚好在这个语句里面有limit 1，因此如果有满足条 件的记录， order byb limit 1和order byb,a limit 1 都会返回b是最小的那一行，逻辑上一致，才 可以这么做。

如果你觉得修改语义这件事儿不太好，这里还有一种改法，图11是执行效果。



```sql
mysql> select * from (select * from t where (a between 1 and 1000) and (b between 50000 and 100000) order by b limit 100) alias limit 1;
```

![image-20250208192950571](MYSQL实战45讲.assets/image-20250208192950571.png)

在这个例子里，我们用limit 100让优化器意识到，使用b索引代价是很高的。其实是我们根据数 mysql> select * from (select * from t where (a between 1 and 1000) and (b between 50000 and 100000) order by b limit 100)alias limit 1; 据特征诱导了一下优化器，也不具备通用性。



第三种方法是，在有些场景下，我们可以新建一个更合适的索引，来提供给优化器做选 择，或删掉误用的索引。



不过，在这个例子中，我没有找到通过新增索引来改变优化器行为的方法。这种情况其实比较 少，尤其是经过DBA索引优化过的库，再碰到这个bug，找到一个更合适的索引一般比较难。

如果我说还有一个方法是删掉索引b，你可能会觉得好笑。但实际上我碰到过两次这样的例子， 最终是DBA跟业务开发沟通后，发现这个优化器错误选择的索引其实根本没有必要存在，于是 就删掉了这个索引，优化器也就重新选择到了正确的索引。



## 小结

今天我们一起聊了聊索引统计的更新机制，并提到了优化器存在选错索引的可能性。

对于由于索引统计信息不准确导致的问题，你可以用analyze table来解决。

而对于其他优化器误判的情况，你可以在应用端用force index来强行指定索引，也可以通过修改 语句来引导优化器，还可以通过增加或者删除索引来绕过这个问题。



你可能会说，今天这篇文章后面的几个例子，怎么都没有展开说明其原理。我要告诉你的是，今 天的话题，我们面对的是MySQL的bug，每一个展开都必须深入到一行行代码去量化，实在不是 我们在这里应该做的事情。



所以，我把我用过的解决方法跟你分享，希望你在碰到类似情况的时候，能够有一些思路。



你平时在处理MySQL优化器bug的时候有什么别的方法，也发到评论区分享一下吧。



### 思考题

最后，我给你留下一个思考题。前面我们在构造第一个例子的过程中，通过session A的配合， 让session B删除数据后又重新插入了一遍数据，然后就发现explain结果中，rows字段从10001 变成37000多。

而如果没有session A的配合，只是单独执行delete fromt 、call idata()、explain这三句话，会看 到rows字段其实还是10000左右。你可以自己验证一下这个结果。 这是什么原因呢？也请你分析一下吧。



回答：

上篇文章中的第一个例子，评论区有几位同学说没有复现，大家要检查一下隔离级别是不是 RR（Repeatable Read，可重复读），创建的表t是不是InnoDB引擎。我把复现过程做成了一 个视频，供你参考。



在上一篇文章最后，我给你留的问题是，为什么经过这个操作序列，explain的结果就不对了？这 里，我来为你分析一下原因。

delete 语句删掉了所有的数据，然后再通过call idata()插入了10万行数据，看上去是覆盖了原来 的10万行。

但是，session A开启了事务并没有提交，所以之前插入的10万行数据是不能删除的。这样，之 前的数据每一行数据都有两个版本，旧版本是delete之前的数据，新版本是标记为deleted的数 据。

这样，索引a上的数据其实就有两份。



然后你会说，不对啊，主键上的数据也不能删，那没有使用force index的语句，使用explain命令 看到的扫描行数为什么还是100000左右？（潜台词，如果这个也翻倍，也许优化器还会认为选 字段a作为索引更合适）



是的，不过这个是主键，主键是直接按照表的行数来估计的。而表的行数，优化器直接用的是 show table status的值。

这个值的计算方法，我会在后面有文章为你详细讲解

![image-20250208193839291](MYSQL实战45讲.assets/image-20250208193839291.png)



# 11 | 怎么给字符串字段加索引？

现在，几乎所有的系统都支持邮箱登录，如何在邮箱这样的字段上建立合理的索引，是我们今天要讨论的问题。

假设，你现在维护一个支持邮箱登录的系统，用户表是这么定义的：

```sql
mysql> create table SUser(
ID bigint unsigned primary key,
email varchar(64),
...
)engine=innodb;

```

由于要使用邮箱登录，所以业务代码中一定会出现类似于这样的语句：

```
mysql> select f1, f2 from SUser where email='xxx';
```

如果email这个字段上没有索引，那么这个语句就只能做全表扫描。



## 前缀索引

同时，**MySQL是支持前缀索引的，也就是说，你可以定义字符串的一部分作为索引**。

默认地，如果你创建索引的语句不指定前缀长度，那么索引就会包含整个字符串.

比如，这两个在email字段上创建索引的语句：

```mysql
mysql> alter table SUser add index index1(email);
或
mysql> alter table SUser add index index2(email(6));
```

第一个语句创建的index1索引里面，包含了每个记录的整个字符串；而第二个语句创建的index2索引里面，对于每个记录都是只取前6个字节。

那么，这两种不同的定义在数据结构和存储上有什么区别呢？如图2和3所示，就是这两个索引的示意图。

<img src="MYSQL实战45讲.assets/image-20240612200303046.png" alt="image-20240612200303046" style="zoom: 33%;" />

<img src="MYSQL实战45讲.assets/image-20240612200316004.png" alt="image-20240612200316004" style="zoom:50%;" />



从图中你可以看到，由于email(6)这个索引结构中每个邮箱字段都只取前6个字节（即：zhangs），所以**占用的空间会更小**，这就是使用前缀索引的优势。

但，这同时带来的损失是，**可能会增加额外的记录扫描次数**。

接下来，我们再看看下面这个语句，在这两个索引定义下分别是怎么执行的。

```sql
select id,name,email from SUser where email='zhangssxyz@xxx.com';
```

如果使用index1全字符索引，，执行顺序是这样的：

1. 从index1索引树找到满足索引值是’zhangssxyz@xxx.com’的这条记录，取得ID2的值；

2. 到主键上查到主键值是ID2的行，判断email的值是正确的，将这行记录加入结果集；

3. 取index1索引树上刚刚查到的位置的下一条记录，发现已经不满足email='zhangssxyz@xxx.com’的条件了，循环结束。

这个过程中，只需要回主键索引取一次数据，所以系统认为只扫描了一行。



如果使用index2前缀索引，，执行顺序是这样的：

1. 从index2索引树找到满足索引值是’zhangs’的记录，找到的第一个是ID1；

2. 到主键上查到主键值是ID1的行，判断出email的值不是’zhangssxyz@xxx.com’，这行记录丢

弃；

3. 取index2上刚刚查到的位置的下一条记录，发现仍然是’zhangs’，取出ID2，再到ID索引上取

整行然后判断，这次值对了，将这行记录加入结果集；

4. 重复上一步，直到在idxe2上取到的值不是’zhangs’时，循环结束。

在这个过程中，要回主键索引取4次数据，也就是扫描了4行。通过这个对比，你很容易就可以发现，使用前缀索引后，可能会导致查询语句读数据的次数变

多。

但是，对于这个查询语句来说，如果你定义的index2不是email(6)而是email(7），也就是说取email字段的前7个字节来构建索引的话，即满足前缀’zhangss’的记录只有一个，也能够直接查到ID2，只扫描一行就结束了。



也就是说使用前缀索引，**定义好长度，就可以做到既节省空间，又不用额外增加太多查询成本（增加查询次数）。**



于是，你就有个问题：**当要给字符串创建前缀索引时，有什么方法能够确定我应该使用多长的前缀呢？**

实际上，我们在建立索引时关注的是区分度，区分度越高越好。因为区分度越高，意味着重复的 键值越少。因此，我们可以通过统计索引上有多少个不同的值来判断要使用多长的前缀。



首先，你可以使用下面这个语句，算出这个列上有多少个不同的值：

```sql
mysql> select count(distinct email) as L from SUser;
```



然后，依次选取不同长度的前缀来看这个值，比如我们要看一下4~7个字节的前缀索引，可以用left函数，用下面这个语句：

```sql
mysql> select
    count(distinct left(email,4)) as L4,
    count(distinct left(email,5))as L5,
    count(distinct left(email,6))as L6,
    count(distinct left(email,7))as L7
from SUser;  
```

当然，使用前缀索引很可能会损失区分度，所以你需要预先设定一个可以接受的损失比例，比如 5%。然后，在返回的L4~L7中，找出不小于 L * 95%的值，假设这里L6、L7都满足，你就可以 选择前缀长度为6。



## 前缀索引对覆盖索引的影响

> 可能用不了覆盖索引

前面我们说了使用前缀索引可能会增加扫描行数，这会影响到性能。其实，前缀索引的影响不止如此，我们再看一下另外一个场景。

你先来看看这个SQL语句：

```sql
select id,email from SUser where email='zhangssxyz@xxx.com';
```

与前面例子中的SQL语句

```
select id,name,email from SUser where email='zhangssxyz@xxx.com';
```

相比，这个语句只要求返回id和email字段。



所以，如果使用index1（即email整个字符串的索引结构）的话，可以利用覆盖索引，从index1查 到结果后直接就返回了，不需要回到ID索引再去查一次。而如果使用index2（即email(6)索引结 构）的话，就不得不回到ID索引再去判断email字段的值。

即使你将index2的定义修改为email(18)的前缀索引，这时候虽然index2已经包含了所有的信息， 但InnoDB还是要回到id索引再查一下，因为系统并不确定前缀索引的定义是否截断了完整信息。



也就是说，使用前缀索引就用不上覆盖索引对查询性能的优化了，这也是你在选择是否使用前缀 索引时需要考虑的一个因素。



## 其他方式

对于类似于邮箱这样的字段来说，使用前缀索引的效果可能还不错。但是，遇到前缀的区分度不够好的情况时，我们要怎么办呢？

比如，我们国家的身份证号，一共18位，其中前6位是地址码，所以同一个县的人的身份证号前 6位一般会是相同的。

假设你维护的数据库是一个市的公民信息系统，这时候如果对身份证号做长度为6的前缀索引的 话，这个索引的区分度就非常低了。

按照我们前面说的方法，可能你需要创建长度为12以上的前缀索引，才能够满足区分度要求。 但是，索引选取的越长，占用的磁盘空间就越大，相同的数据页能放下的索引值就越少，搜索的 效率也就会越低。



那么，**如果我们能够确定业务需求里面只有按照身份证进行等值查询的需求，还有没有别的处理方法呢？**这种方法，既可以占用更小的空间，也能达到相同的查询效率。

答案是，有的。

### 倒序存储和hash字段

> 倒序存储

第一种方式是使用倒序存储。如果你存储身份证号的时候把它倒过来存，每次查询的时候，你 可以这么写：

```
mysql> select field_list from t where id_card = reverse('input_id_card_string');
```

由于身份证号的最后6位没有地址码这样的重复逻辑，所以最后这6位很可能就提供了足够的区 分度。当然了，实践中你不要忘记使用count(distinct)方法去做个验证。



> hash字段

第二种方式是使用hash字段。你可以在表上再创建一个整数字段，来保存身份证的校验码， 同时在这个字段上创建索引。

```sql
mysql> alter table t add id_card_crc int unsigned, add index(id_card_crc);
```

然后每次插入新记录的时候，都同时用crc32()这个函数得到校验码填到这个新字段。由于校验码 可能存在冲突，也就是说两个不同的身份证号通过crc32()函数得到的结果可能是相同的，所以你 的查询语句where部分要判断id_card的值是否精确相同。

```sql
mysql> select field_list from t where id_card_crc=crc32('input_id_card_string') and id_card='input_id_card_string'
```



这样，索引的长度变成了4个字节，比原来小了很多。

接下来，我们再一起看看使用倒序存储和使用hash字段这两种方法的异同点。



首先，它们的相同点是，都不支持范围查询。倒序存储的字段上创建的索引是按照倒序字符串的 方式排序的，已经没有办法利用索引方式查出身份证号码在[ID_X, ID_Y]的所有市民了。同样 地，hash字段的方式也只能支持等值查询。



它们的区别，主要体现在以下三个方面：



1. 从占用的额外空间来看，倒序存储方式在主键索引上，不会消耗额外的存储空间，而hash字 段方法需要增加一个字段。当然，倒序存储方式使用4个字节的前缀长度应该是不够的，如 果再长一点，这个消耗跟额外这个hash字段也差不多抵消了。
2. 在CPU消耗方面，倒序方式每次写和读的时候，都需要额外调用一次reverse函数，而hash 字段的方式需要额外调用一次crc32()函数。如果只从这两个函数的计算复杂度来看的 话，reverse函数额外消耗的CPU资源会更小些。
3. 从查询效率上看，使用hash字段方式的查询性能相对更稳定一些。因为crc32算出来的值虽 然有冲突的概率，但是概率非常小，可以认为每次查询的平均扫描行数接近1。而倒序存储 方式毕竟还是用的前缀索引的方式，也就是说还是会增加扫描行数。



## 小结

在今天这篇文章中，我跟你聊了聊字符串字段创建索引的场景。我们来回顾一下，你可以使用的方式有： 

1. 直接创建完整索引，这样可能比较占用空间； 
2. 创建前缀索引，节省空间，但会增加查询扫描次数，并且不能使用覆盖索引； 
3. 倒序存储，再创建前缀索引，用于绕过字符串本身前缀的区分度不够的问题；
4. 创建hash字段索引，查询性能稳定，有额外的存储和计算消耗，跟第三种方式一样，都不支持范围扫描。

在实际应用中，你要根据业务字段的特点选择使用哪种方式。

### 思考题

 好了，又到了最后的问题时间。

如果你在维护一个学校的学生信息数据库，学生登录名的统一格式是”学号@gmail.com", 而学号 的规则是：十五位的数字，其中前三位是所在城市编号、第四到第六位是学校编号、**第七位到第十位是入学年份、最后五位是顺序编号**。



系统登录的时候都需要学生输入登录名和密码，验证正确后才能继续使用系统。就只考虑登录验 证这个行为的话，你会怎么设计这个登录名的索引呢



回答：

由于这个学号的规则，无论是正向还是反向的前缀索引，重复度都比较高。

因为维护的只是一个 学校的，因此前面6位（其中，前三位是所在城市编号、第四到第六位是学校编号）其实是固定 的，邮箱后缀都是@gamil.com，因此可以只存入学年份加顺序编号，它们的长度是9位。 而其实在此基础上，可以用数字类型来存这9位数字。比如201100001，这样只需要占4个字 节。

其实这个就是一种hash，只是它用了最简单的转换规则：字符串转数字的规则，而刚好我 们设定的这个背景，可以保证这个转换后结果的唯一性。



评论区中，也有其他一些很不错的见解。 评论用户@封建的风 说，一个学校的总人数这种数据量，50年才100万学生，这个表肯定是小 表。为了业务简单，直接存原来的字符串。这个答复里面包含了“优化成本和收益”的思想，我觉 得值得at出来。 

@小潘 同学提了另外一个极致的方向。如果碰到表数据量特别大的场景，通过这种方式的收益 很不错的。



# 12 | 为什么我的MySQL会“抖”一下？

平时的工作中，不知道你有没有遇到过这样的场景，一条SQL语句，正常执行的时候特别快，但 是有时也不知道怎么回事，它就会变得特别慢，并且这样的场景很难复现，它不只随机，而且持 续时间还很短。

看上去，这就像是数据库“抖”了一下。今天，我们就一起来看一看这是什么原因。



## 你的SQL语句为什么变“慢”了



在前面第2篇文章《日志系统：一条SQL更新语句是如何执行的？》中，我为你介绍了WAL机 制。

> MySQL 中的 WAL（Write-Ahead Logging）机制是一种用于事务日志的持久化和恢复的技术。它是一种在写入数据之前先写入日志的方法，以确保数据的持久性和一致性。
>
> WAL 机制的工作原理如下：
>
> 1. 在执行事务操作之前，MySQL 将事务的修改操作写入一个称为 WAL 日志的特殊文件中，而不是直接写入磁盘上的数据文件。
> 2. WAL 日志记录了事务的每个修改操作，包括插入、更新和删除等。
> 3. 当事务提交时，MySQL 将修改操作应用到磁盘上的数据文件，以确保数据的持久性。
> 4. 如果系统崩溃或发生故障，MySQL 可以使用 WAL 日志来恢复数据的一致性。通过重新执行 WAL 日志中的操作，可以将数据文件恢复到崩溃之前的状态。
>
> WAL 机制的优点包括：
>
> - 提高了数据库的写入性能，因为数据的写入是顺序写入 WAL 日志文件，而不是随机写入数据文件。
> - 提供了更好的事务持久性和一致性，即使在系统崩溃或故障的情况下也能够恢复数据。
> - 减少了数据文件的随机写入，从而减少了磁盘 I/O 操作，提高了数据库的整体性能。



现在你知道了，InnoDB在处理更新语句的时候，只做了写日志这一个磁盘操作。这个日志 叫作redo log（重做日志），也就是《孔乙己》里咸亨酒店掌柜用来记账的粉板，在更新内存写 完redo log后，就返回给客户端，本次更新成功。



**做下类比的话，掌柜记账的账本是数据文件，记账用的粉板是日志文件（redo log），掌柜的记 忆就是内存**。

掌柜总要找时间把账本更新一下，这对应的就是把内存里的数据写入磁盘的过程，术语就是 flush。在这个flush操作执行之前，孔乙己的赊账总额，其实跟掌柜手中账本里面的记录是不一 致的。因为孔乙己今天的赊账金额还只在粉板上，而账本里的记录是老的，还没把今天的赊账算 进去。



当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”。内存数据写 入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页”。



不论是脏页还是干净页，都在内存中。在这个例子里，内存对应的就是掌柜的记忆。

接下来，我们用一个示意图来展示一下“孔乙己赊账”的整个操作过程。假设原来孔乙己欠账10 文，这次又要赊9文。

<img src="MYSQL实战45讲.assets/image-20250211182129265.png" alt="image-20250211182129265" style="zoom:50%;" />



回到文章开头的问题，你不难想象，平时执行很快的更新操作，其实就是在写内存和日志，而 **MySQL偶尔“抖”一下的那个瞬间，可能就是在刷脏页（flush）**。

那么，什么情况会引发数据库的flush过程呢？



我们还是继续用咸亨酒店掌柜的这个例子，想一想：掌柜在什么情况下会把粉板上的赊账记录改 到账本上？

1、第一种场景是，粉板满了，记不下了。这时候如果再有人来赊账，掌柜就只得放下手里的活 儿，将粉板上的记录擦掉一些，留出空位以便继续记账。当然在擦掉之前，他必须先将正确 的账目记录到账本中才行。

这个场景，对应的就是**InnoDB的redo log写满了**。这时候系统会停止所有更新操作，把 checkpoint往前推进，redo log留出空间可以继续写。我在第二讲画了一个redo log的示意 图，这里我改成环形，便于大家理解。

<img src="MYSQL实战45讲.assets/image-20250211182250951.png" alt="image-20250211182250951" style="zoom:50%;" />

checkpoint（更新点）可不是随便往前修改一下位置就可以的。比如图2中，把checkpoint位置从CP推进到 CP’，就需要将两个点之间的日志（浅绿色部分），对应的所有脏页都flush到磁盘上。之后，图 中从write pos到CP’之间就是可以再写入的redo log的区域。



2、第二种场景是，这一天生意太好，要记住的事情太多，掌柜发现自己快记不住了，赶紧找出 账本把孔乙己这笔账先加进去。

这种场景，对应的就是系统内存不足。当需要新的内存页，而内存不够用的时候，就要淘汰 一些数据页，空出内存给别的数据页使用。

**如果淘汰的是“脏页”，就要先将脏页写到磁盘**。 你一定会说，这时候难道不能直接把内存淘汰掉，下次需要请求的时候，从磁盘读入数据 页，然后拿redo log出来应用不就行了？这里其实是从性能考虑的。如果刷脏页一定会写盘， 就保证了每个数据页有两种状态：

- 一种是内存里存在，内存里就肯定是正确的结果，直接返回； 
- 另一种是内存里没有数据，就可以肯定数据文件上是正确的结果，读入内存后返回。 这样的效率最高。



3、第三种场景是，生意不忙的时候，或者打烊之后。这时候柜台没事，掌柜闲着也是闲着，不 如更新账本。

这种场景，对应的就是**MySQL认为系统“空闲”的时候**。当然，MySQL“这家酒店”的生意好起 来可是会很快就能把粉板记满的，所以“掌柜”要合理地安排时间，即使是“生意好”的时候，也 要见缝插针地找时间，只要有机会就刷一点“脏页”。



4、第四种场景是，年底了咸亨酒店要关门几天，需要把账结清一下。这时候掌柜要把所有账都 记到账本上，这样过完年重新开张的时候，就能就着账本明确账目情况了

这种场景，对应的就是**MySQL正常关闭的情况**。这时候，MySQL会把内存的脏页都flush到磁 盘上，这样下次MySQL启动的时候，就可以直接从磁盘上读数据，启动速度会很快。



接下来，你可以分析一下上面四种场景对性能的影响。 其中，第三种情况是属于MySQL空闲时的操作，这时系统没什么压力，而第四种场景是数据库 本来就要关闭了。这两种情况下，你不会太关注“性能”问题。

所以这里，我们主要来分析一下前 两种场景下的**性能问题**。



第一种是“redo log写满了，要flush脏页”，这种情况是InnoDB要尽量避免的。因为出现这种情况 的时候，整个系统就不能再接受更新了，所有的更新都必须堵住。如果你从监控上看，这时候更 新数会跌为0。



第二种是“内存不够用了，要先将脏页写到磁盘”，这种情况其实是常态。InnoDB用缓冲池 （buffer pool）管理内存，缓冲池中的内存页有三种状态：

- 第一种是，还没有使用的； 
- 第二种是，使用了并且是干净页；
- 第三种是，使用了并且是脏页。



InnoDB的策略是尽量使用内存，因此对于一个长时间运行的库来说，未被使用的页面很少。

而当要读入的数据页没有在内存的时候，就必须到缓冲池中申请一个数据页。这时候只能把最久 不使用的数据页从内存中淘汰掉：如果要淘汰的是一个干净页，就直接释放出来复用；但如果是 脏页呢，就必须将脏页先刷到磁盘，变成干净页后才能复用。



所以，刷脏页虽然是常态，但是出现以下这两种情况，都是会明显影响性能的：

1. 一个查询要淘汰的脏页个数太多，会导致查询的响应时间明显变长；

2. 日志写满，更新全部堵住，写性能跌为0，这种情况对敏感业务来说，是不能接受的。

所以，InnoDB需要有控制脏页比例的机制，来尽量避免上面的这两种情况。



## InnoDB刷脏页的控制策略

接下来，我就来和你说说InnoDB脏页的控制策略，以及和这些策略相关的参数。

首先，你要正确地告诉InnoDB所在主机的IO能力，这样InnoDB才能知道需要全力刷脏页的时候，可以刷多快。

这就要用到innodb_io_capacity这个参数了，它会告诉InnoDB你的磁盘能力。这个值我建议你设置成磁盘的**IOPS**。磁盘的IOPS可以通过fio这个工具来测试，下面的语句是我用来测试磁盘随机读写的命令：

```bash
fio -filename=$filename -direct=1 -iodepth 1 -thread -rw=randrw -ioengine=psync -bs=16k -size=500M 
```

其实，因为没能正确地设置innodb_io_capacity参数，而导致的性能问题也比比皆是。之前，就 曾有其他公司的开发负责人找我看一个库的性能问题，说MySQL的写入速度很慢，TPS很低， 但是数据库主机的IO压力并不大。经过一番排查，发现罪魁祸首就是这个参数的设置出了问题。



他的主机磁盘用的是SSD，但是innodb_io_capacity的值设置的是300。于是，InnoDB认为这个 系统的能力就这么差，所以刷脏页刷得特别慢，甚至比脏页生成的速度还慢，这样就造成了脏页 累积，影响了查询和更新性能。



虽然我们现在已经定义了“全力刷脏页”的行为，但平时总不能一直是全力刷吧？毕竟磁盘能力不 能只用来刷脏页，还需要服务用户请求。所以接下来，我们就一起看看InnoDB怎么控制引擎按 照“全力”的百分比来刷脏页。



根据我前面提到的知识点，试想一下，如果你来设计策略控制刷脏页的速度，会参考哪些因 素呢？



这个问题可以这么想，如果刷太慢，会出现什么情况？首先是内存脏页太多，其次是redo log写 满。



所以，**InnoDB的刷盘速度就是要参考这两个因素：一个是脏页比例，一个是redo log写盘速度。**



InnoDB会根据这两个因素先单独算出两个数字。

参数`innodb_max_dirty_pages_pct`是脏页比例上限，默认值是75%。InnoDB会根据当前的脏页 比例（假设为M），算出一个范围在0到100之间的数字，计算这个数字的伪代码类似这样：

```
F1(M)
{
    if M>=innodb_max_dirty_pages_pct then
        return 100;
    return 100*M/innodb_max_dirty_pages_pct;
}

```

InnoDB每次写入的日志都有一个序号，当前写入的序号跟checkpoint对应的序号之间的差值， 我们假设为N。InnoDB会根据这个N算出一个范围在0到100之间的数字，这个计算公式可以记为 F2(N)。F2(N)算法比较复杂，你只要知道N越大，算出来的值越大就好了。

然后，根据上述算得的F1(M)和F2(N)两个值，取其中较大的值记为R，之后引擎就可以按 照innodb_io_capacity定义的能力乘以R%来控制刷脏页的速度。



上述的计算流程比较抽象，不容易理解，所以我画了一个简单的流程图。图中的F1、F2就是上 面我们通过脏页比例和redo log写入速度算出来的两个值。

<img src="MYSQL实战45讲.assets/image-20250211195002030.png" alt="image-20250211195002030" style="zoom:50%;" />



现在你知道了，InnoDB会在后台刷脏页，而刷脏页的过程是要将内存页写入磁盘。所以，无论 是你的查询语句在需要内存的时候可能要求淘汰一个脏页，还是由于刷脏页的逻辑会占用IO资源 并可能影响到了你的更新语句，都可能是造成你从业务端感知到MySQL“抖”了一下的原因。



要尽量避免这种情况，你就要合理地设置innodb_io_capacity的值，并且平时要多关注脏页比 例，不要让它经常接近75%

其中，脏页比例是通过Innodb_buffer_pool_pages_dirty/Innodb_buffer_pool_pages_total得到 的，具体的命令参考下面的代码：

```
mysql> select VARIABLE_VALUE into @a from information_schema.global_status where VARIABLE_NAME = 'Innodb_buffer_pool_pages_dirty';
select VARIABLE_VALUE into @b from information_schema.global_status where VARIABLE_NAME = 'Innodb_buffer_pool_pages_total';
select @a/@b;

```

==> mysql 8.0 好像存在status中了

```mysql
mysql> SHOW GLOBAL STATUS LIKE 'Innodb_buffer_pool_pages_dirty';
+--------------------------------+-------+
| Variable_name                  | Value |
+--------------------------------+-------+
| Innodb_buffer_pool_pages_dirty | 0     |
+--------------------------------+-------+
1 row in set (0.00 sec)

mysql> SHOW GLOBAL STATUS LIKE 'Innodb_buffer_pool_pages_total';
+--------------------------------+--------+
| Variable_name                  | Value  |
+--------------------------------+--------+
| Innodb_buffer_pool_pages_total | 196608 |
+--------------------------------+--------+
1 row in set (0.00 sec)
```



接下来，我们再看一个有趣的策略。



一旦一个查询请求需要在执行过程中先flush掉一个脏页时，这个查询就可能要比平时慢了。而 MySQL中的一个机制，可能让你的查询会更慢：在准备刷一个脏页的时候，如果这个数据页旁 边的数据页刚好是脏页，就会把这个“邻居”也带着一起刷掉；而且这个把“邻居”拖下水的逻辑还 可以继续**蔓延**，也就是对于每个邻居数据页，如果跟它相邻的数据页也还是脏页的话，也会被放 到一起刷。



在InnoDB中，`innodb_flush_neighbors` 参数就是用来控制这个行为的，值为1的时候会有上述 的“连坐”机制，值为0时表示不找邻居，自己刷自己的。

找“邻居”这个优化在机械硬盘时代是很有意义的，可以减少很多随机IO。机械硬盘的随机IOPS 一般只有几百，相同的逻辑操作减少随机IO就意味着系统性能的大幅度提升。

而如果使用的是SSD这类IOPS比较高的设备的话，我就建议你把innodb_flush_neighbors的值 设置成0。因为这时候IOPS往往不是瓶颈，而“只刷自己”，就能更快地执行完必要的刷脏页操 作，减少SQL语句响应时间。

在MySQL 8.0中，innodb_flush_neighbors参数的默认值已经是0了。

```mysql
mysql> SHOW VARIABLES LIKE 'innodb_flush_neighbors';
+------------------------+-------+
| Variable_name          | Value |
+------------------------+-------+
| innodb_flush_neighbors | 0     |
+------------------------+-------+
1 row in set (0.00 sec)
```





## 小结 

今天这篇文章，我延续第2篇中介绍的WAL的概念，和你解释了这个机制后续需要的刷脏页操作和执行时机。

**利用WAL技术，数据库将随机写转换成了顺序写，大大提升了数据库的性能**。 

但是，由此也带来了内存脏页的问题。脏页会被后台线程自动flush，也会由于数据页淘汰而触 发flush，而刷脏页的过程由于会占用资源，可能会让你的更新和查询语句的响应时间长一些。 

在文章里，我也给你介绍了控制刷脏页的方法和对应的监控方式。





### 思考题

一个内存配置为128GB、innodb_io_capacity设置为20000的大规格实例，正常会建议你将redo log设置成4个1GB的文件。

但如果你在配置的时候不慎将redo log设置成了1个100M的文件，会发生什么情况呢？又为什么 会出现这样的情况呢？



回答：

如果一个高配的机器，redo log设置太小，会发生什么情况？

每次事务提交都要写redo log，如果设置太小，很快就会被写满，也就是下面这个图的状态，这 个“环”将很快被写满，write pos一直追着CP。

<img src="MYSQL实战45讲.assets/image-20250211200208457.png" alt="image-20250211200208457" style="zoom:50%;" />

这时候系统不得不停止所有更新，去推进checkpoint。 这时，**你看到的现象就是磁盘压力很小，但是数据库出现间歇性的性能下跌**。



评论区留言点赞板： 

@某、人 给了一个形象的描述，而且提到了，在这种情况下，连change buffer的优化也失效 了。因为checkpoint一直要往前推，这个操作就会触发merge操作，然后又进一步地触发刷脏 页操作；

有几个同学提到了内存淘汰脏页，对应的redo log的操作，这个我们会在后面的文章中展开， 大家可以先看一下 @melon 同学的描述了解一下； 

@算不出流源 提到了“动态平衡”，其实只要出现了这种“平衡”，意味着本应该后台的操作，就 已经影响了业务应用，属于有损失的平衡



# 13 | 为什么表数据删掉一半，表文件大小不变？



经常会有同学来问我，我的数据库占用空间太大，我把一个最大的表删掉了一半的数据，怎么表 文件的大小还是没变？



那么今天，我就和你聊聊**数据库表的空间回收**，看看如何解决这个问题。

这里，我们还是针对MySQL中应用最广泛的InnoDB引擎展开讨论。一个InnoDB表包含两部 分，即：表结构定义和数据。

在MySQL 8.0版本以前，表结构是存在以`.frm`为后缀的文件里。而 MySQL 8.0版本，则已经允许把表结构定义放在系统数据表中了。因为表结构定义占用的空间很 小，所以我们今天主要讨论的是表数据。

接下来，我会先和你说明为什么简单地删除表数据达不到表空间回收的效果，然后再和你介绍正 确回收空间的方法。



## 参数innodb_file_per_table

表数据既可以存在共享表空间里，也可以是单独的文件。这个行为是由参数 `innodb_file_per_table`控制的：

1. 这个参数设置为OFF表示的是，表的数据放在系统共享表空间，也就是跟数据字典放在一 起；
2.  这个参数设置为ON表示的是，每个InnoDB表数据存储在一个以 .ibd为后缀的文件中。

从MySQL 5.6.6版本开始，它的默认值就是ON了。

我建议你不论使用MySQL的哪个版本，都将这个值设置为ON。因为，一个表单独存储为一个文 件更容易管理，而且在你不需要这个表的时候，通过drop table命令，系统就会直接删除这个文件。而**如果是放在共享表空间中，即使表删掉了，空间也是不会回收的**。



所以，将innodb_file_per_table设置为ON，是推荐做法，我们接下来的讨论都是基于这个设置展开的。



我们在删除整个表的时候，可以使用drop table命令回收表空间。但是，我们遇到的更多的删除 数据的场景是删除某些行，这时就遇到了我们文章开头的问题：表中的数据被删除了，但是表空 间却没有被回收。

我们要彻底搞明白这个问题的话，就要从数据删除流程说起了。



## 数据删除流程

我们先再来看一下InnoDB中一个索引的示意图。在前面第4和第5篇文章中，我和你介绍索引时 曾经提到过，InnoDB里的数据都是用B+树的结构组织的。

<img src="MYSQL实战45讲.assets/image-20250212163751307.png" alt="image-20250212163751307" style="zoom:50%;" />

假设，我们要删掉R4这个记录，InnoDB引擎只会把R4这个记录标记为删除。如果之后要再插入 一个ID在300和600之间的记录时，可能会复用这个位置。但是，磁盘文件的大小并不会缩小。

现在，你已经知道了InnoDB的数据是按页存储的，那么如果我们删掉了一个数据页上的所有记 录，会怎么样？

答案是，整个数据页就可以被复用了。

但是，**数据页的复用跟记录的复用是不同的**。



记录的复用，只限于符合范围条件的数据。比如上面的这个例子，R4这条记录被删除后，如果 插入一个ID是400的行，可以直接复用这个空间。但如果插入的是一个ID是800的行，就不能复 用这个位置了。



而当整个页从B+树里面摘掉以后，可以复用到任何位置。以图1为例，如果将数据页page A上的 所有记录删除以后，page A会被标记为可复用。这时候如果要插入一条ID=50的记录需要使用新 页的时候，page A是可以被复用的。



如果相邻的两个数据页利用率都很小，系统就会把这两个页上的数据合到其中一个页上，另外一 个数据页就被标记为可复用。



进一步地，**如果我们用delete命令把整个表的数据删除呢？结果就是，所有的数据页都会被标记 为可复用。但是磁盘上，文件不会变小。**



你现在知道了，**delete命令其实只是把记录的位置，或者数据页标记为了“可复用”，但磁盘文件 的大小是不会变的**。也就是说，通过delete命令是不能回收表空间的。这些可以复用，而没有被 使用的空间，看起来就像是“空洞”。



实际上，不止是删除数据会造成空洞，插入数据也会。

如果数据是按照索引递增顺序插入的，那么索引是紧凑的。但如果数据是随机插入的，就可能造成索引的数据页分裂。



假设图1中page A已经满了，这时我要再插入一行数据，会怎样呢？

<img src="MYSQL实战45讲.assets/image-20250212164128218.png" alt="image-20250212164128218" style="zoom:50%;" />

可以看到，由于page A满了，再插入一个ID是550的数据时，就不得不再申请一个新的页面 page B来保存数据了。页分裂完成后，page A的末尾就留下了空洞（注意：实际上，可能不止1 个记录的位置是空洞）。



另外，更新索引上的值，可以理解为删除一个旧的值，再插入一个新值。不难理解，这也是会造成**空洞**的。

也就是说，经过大量增删改的表，都是可能是存在空洞的。所以，如果能够把这些空洞去掉，就 能达到收缩表空间的目的。



也就是说，经过大量增删改的表，都是可能是存在空洞的。所以，如果能够把这些空洞去掉，就 能达到收缩表空间的目的。



## 重建表

试想一下，如果你现在有一个表A，需要做空间收缩，为了把表中存在的空洞去掉，你可以怎么做呢？

你可以新建一个与表A结构相同的表B，然后按照主键ID递增的顺序，把数据一行一行地从表A 里读出来再插入到表B中。

由于表B是新建的表，所以表A主键索引上的空洞，在表B中就都不存在了。显然地，表B的主键 索引更紧凑，数据页的利用率也更高。如果我们把表B作为临时表，数据从表A导入表B的操作完 成后，用表B替换A，从效果上看，就起到了收缩表A空间的作用。



这里，你可以使用`alter table A engine=InnoDB`命令来重建表。在**MySQL 5.5版本**之前，这个命 令的执行流程跟我们前面描述的差不多，区别只是这个临时表B不需要你自己创建，MySQL会自动完成转存数据、交换表名、删除旧表的操作。



<img src="MYSQL实战45讲.assets/image-20250212164659555.png" alt="image-20250212164659555" style="zoom:50%;" />



显然，花时间最多的步骤是往临时表插入数据的过程，如果在这个过程中，有新的数据要写入到 表A的话，就会造成数据丢失。因此，在整个DDL过程中，表A中不能有更新。也就是说，这个 **DDL(Data Definition Language, 数据定义语言)不是Online**的。



而在MySQL 5.6版本开始引入的Online DDL，对这个操作流程做了优化。



我给你简单描述一下引入了**Online DDL**之后，重建表的流程：

1. 建立一个临时文件，扫描表A主键的所有数据页； 
2. 用数据页中表A的记录生成B+树，存储到临时文件中；
3. 生成临时文件的过程中，将所有对A的操作记录在一个**日志文件（rowlog）**中，对应的是图中state2的状态； 
4. 临时文件生成后，将日志文件中的操作应用到临时文件，得到一个逻辑数据上与表A相同的数据文件，对应的就是图中state3的状态； 
5. 用临时文件替换表A的数据文件。

<img src="MYSQL实战45讲.assets/image-20250212165014470.png" alt="image-20250212165014470" style="zoom:50%;" />



可以看到，**与图3过程的不同之处在于，由于日志文件记录和重放操作这个功能的存在，这个方案在重建表的过程中，允许对表A做增删改操作**。这也就是Online DDL名字的来源。



我记得有同学在第6篇讲表锁的文章《全局锁和表锁 ：给表加个字段怎么索这么多阻碍？》的评论区留言说，DDL之前是要拿MDL（Metadata Lock，元数据锁）写锁的，这样还能叫Online DDL吗？

> 在 MySQL 中，MDL 锁是元数据锁（Metadata Lock）的缩写。它是一种用于保护数据库对象元数据的锁机制。MDL 锁的作用是确保在并发环境下，对数据库对象的元数据进行操作时的一致性和安全性。
>
> MDL 锁是一种细粒度的锁，它与表级别的锁（如表锁）不同。MDL 锁是在 MySQL 5.5 版本引入的，它允许并发地读取元数据，但在写操作之前需要获取写锁。
>
> 当一个会话（连接）需要对数据库对象进行某些操作（如修改表结构、重命名表等）时，它会尝试获取相应的 MDL 锁。如果其他会话已经持有了相应的 MDL 锁（如写锁），则当前会话需要等待，直到锁被释放。这样可以确保在进行元数据操作时，不会发生冲突或数据不一致的情况。

确实，图4的流程中，**alter语句在启动的时候需要获取MDL写锁**，但是这个写锁在真正拷贝数据之前就退化成读锁了。

为什么要退化呢？为了实现Online，MDL读锁不会阻塞增删改操作。

那为什么不干脆直接解锁呢？为了保护自己，禁止其他线程对这个表同时做DDL。



而对于一个大表来说，Online DDL最耗时的过程就是拷贝数据到临时表的过程，这个步骤的执行期间可以接受增删改操作。所以，相对于整个DDL过程来说，锁的时间非常短。对业务来说， 就可以认为是Online的。



需要补充说明的是，上述的这些重建方法都会扫描原表数据和构建临时文件。**对于很大的表来说，这个操作是很消耗IO和CPU资源的**。因此，如果是线上服务，你要很小心地控制操作时间。如果想要比较安全的操作的话，我推荐你使用GitHub开源的gh-ost来做。



## Online 和 inplace

说到Online，我还要再和你澄清一下它和另一个跟DDL有关的、容易混淆的概念inplace的区别。



你可能注意到了，在图3中，我们把表A中的数据导出来的存放位置叫作tmp_table。这是一个临 时表，是在server层创建的。



在图4中，根据表A重建出来的数据是放在“tmp_file”里的，这个临时文件是InnoDB在内部创建出 来的。整个DDL过程都在InnoDB内部完成。

**对于server层来说，没有把数据挪动到临时表，是 一个“原地”操作，这就是“inplace”名称的来源**。



所以，我现在问你，如果你有一个1TB的表，现在磁盘间是1.2TB，能不能做一个inplace的DDL 呢？ 答案是不能。因为，tmp_file也是要占用临时空间的。



我们重建表的这个语句alter table t engine=InnoDB，其实隐含的意思是：

```sql
alter table t engine=innodb,ALGORITHM=inplace;
```

跟inplace对应的就是拷贝表的方式了，用法是：

```sql
alter table t engine=innodb,ALGORITHM=copy;
```

当你使用ALGORITHM=copy的时候，表示的是强制拷贝表，对应的流程就是图3的操作过程。



但我这样说你可能会觉得，inplace跟Online是不是就是一个意思？

其实不是的，只是在重建表这个逻辑中刚好是这样而已。 比如，如果我要给InnoDB表的一个字段加全文索引，写法是：

```sql
alter table t add FULLTEXT(field_name);
```

这个过程是inplace的，但会阻塞增删改操作，是非Online的。



如果说这两个逻辑之间的关系是什么的话，可以概括为：

1. DDL过程如果是Online的，就一定是inplace的；
2. 反过来未必，也就是说inplace的DDL，有可能不是Online的。截止到MySQL 8.0，添加全文索引（FULLTEXTindex）和空间索引(SPATIAL index)就属于这种情况。



最后，我们再延伸一下。

在第10篇文章《MySQL为什么有时候会选错索引》的评论区中，有同学问到使用optimize table、analyze table和alter table这三种方式重建表的区别。这里，我顺便再简单和你解释一 下。

- 从MySQL 5.6版本开始，alter table t engine = InnoDB（也就是recreate）默认的就是上面图4 的流程了； 
- analyze table t 其实不是重建表，只是对表的索引信息做重新统计，没有修改数据，这个过程中加了MDL读锁； 
- optimize table t 等于recreate+analyze。



## 小结

今天这篇文章，我和你讨论了数据库中收缩表空间的方法。

现在你已经知道了，**如果要收缩一个表，只是delete掉表里面不用的数据的话，表文件的大小是 不会变的，你还要通过alter table命令重建表**，才能达到表文件变小的目的。



我跟你介绍了重建 表的两种实现方式，Online DDL的方式是可以考虑在业务低峰期使用的，而MySQL 5.5及之前的 版本，这个命令是会阻塞DML的，这个你需要特别小心。



### 思考题

最后，又到了我们的课后问题时间。 假设现在有人碰到了一个“想要收缩表空间，结果适得其反”的情况，看上去是这样的：

1. 一个表t文件大小为1TB； 
2. 对这个表执行 alter table t engine=InnoDB； 
3. 发现执行完成后，空间不仅没变小，还稍微大了一点儿，比如变成了1.01TB。

你觉得可能是什么原因呢 ？



> 回答

什么时候使用alter table t engine=InnoDB会让一个表占用的空间反而变大。

在这篇文章的评论区里面，大家都提到了一个点，就是**这个表，本身就已经没有空洞的了**，比如说刚刚做过一次重建表操作。



在DDL期间，**如果刚好有外部的DML在执行，这期间可能会引入一些新的空洞**。



@飞翔 提到了一个更深刻的机制，是我们在文章中没说的。**在重建表的时候，InnoDB不会把整 张表占满，每个页留了1/16给后续的更新用**。也就是说，其实重建表之后不是“最”紧凑的。



假如是这么一个过程：

1. 将表t重建一次； 
2. 插入一部分数据，但是插入的这些数据，用掉了一部分的预留空间； 
3. 这种情况下，再重建一次表t，就可能会出现问题中的现象。



# 14 | count(*)这么慢，我该怎么办？



在开发系统的时候，你可能经常需要计算一个表的行数，比如一个交易系统的所有变更记录总 数。这时候你可能会想，一条select count(*) fromt 语句不就解决了吗？

但是，你会发现随着系统中记录数越来越多，这条语句执行得也会越来越慢。然后你可能就想 了，MySQL怎么这么笨啊，记个总数，每次要查的时候直接读出来，不就好了吗。



那么今天，我们就来聊聊count(*)语句到底是怎样实现的，以及MySQL为什么会这么实现。

然 后，我会再和你说说，如果应用中有这种频繁变更并需要统计表行数的需求，业务设计上可以怎 么做。



## count(*)的实现方式



你首先要明确的是，在不同的MySQL引擎中，count(*)有不同的实现方式。

- MyISAM引擎把一个表的总行数存在了磁盘上，因此执行count(*)的时候会直接返回这个数， 效率很高；
- 而InnoDB引擎就麻烦了，它执行count(*)的时候，需要把数据一行一行地从引擎里面读出 来，然后累积计数。

这里需要注意的是，我们在这篇文章里讨论的是没有过滤条件的count(*)，如果加了where 条件 的话，MyISAM表也是不能返回得这么快的。



在前面的文章中，我们一起分析了为什么要使用InnoDB，因为不论是在事务支持、并发能力还 是在数据安全方面，InnoDB都优于MyISAM。我猜你的表也一定是用了InnoDB引擎。这就是当 你的记录数越来越多的时候，计算一个表的总行数会越来越慢的原因。



那为什么InnoDB不跟MyISAM一样，也把数字存起来呢？



这是因为即使是在同一个时刻的多个查询，由于多版本并发控制（MVCC）的原因，InnoDB 表“应该返回多少行”也是不确定的。这里，我用一个算count(*)的例子来为你解释一下。



假设表t中现在有10000条记录，我们设计了三个用户并行的会话。 

- 会话A先启动事务并查询一次表的总行数； 
- 会话B启动事务，插入一行后记录后，查询表的总行数；
- 会话C先启动一个单独的语句，插入一行记录后，查询表的总行数。

我们假设从上到下是按照时间顺序执行的，同一行语句是在同一时刻执行的。

<img src="MYSQL实战45讲.assets/image-20250213200030883.png" alt="image-20250213200030883" style="zoom:50%;" />



你会看到，在最后一个时刻，三个会话A、B、C会同时查询表t的总行数，但拿到的结果却不 同。



这和InnoDB的事务设计有关系，可重复读是它默认的隔离级别，在代码上就是通过多版本并发 控制，也就是MVCC来实现的。



每一行记录都要判断自己是否对这个会话可见，因此对于 count(*)请求来说，InnoDB只好把数据一行一行地读出依次判断，可见的行才能够用于计算“基 于这个查询”的表的总行数。

> 备注：如果你对MVCC记忆模糊了，可以再回顾下第3篇文章《事务隔离：为什么你改了我还 看不见？》和第8篇文章《事务到底是隔离的还是不隔离的？》中的相关内容



当然，现在这个看上去笨笨的MySQL，在执行count(*)操作的时候还是做了优化的。



你知道的，InnoDB是索引组织表，主键索引树的叶子节点是数据，而普通索引树的叶子节点是 主键值。所以，普通索引树比主键索引树小很多。对于count(*)这样的操作，遍历哪个索引树得 到的结果逻辑上都是一样的。因此，MySQL优化器会找到最小的那棵树来遍历。在保证逻辑正 确的前提下，尽量减少扫描的数据量，是数据库系统设计的通用法则之一。



如果你用过`show table status` 命令的话，就会发现这个命令的输出结果里面也有一个 TABLE_ROWS用于显示这个表当前有多少行，这个命令执行挺快的，那这个TABLE_ROWS能 代替count(*)吗？

你可能还记得在第10篇文章《 MySQL为什么有时候会选错索引？》中我提到过，索引统计的值 是通过采样来估算的。实际上，TABLE_ROWS就是从这个采样估算得来的，因此它也很不准。 有多不准呢，官方文档说误差可能达到40%到50%。所以，show table status命令显示的行 数也不能直接使用。



到这里我们小结一下：

- MyISAM表虽然count(*)很快，但是不支持事务；
- show table status命令虽然返回很快，但是不准确；
- InnoDB表直接count(*)会遍历全表，虽然结果准确，但会导致性能问题。



那么，回到文章开头的问题，如果你现在有一个页面经常要显示交易系统的操作记录总数，到底 应该怎么办呢？答案是，我们只能自己计数。



接下来，我们讨论一下，看看自己计数有哪些方法，以及每种方法的优缺点有哪些。



这里，我先和你说一下这些方法的基本思路：你需要自己找一个地方，把操作记录表的行数存起 来。



## 用缓存系统保存计数

对于更新很频繁的库来说，你可能会第一时间想到，用缓存系统来支持。

你可以用一个Redis服务来保存这个表的总行数。这个表每被插入一行Redis计数就加1，每被删 除一行Redis计数就减1。这种方式下，读和更新操作都很快，但你再想一下这种方式存在什么 问题吗？

没错，**缓存系统可能会丢失更新**。



Redis的数据不能永久地留在内存里，所以你会找一个地方把这个值定期地持久化存储起来。但 即使这样，仍然可能丢失更新。试想如果刚刚在数据表中插入了一行，Redis中保存的值也加了 1，然后Redis异常重启了，重启后你要从存储redis数据的地方把这个值读回来，而刚刚加1的这 个计数操作却丢失了。



当然了，这还是有解的。比如，Redis异常重启以后，到数据库里面单独执行一次count(*)获取真 实的行数，再把这个值写回到Redis里就可以了。异常重启毕竟不是经常出现的情况，这一次全 表扫描的成本，还是可以接受的。



但实际上，将计数保存在缓存系统中的方式，还不只是丢失更新的问题。即使Redis正常工 作，这个值还是逻辑上不精确的。



你可以设想一下有这么一个页面，要显示操作记录的总数，同时还要显示最近操作的100条记 录。那么，这个页面的逻辑就需要先到Redis里面取出计数，再到数据表里面取数据记录。



我们是这么定义不精确的：

1. 一种是，查到的100行结果里面有最新插入记录，而Redis的计数里还没加1； 
2. 另一种是，查到的100行结果里没有最新插入的记录，而Redis的计数里已经加了1。



这两种情况，都是逻辑不一致的。

我们一起来看看这个时序图。

<img src="MYSQL实战45讲.assets/image-20250213200951289.png" alt="image-20250213200951289" style="zoom:50%;" />

图2中，会话A是一个插入交易记录的逻辑，往数据表里插入一行R，然后Redis计数加1；会话B 就是查询页面显示时需要的数据。

在图2的这个时序里，在T3时刻会话B来查询的时候，会显示出新插入的R这个记录，但是Redis 的计数还没加1。这时候，就会出现我们说的数据不一致。



你一定会说，这是因为我们执行新增记录逻辑时候，是先写数据表，再改Redis计数。而读的时 候是先读Redis，再读数据表，这个顺序是相反的。那么，如果保持顺序一样的话，是不是就没 问题了？我们现在把会话A的更新顺序换一下，再看看执行结果。



<img src="MYSQL实战45讲.assets/image-20250213201024484.png" alt="image-20250213201024484" style="zoom:50%;" />

你会发现，这时候反过来了，会话B在T3时刻查询的时候，Redis计数加了1了，但还查不到新插 入的R这一行，也是数据不一致的情况。



在并发系统里面，我们是无法精确控制不同线程的执行时刻的，因为存在图中的这种操作序列， 所以，我们说即使Redis正常工作，这个计数值还是逻辑上不精确的。



## 在数据库保存计数

 根据上面的分析，用缓存系统保存计数有丢失数据和计数不精确的问题。那么，如果我们把这 个计数直接放到数据库里单独的一张计数表C中，又会怎么样呢？

首先，这解决了崩溃丢失的问题，InnoDB是支持崩溃恢复不丢数据的。

> 备注：关于InnoDB的崩溃恢复，你可以再回顾一下第2篇文章《日志系统：一条SQL更新语句 是如何执行的？》中的相关内容



然后，我们再看看能不能解决计数不精确的问题。 你会说，这不一样吗？无非就是把图3中对Redis的操作，改成了对计数表C的操作。只要出现图 3的这种执行序列，这个问题还是无解的吧？



这个问题还真不是无解的。 我们这篇文章要解决的问题，都是由于InnoDB要支持事务，从而导致InnoDB表不能把count(*) 直接存起来，然后查询的时候直接返回形成的。

所谓以子之矛攻子之盾，现在我们就利用“事务”这个特性，把问题解决掉。

<img src="MYSQL实战45讲.assets/image-20250213201225620.png" alt="image-20250213201225620" style="zoom:50%;" />



我们来看下现在的执行结果。虽然会话B的读操作仍然是在T3执行的，但是因为这时候更新事务 还没有提交，所以计数值加1这个操作对会话B还不可见。

因此，会话B看到的结果里， 查计数值和“最近100条记录”看到的结果，逻辑上就是一致的。



## 不同的count用法



在前面文章的评论区，有同学留言问到：在select count(?) fromt这样的查询语句里面，count(*)、count(主键id)、count(字段)和count(1)等不同用法的性能，有哪些差别。*

*今天谈 到了count(*)的性能问题，我就借此机会和你详细说明一下这几种用法的性能差别。

需要注意的是，下面的讨论还是基于InnoDB引擎的。

这里，首先你要弄清楚count()的语义。**count()是一个聚合函数**，**对于返回的结果集，一行行地 判断，如果count函数的参数不是NULL，累计值就加1，否则不加。最后返回累计值**。

所以，count(*)、count(主键id)和count(1) 都表示返回满足条件的结果集的总行数；

而**count(字段），则表示返回满足条件的数据行里面，参数“字段”不为NULL的总个数**。



至于分析性能差别的时候，你可以记住这么几个原则：

1. server层要什么就给什么； 
2. InnoDB只给必要的值； 
3. 现在的优化器只优化了count(*)的语义为“取行数”，其他“显而易见”的优化并没有做。

这是什么意思呢？接下来，我们就一个个地来看看。

对于**count(主键id)**来说，InnoDB引擎会遍历整张表，把每一行的id值都取出来，返回给server 层。server层拿到id后，判断是不可能为空的，就按行累加。



对于**count(1)**来说，InnoDB引擎遍历整张表，但不取值。server层对于返回的每一行，放一个 数字“1”进去，判断是不可能为空的，按行累加。单看这两个用法的差别的话，你能对比出来，count(1)执行得要比count(主键id)快。因为从引擎 返回id会涉及到解析数据行，以及拷贝字段值的操作。



对于**count(字段)**来说：

1. 如果这个“字段”是定义为not null的话，一行行地从记录里面读出这个字段，判断不能为 null，按行累加； 
2. 如果这个“字段”定义允许为null，那么执行的时候，判断到有可能是null，还要把值取出来再判断一下，不是null才累加。

也就是前面的第一条原则，server层要什么字段，InnoDB就返回什么字段。



但是`count(*)`是例外，并不会把全部字段取出来，而是专门做了优化，不取值。count(*)肯定不 是null，按行累加。



看到这里，你一定会说，优化器就不能自己判断一下吗，主键id肯定非空啊，为什么不能按照 count(*)来处理，多么简单的优化啊。

当然，MySQL专门针对这个语句进行优化，也不是不可以。但是这种需要专门优化的情况太多 了，而且MySQL已经优化过count(*)了，你直接使用这种用法就可以了。

所以结论是：按照效率排序的话，`count(字段)<count(主键id)<count(1)≈count(*)`,所以我建议 你，尽量使用count(*)。





## 小结



今天，我和你聊了聊MySQL中获得表行数的两种方法。

我们提到了在不同引擎中count(*)的实现方式是不一样的，也分析了用缓存系统来存储计数值存在的问题。



其实，把计数放在Redis里面，不能够保证计数和MySQL表里的数据精确一致的原因，是这两个 不同的存储构成的系统，不支持分布式事务，无法拿到精确一致的视图。而把计数值也放在 MySQL中，就解决了一致性视图的问题。



InnoDB引擎支持事务，我们利用好事务的原子性和隔离性，就可以简化在业务开发时的逻辑。 这也是InnoDB引擎备受青睐的原因之一



### 思考题

最后，又到了今天的思考题时间了。 在刚刚讨论的方案中，我们用了事务来确保计数准确。由于事务可以保证中间结果不被别的事务 读到，因此修改计数值和插入新记录的顺序是不影响逻辑结果的。但是，从并发系统性能的角度 考虑，你觉得在这个事务序列里，应该先插入操作记录，还是应该先更新计数表呢？



> 回答

上期的问题是，用一个计数表记录一个业务表的总行数，在往业务表插入数据的时候，需要给计 数值加1。

逻辑实现上是启动一个事务，执行两个语句：

1. insert into 数据表； 
2. update 计数表，计数值加1。

从系统并发能力的角度考虑，怎么安排这两个语句的顺序。 这里，我直接复制 @阿建 的回答过来供你参考：

> 并发系统性能的角度考虑，应该先插入操作记录，再更新计数表。 知识点在《行锁功过：怎么减少行锁对性能的影响？》 因为更新计数表涉及到行锁的竞争，先插入再更新能最大程度地**减少事务之间的锁等待**，提升并发度



评论区有同学说，应该把update计数表放后面，因为这个计数表可能保存了多个业务表的计数 值。如果把update计数表放到事务的第一个语句，多个业务表同时插入数据的话，等待时间会 更长。

这个答案的结论是对的，但是理解不太正确。即使我们用一个计数表记录多个业务表的行数，也 肯定会给表名字段加唯一索引。类似于下面这样的表结构：

```sql
CREATE TABLE `rows_stat` (
    `table_name` varchar(64) NOT NULL,
    `row_count` int(10) unsigned NOT NULL,
    PRIMARY KEY (`table_name`)
) ENGINE=InnoDB
```

在更新计数表的时候，一定会传入where table_name=$table_name，**使用主键索引**，更新加行 锁只会锁在一行上。

而在不同业务表插入数据，是更新不同的行，不会有行锁。





# 15 | 答疑文章（一）：日志和索引相关问题



在今天这篇答疑文章更新前，MySQL实战这个专栏已经更新了14篇。在这些文章中，大家在评 论区留下了很多高质量的留言。现在，每篇文章的评论区都有热心的同学帮忙总结文章知识点， 也有不少同学提出了很多高质量的问题，更有一些同学帮忙解答其他同学提出的问题。



在浏览这些留言并回复的过程中，我倍受鼓舞，也尽我所知地帮助你解决问题、和你讨论。可以 说，你们的留言活跃了整个专栏的氛围、提升了整个专栏的质量，谢谢你们。



评论区的大多数留言我都直接回复了，对于需要展开说明的问题，我都拿出小本子记了下来。这 些被记下来的问题，就是我们今天这篇答疑文章的素材了。



到目前为止，我已经收集了47个问题，很难通过今天这一篇文章全部展开。所以，我就先从中 找了几个联系非常紧密的问题，串了起来，希望可以帮你解决关于日志和索引的一些疑惑。而其 他问题，我们就留着后面慢慢展开吧。



## 日志相关问题

我在第2篇文章《日志系统：一条SQL更新语句是如何执行的？》中，和你讲到binlog（归档日 志）和redo log（重做日志）配合崩溃恢复的时候，用的是反证法，说明了如果没有**两阶段提交**，会导致MySQL出现主备数据不一致等问题。



### 在两阶段提交的不同时刻，MySQL异常重启会出现什么现象

在这篇文章下面，很多同学在问，在两阶段提交的不同瞬间，MySQL如果发生异常重启，是怎么保证数据完整性的？

现在，我们就从这个问题开始吧。



我再放一次两阶段提交的图，方便你学习下面的内容。

```
mysql> update T set c=c+1 where ID=2;
```

<img src="MYSQL实战45讲.assets/image-20250214122704852.png" alt="image-20250214122704852" style="zoom:50%;" />



这里，我要先和你解释一个误会式的问题。有同学在评论区问到，这个图不是一个update语句 的执行流程吗，怎么还会调用commit语句？

他产生这个疑问的原因，是把两个“commit”的概念混淆了：

- 他说的“commit语句”，是指MySQL语法中，用于提交一个事务的命令。一般跟begin/start transaction 配对使用。
- 而我们图中用到的这个“commit步骤”，指的是事务提交过程中的一个小步骤，也是最后一 步。当这个步骤执行完成后，这个事务就提交完成了。
- “commit语句”执行的时候，会包含“commit 步骤”。

而我们这个例子里面，没有显式地开启事务，因此这个update语句自己就是一个事务，在执行 完成后提交事务时，就会用到这个“commit步骤“。



接下来，我们就一起分析一下**在两阶段提交的不同时刻，MySQL异常重启会出现什么现象**。

如果在图中时刻A的地方，也就是写入redo log 处于prepare阶段之后、写binlog之前，发生了崩 溃（crash），由于此时binlog还没写，redo log也还没提交，所以崩溃恢复的时候，这个事务会 回滚。这时候，binlog还没写，所以也不会传到备库。到这里，大家都可以理解。



大家出现问题的地方，主要集中在时刻B，也就是binlog写完，redo log还没commit前发生 crash，那崩溃恢复的时候MySQL会怎么处理？



我们先来看一下崩溃恢复时的判断规则。

1. 如果redo log里面的事务是完整的，也就是已经有了commit标识，则直接提交；
2. 如果redo log里面的事务只有完整的prepare，则判断对应的事务binlog是否存在并完整：
   1. 如果是，则提交事务； 
   2. 否则，回滚事务。

这里，时刻B发生crash对应的就是2(a)的情况，崩溃恢复过程中事务会被提交。



> 追问1：MySQL怎么知道binlog是完整的?

回答：一个事务的binlog是有完整格式的：

- statement格式的binlog，最后会有COMMIT；
- row格式的binlog，最后会有一个XID event。

另外，在MySQL 5.6.2版本以后，还引入了**binlog-checksum参数**，用来验证binlog内容的正确性。对于binlog日志由于磁盘原因，可能会在日志中间出错的情况，MySQL可以通过校验checksum的结果来发现。所以，MySQL还是有办法验证事务binlog的完整性的。



> 追问2：redo log 和 binlog是怎么关联起来的?

回答：它们有一个共同的数据字段，叫XID。崩溃恢复的时候，会按顺序扫描redo log：

如果碰到既有prepare、又有commit的redo log，就直接提交； 如果碰到只有parepare、而没有commit的redo log，就拿着XID去binlog找对应的事务。



> 追问3：处于prepare阶段的redo log加上完整binlog，重启就能恢复，MySQL为什么要这么设计?

回答：其实，这个问题还是跟我们在反证法中说到的**数据与备份的一致性有关**。在时刻B，也就 是binlog写完以后MySQL发生崩溃，这时候binlog已经写入了，之后就会被从库（或者用这个 binlog恢复出来的库）使用。



所以，在主库上也要提交这个事务。采用这个策略，主库和备库的数据就保证了一致性。



> 追问4：如果这样的话，为什么还要两阶段提交呢？干脆先redo log写完，再写 binlog。崩溃恢复的时候，必须得两个日志都完整才可以。是不是一样的逻辑？

回答：其实，两阶段提交是经典的分布式系统问题，并不是MySQL独有的。

如果必须要举一个场景，来说明这么做的必要性的话，那就是事务的持久性问题。

对于InnoDB引擎来说，如果redo log提交完成了，事务就不能回滚（如果这还允许回滚，就可能 覆盖掉别的事务的更新）。而如果redo log直接提交，然后binlog写入的时候失败，InnoDB又回 滚不了，数据和binlog日志又不一致了。

两阶段提交就是为了给所有人一个机会，当每个人都说“我ok”的时候，再一起提交。



> 追问5：不引入两个日志，也就没有两阶段提交的必要了。只用binlog来支持崩 溃恢复，又能支持归档，不就可以了？

回答：这位同学的意思是，只保留binlog，然后可以把提交流程改成这样：…-> “数据更新到内 存” -> “写 binlog” -> “提交事务”，是不是也可以提供崩溃恢复的能力？

答案是不可以。

如果说历史原因的话，那就是InnoDB并不是MySQL的原生存储引擎。MySQL的原生引擎是 MyISAM，设计之初就有没有支持崩溃恢复。

InnoDB在作为MySQL的插件加入MySQL引擎家族之前，就已经是一个提供了崩溃恢复和事务支 持的引擎了。

InnoDB接入了MySQL后，发现既然binlog没有崩溃恢复的能力，那就用InnoDB原有的redo log 好了。



而如果说实现上的原因的话，就有很多了。就按照问题中说的，只用binlog来实现崩溃恢复的流 程，我画了一张示意图，这里就没有redo log了。



<img src="MYSQL实战45讲.assets/image-20250214181023612.png" alt="image-20250214181023612" style="zoom:50%;" />



这样的流程下，binlog还是不能支持崩溃恢复的。我说一个不支持的点吧：binlog没有能力恢复“数据页”。

如果在图中标的位置，也就是binlog2写完了，但是整个事务还没有commit的时候，MySQL发生 了crash。



重启后，引擎内部事务2会回滚，然后应用binlog2可以补回来；但是对于事务1来说，系统已经 认为提交完成了，不会再应用一次binlog1。

但是，InnoDB引擎使用的是WAL技术，执行事务的时候，写完内存和日志，事务就算完成了。 如果之后崩溃，要依赖于日志来恢复数据页。



也就是说在图中这个位置发生崩溃的话，事务1也是可能丢失了的，而且是数据页级的丢失。此时，**binlog里面并没有记录数据页的更新细节，是补不回来的**



你如果要说，那我优化一下binlog的内容，让它来记录数据页的更改可以吗？但，这其实就是又 做了一个redo log出来。

所以，**至少现在的binlog能力，还不能支持崩溃恢复**。



> 追问6：那能不能反过来，只用redo log，不要binlog？

回答：如果**只从崩溃恢复的角度来讲是可以的**。你可以把binlog关掉，这样就没有两阶段提交 了，但系统依然是crash-safe的。



但是，如果你了解一下业界各个公司的使用场景的话，就会发现在正式的生产库上，binlog都是 开着的。因为binlog有着redo log无法替代的功能。

一个是归档。**redo log是循环写，写到末尾是要回到开头继续写的**。这样历史日志没法保留，redo log也就起不到归档的作用。



一个就是MySQL系统依赖于binlog。binlog作为MySQL一开始就有的功能，被用在了很多地方。 其中，MySQL系统高可用的基础，就是binlog复制。

还有很多公司有异构系统（比如一些数据分析系统），这些系统就靠消费MySQL的binlog来更新 自己的数据。关掉binlog的话，这些下游系统就没法输入了。



总之，由于现在包括MySQL高可用在内的很多系统机制都依赖于binlog，所以“鸠占鹊巢”redo log还做不到。**你看，发展生态是多么重要**。



> 追问7：redo log一般设置多大？

回答：redo log太小的话，会导致很快就被写满，然后不得不强行刷redo log，这样WAL机制的 能力就发挥不出来了。

所以，如果是现在常见的几个TB的磁盘的话，就不要太小气了，直接将redo log设置为4个文 件、每个文件1GB吧。



> 追问8：正常运行中的实例，数据写入后的最终落盘，是从redo log更新过来的 还是从buffer pool更新过来的呢？

回答：这个问题其实问得非常好。这里涉及到了，“redo log里面到底是什么”的问题。



实际上，**redo log并没有记录数据页的完整数据**，所以它并没有能力自己去更新磁盘数据页，也 就不存在“数据最终落盘，是由redo log更新过去”的情况。

1. 如果是正常运行的实例的话，数据页被修改以后，跟磁盘的数据页不一致，称为脏页。最终数据落盘，就是把内存中的数据页写盘。这个过程，甚至与redo log毫无关系。 
2. 在崩溃恢复场景中，InnoDB如果判断到一个数据页可能在崩溃恢复的时候丢失了更新，就会将它读到内存，然后让redo log更新内存内容。更新完成后，内存页变成脏页，就回到了 第一种情况的状态。



> 追问9：redo log buffer是什么？是先修改内存，还是先写redo log文件？

回答：这两个问题可以一起回答。

在一个事务的更新过程中，日志是要写多次的。比如下面这个事务：

```sql
begin;
insert into t1 ...
insert into t2 ...
commit;
```

这个事务要往两个表中插入记录，插入数据的过程中，生成的日志都得先保存起来，但又不能在 还没commit的时候就直接写到redo log文件里。

所以，redo log buffer就是一块内存，用来先存redo日志的。也就是说，在执行第一个insert的时 候，数据的内存被修改了，redo log buffer也写入了日志。

但是，真正把日志写到redo log文件（文件名是 ib_logfile+数字），是在执行commit语句的时候做的。

> （这里说的是事务执行过程中不会“主动去刷盘”，以减少不必要的IO消耗。但是可能会出现“被 动写入磁盘”，比如内存不够、其他事务提交等情况。这个问题我们会在后面第22篇文章 《MySQL有哪些“饮鸩止渴”的提高性能的方法？》中再详细展开）。



单独执行一个更新语句的时候，InnoDB会自己启动一个事务，在语句执行完成的时候提交。过 程跟上面是一样的，只不过是“压缩”到了一个语句里面完成。

以上这些问题，就是把大家提过的关于redo log和binlog的问题串起来，做的一次集中回答。



## 业务设计问题

接下来，我再和你分享@ithunter 同学在第8篇文章《事务到底是隔离的还是不隔离的？》的评 论区提到的跟索引相关的一个问题。我觉得这个问题挺有趣、也挺实用的，其他同学也可能会碰 上这样的场景，在这里解答和分享一下。

问题是这样的（我文字上稍微做了点修改，方便大家理解）：

> 业务上有这样的需求，A、B两个用户，如果互相关注，则成为好友。设计上是有两张表，一 个是like表，一个是friend表，like表有user_id、liker_id两个字段，我设置为复合唯一索引即uk_user_id_liker_id。语句执行逻辑是这样的：
>
> 以A关注B为例： 
>
> 第一步，先查询对方有没有关注自己（B有没有关注A） select *fromlike where user_id =B and liker_id =A;
>
> 如果有，则成为好友 insert into friend;
>
> 没有，则只是单向关注关系 insert into like;
>
> 但是如果A、B同时关注对方，会出现不会成为好友的情况。因为上面第1步，双方都没关注对 方。第1步即使使用了排他锁也不行，因为记录不存在，行锁无法生效。请问这种情况，在 MySQL锁层面有没有办法处理？



首先，我要先赞一下这样的提问方式。虽然极客时间现在的评论区还不能追加评论，但如果大家 能够一次留言就把问题讲清楚的话，其实影响也不大。所以，我希望你在留言提问的时候，也能借鉴这种方式。

接下来，我把@ithunter 同学说的表模拟出来，方便我们讨论。

```sql
CREATE TABLE `like` (
    `id` int(11) NOT NULL AUTO_INCREMENT,
    `user_id` int(11) NOT NULL,
    `liker_id` int(11) NOT NULL,
    PRIMARY KEY (`id`),
    UNIQUE KEY `uk_user_id_liker_id` (`user_id`,`liker_id`)
) ENGINE=InnoDB;


CREATE TABLE `friend` (
    id` int(11) NOT NULL AUTO_INCREMENT,
    `friend_1_id` int(11) NOT NULL,
    `firned_2_id` int(11) NOT NULL,
    UNIQUE KEY `uk_friend` (`friend_1_id`,`firned_2_id`)
    PRIMARY KEY (`id`)
) ENGINE=InnoDB;

```

虽然这个题干中，并没有说到friend表的索引结构。但我猜测friend_1_id和friend_2_id也有索引，为便于描述，我给加上唯一索引。

顺便说明一下，“like”是关键字，我一般不建议使用关键字作为库名、表名、字段名或索引名。

我把他的疑问翻译一下，在并发场景下，同时有两个人，设置为关注对方，就可能导致无法成功 加为朋友关系。

现在，我用你已经熟悉的时刻顺序表的形式，把这两个事务的执行语句列出来：

<img src="MYSQL实战45讲.assets/image-20250214182627050.png" alt="image-20250214182627050" style="zoom:50%;" />



由于一开始A和B之间没有关注关系，所以两个事务里面的select语句查出来的结果都是空。

因此，session 1的逻辑就是“既然B没有关注A，那就只插入一个单向关注关系”。session 2也同 样是这个逻辑。



这个结果对业务来说就是bug了。因为在业务设定里面，这两个逻辑都执行完成以后，是应该在 friend表里面插入一行记录的。



如提问里面说的，“第1步即使使用了排他锁也不行，因为记录不存在，行锁无法生效”。不过， 我想到了另外一个方法，来解决这个问题。

首先，要给“like”表增加一个字段，比如叫作 relation_ship，并设为整型，取值1、2、3。

> 值是1的时候，表示user_id 关注 liker_id; 
>
> 值是2的时候，表示liker_id 关注 user_id; 
>
> 值是3的时候，表示互相关注。

然后，当 A关注B的时候，逻辑改成如下所示的样子：

应用代码里面，比较A和B的大小，如果A < B，就执行下面的逻辑

```sql
mysql> begin; /*启动事务*/
insert into `like`(user_id, liker_id, relation_ship) values(A, B, 1) on duplicate key update relation_ship=relation_ship | 1;
select relation_ship from `like` where user_id=A and liker_id=B;
/*代码中判断返回的 relation_ship，
如果是1，事务结束，执行 commit
如果是3，则执行下面这两个语句：
*/
insert ignore into friend(friend_1_id, friend_2_id) values(A,B);
commit;

```

如果A>B，则执行下面的逻辑

```sql
mysql> begin; /*启动事务*/
insert into `like`(user_id, liker_id, relation_ship) values(B, A, 2) on duplicate key update relation_ship=relation_ship | 2;
select relation_ship from `like` where user_id=B and liker_id=A;
/*代码中判断返回的 relation_ship，
如果是2，事务结束，执行 commit
如果是3，则执行下面这两个语句：
*/
insert ignore into friend(friend_1_id, friend_2_id) values(B,A);
commit;

```

**这个设计里，让“like”表里的数据保证user_id < liker_id**，这样不论是A关注B，还是B关注A，在 操作“like”表的时候，如果反向的关系已经存在，就会出现行锁冲突。

然后，insert …on duplicate语句，确保了在事务内部，执行了这个SQL语句后，就强行占住了这 个行锁，之后的select 判断relation_ship这个逻辑时就确保了是在行锁保护下的读操作。

操作符 “|” 是按位或，连同最后一句insert语句里的**ignore**，是为了保证重复调用时的幂等性。

这样，即使在双方“同时”执行关注操作，最终数据库里的结果，也是like表里面有一条关于A和B 的记录，而且relation_ship的值是3， 并且friend表里面也有了A和B的这条记录。



不知道你会不会吐槽：之前明明还说尽量不要使用唯一索引，结果这个例子一上来我就创建了两 个。这里我要再和你说明一下，之前文章我们讨论的，是在“业务开发保证不会插入重复记录”的 情况下，着重要解决性能问题的时候，才建议尽量使用普通索引。

而像这个例子里，按照这个设计，业务根本就是保证“我一定会插入重复数据，数据库一定要要 有唯一性约束”，这时就没啥好说的了，唯一索引建起来吧。



## 小结

这是专栏的第一篇答疑文章。

我针对前14篇文章，大家在评论区中的留言，从中摘取了关于日志和索引的相关问题，串成了 今天这篇文章。这里我也要再和你说一声，有些我答应在答疑文章中进行扩展的话题，今天这篇 文章没来得及扩展，后续我会再找机会为你解答。所以，篇幅所限，评论区见吧。



### 思考题

最后，虽然这篇是答疑文章，但课后问题还是要有的。 我们创建了一个简单的表t，并插入一行，然后对这一行做修改。

```sql
mysql> CREATE TABLE `t` (
    `id` int(11) NOT NULL primary key auto_increment,
    `a` int(11) DEFAULT NULL
) ENGINE=InnoDB;
insert into t values(1,2);
```

这时候，表t里有唯一的一行数据(1,2)。假设，我现在要执行：

```
mysql> update t set a=2 where id=1;
```

你会看到这样的结果：

<img src="MYSQL实战45讲.assets/image-20250214193006657.png" alt="image-20250214193006657" style="zoom:50%;" />

结果显示，匹配(rows matched)了一行，修改(Changed)了0行。 仅从现象上看，MySQL内部在处理这个命令的时候，可以有以下三种选择：

1. 更新都是先读后写的，MySQL读出数据，发现a的值本来就是2，不更新，直接返回，执行结束；
2. MySQL调用了InnoDB引擎提供的“修改为(1,2)”这个接口，但是引擎发现值与原来相同，不更新，直接返回；
3. InnoDB认真执行了“把这个值修改成(1,2)"这个操作，该加锁的加锁，该更新的更新。

你觉得实际情况会是以上哪种呢？你可否用构造实验的方式，来证明你的结论？进一步地，可以 思考一下，MySQL为什么要选择这种策略呢？

> 回答

上期的问题是，当MySQL去更新一行，但是要修改的值跟原来的值是相同的，这时候MySQL会 真的去执行一次修改吗？还是看到值相同就直接返回呢？

这是第一次我们课后问题的三个选项都有同学选的，所以我要和你需要详细说明一下。

第一个选项是，MySQL读出数据，发现值与原来相同，不更新，直接返回，执行结束。这里我 们可以用一个锁实验来确认。

假设，当前表t里的值是(1,2)。

<img src="MYSQL实战45讲.assets/image-20250214193311124.png" alt="image-20250214193311124" style="zoom:50%;" />

session B的update 语句被blocked了，加锁这个动作是InnoDB才能做的，所以排除选项1。



第二个选项是，MySQL调用了InnoDB引擎提供的接口，但是引擎发现值与原来相同，不更新， 直接返回。有没有这种可能呢？这里我用一个可见性实验来确认。

假设当前表里的值是(1,2)。

<img src="MYSQL实战45讲.assets/image-20250214193422594.png" alt="image-20250214193422594" style="zoom: 50%;" />

session A的第二个select 语句是一致性读（快照读)，它是不能看见session B的更新的。

现在它返回的是(1,3)，表示它看见了某个新的版本，这个版本只能是session A自己的update语 句做更新的时候生成。（如果你对这个逻辑有疑惑的话，可以回顾下第8篇文章《事务到底是隔 离的还是不隔离的？》中的相关内容）



所以，**我们上期思考题的答案应该是选项3**，即：InnoDB认真执行了“把这个值修改成(1,2)"这个操作，该加锁的加锁，该更新的更新。

然后你会说，MySQL怎么这么笨，就不会更新前判断一下值是不是相同吗？如果判断一下，不 就不用浪费InnoDB操作，多去更新一次了



其实MySQL是确认了的。只是在这个语句里面，MySQL认为读出来的值，只有一个确定的 (id=1), 而要写的是(a=3)，只从这两个信息是看不出来“不需要修改”的。



作为验证，你可以看一下下面这个例子。

<img src="MYSQL实战45讲.assets/image-20250214195937768.png" alt="image-20250214195937768" style="zoom:50%;" />

补充说明： 上面我们的验证结果都是在binlog_format=statement格式下进行的。



@didiren 补充了一个case， 如果是binlog_format=row并且binlog_row_image=FULL的时候，由 于MySQL需要在binlog里面记录所有的字段，所以在读数据的时候就会把所有数据都读出来了。 

根据上面说的规则，“既然读了数据，就会判断”， 因此在这时候，select *fromt where id=1， 结果就是“返回 (1,2)”。

同理，如果是binlog_row_image=NOBLOB, 会读出除blob 外的所有字段，在我们这个例子里， 结果还是“返回 (1,2)”。

<img src="MYSQL实战45讲.assets/image-20250214200036154.png" alt="image-20250214200036154" style="zoom: 67%;" />

类似的，@mahonebags 同学提到了timestamp字段的问题。结论是：如果表中有timestamp字段而且设置了自动更新的话，那么更新“别的字段”的时候，MySQL会读入所有涉及的字段，这样 通过判断，就会发现不需要修改。 这两个点我会在后面讲更新性能的文章中再展开。



```
评论区留言点赞板： @Gavin 、@melon、@阿建 等同学提到了锁验证法； 
@郭江伟 同学提到了两个点，都非常好，有去实际验证。结论是这样的： 第一，hexdump看出来没改应该是WAL机制生效了，要过一会儿，或者把库shutdown看看。 第二，binlog没写是MySQL Server层知道行的值没变，所以故意不写的，这个是在row格式下 的策略。你可以把binlog_format 改成statement再验证下
```





# 16 | “order by”是怎么工作的？

在你开发应用的时候，一定会经常碰到需要根据指定的字段排序来显示结果的需求。还是以我们前面举例用过的市民表为例，假设你要查询城市是“杭州”的所有人名字，并且按照姓名排序返回前1000个人的姓名、年龄。

假设这个表的部分定义是这样的：

```sql
CREATE TABLE `t` (
    `id` int(11) NOT NULL,
    `city` varchar(16) NOT NULL,
    `name` varchar(16) NOT NULL,
    `age` int(11) NOT NULL,
    `addr` varchar(128) DEFAULT NULL,
    PRIMARY KEY (`id`),
    KEY `city` (`city`)
) ENGINE=InnoDB;
```

这时，你的SQL语句可以这么写：

```SQL
select city,name,age from t where city='杭州' order by name limit 1000 ;
```

这个语句看上去逻辑很清晰，但是你了解它的执行流程吗？今天，我就和你聊聊这个语句是怎么执行的，以及有什么参数会影响执行的行为。

## 全字段排序

前面我们介绍过索引，所以你现在就很清楚了，为避免全表扫描，我们需要在city字段加上索引。

在city字段上创建索引之后，我们用explain命令来看看这个语句的执行情况。

```sql
mysql> explain select city,name,age from t where city='杭州' order by name limit 1000 ;
```

![image-20240426192519643](MYSQL实战45讲.assets/image-20240426192519643.png)

​                                                                                                  图1 使用explain命令查看语句的执行情况

这是一个 MySQL 的 `EXPLAIN` 查询结果，用于解释查询语句的执行计划和性能优化信息。下面是对每个列的解释：

- `id`: 查询中每个操作的标识符。在这个例子中，只有一个操作，因此为 1。
- `select_type`: 查询的类型。在这个例子中，是 `SIMPLE`，表示这是一个简单的 SELECT 查询。
- `table`: 查询涉及的表名。
- `partitions`: 表的分区信息。在这个例子中，为 `NULL`，表示没有使用分区。
- `type`: 访问类型，表示查询时使用的访问方法。**在这个例子中，是 `ref`，表示使用索引进行查询**。
- `possible_keys`: 可能使用的索引列表。
- `key`: 实际使用的索引。
- `key_len`: 使用的索引长度。
- `ref`: 表示索引的哪个列或常量与查询条件进行比较。
- `rows`: 估计的扫描行数。
- `filtered`: 表示在表中过滤的行的百分比。
- `Extra`: 额外的信息和优化提示。在这个例子中，表示使用了索引条件和文件排序。

Extra这个字段中的“Using filesort”表示的就是需要排序，**MySQL会给每个线程分配一块内存用于排序，称为sort_buffer。**

为了说明这个SQL查询语句的执行过程，我们先来看一下city这个索引的示意图。

<img src="MYSQL实战45讲.assets/image-20240426192103573.png" alt="image-20240426192103573" style="zoom:50%;" />

​                                                                                                      图2 city字段的索引示意图



从图中可以看到，满足city='杭州’条件的行，是从ID_X到ID_(X+N)的这些记录。

通常情况下，这个语句执行流程如下所示 ：（聚簇索引+非聚簇索引）

1. 初始化sort_buffer，确定放入name、city、age这三个字段；

2. 从索引city找到第一个满足city='杭州’条件的主键id，也就是图中的ID_X；

3. 到主键id索引取出整行，取name、city、age三个字段的值，存入sort_buffer中；

4. 从索引city取下一个记录的主键id；

5. 重复步骤3、4直到city的值不满足查询条件为止，对应的主键id也就是图中的ID_Y；

6. 对sort_buffer中的数据按照字段name做快速排序；

7. 按照排序结果取前1000行返回给客户端。

我们暂且把这个排序过程，称为**全字段排序**，执行流程的示意图如下所示，下一篇文章中我们还会用到这个排序。

<img src="MYSQL实战45讲.assets/image-20240426192338252.png" alt="image-20240426192338252" style="zoom:50%;" />

​                                                                                                                             图3 全字段排序

图中“按name排序”这个动作，**可能在内存中完成，也可能需要使用外部排序**，这取决于排序所需的**内存和参数sort_buffer_size**。

sort_buffer_size，就是MySQL为排序开辟的内存（sort_buffer）的大小。如果要排序的数据量小于sort_buffer_size，排序就在内存中完成。但如果排序数据量太大，内存放不下，则不得不利用磁盘临时文件辅助排序

你可以用下面介绍的方法，来确定一个排序语句是否使用了临时文件。

```sql
/* 打开optimizer_trace，只对本线程有效 */
SET optimizer_trace='enabled=on';
/* @a保存Innodb_rows_read的初始值 */
select VARIABLE_VALUE into @a from performance_schema.session_status where variable_name = 'Innodb_rows_read';
/* 执行语句 */
select city, name,age from t where city='杭州' order by name limit 1000;
/* 查看 OPTIMIZER_TRACE 输出 */
SELECT * FROM `information_schema`.`OPTIMIZER_TRACE`\G
/* @b保存Innodb_rows_read的当前值 */
select VARIABLE_VALUE into @b from performance_schema.session_status where variable_name = 'Innodb_rows_read';
/* 计算Innodb_rows_read差值 */
select @b-@a;
```

这个方法是通过查看 OPTIMIZER_TRACE 的结果来确认的，你可以从 **number_of_tmp_files**中看到是否使用了临时文件

![image-20240426192804478](MYSQL实战45讲.assets/image-20240426192804478.png)

​                                                                                    图4 全排序的OPTIMIZER_TRACE部分结果

number_of_tmp_files表示的是，排序过程中使用的临时文件数。你一定奇怪，为什么需要12个文件？内存放不下时，就需要使用外部排序，外部排序一般使用**归并排序算法**。

示例表中有4000条满足city='杭州’的记录，所以你可以看到 examined_rows=4000，表示参与排序的行数是4000行。

sort_mode 里面的packed_additional_fields的意思是，排序过程对字符串做了“紧凑”处理。即使name字段的定义是varchar(16)，在排序过程中还是要按照实际长度来分配空间的。

同时，最后一个查询语句select @b-@a 的返回结果是4000，表示整个执行过程只扫描了4000行。

这里需要注意的是，为了避免对结论造成干扰，我把internal_tmp_disk_storage_engine设置成MyISAM。否则，select @b-@a的结果会显示为4001。这是因为查询OPTIMIZER_TRACE这个表时，需要用到临时表，而**internal_tmp_disk_storage_engine**的默认值是InnoDB。如果使用的是InnoDB引擎的话，把数据从临时表取出来的时候，会让Innodb_rows_read的值加1。



## **rowId**排序

在上面这个算法过程里面，只对原表的数据读了一遍，剩下的操作都是在sort_buffer和临时文件中执行的。但这个算法有一个问题，就是如果查询要返回的字段很多的话，那么sort_buffer里面要放的字段数太多，这样内存里能够同时放下的行数很少，要分成很多个临时文件，排序的性能会很差。所以如果单行很大，这个方法效率不够好。

接下来，我来修改一个参数，让MySQL采用另外一种算法

```sql
SET max_length_for_sort_data = 16;
```

max_length_for_sort_data，是MySQL中专门控制用于排序的行数据的长度的一个参数。它的意思是，如果单行的长度超过这个值，MySQL就认为单行太大，要换一个算法。city、name、age 这三个字段的定义总长度是36，我把max_length_for_sort_data设置为16，我们再来看看计算过程有什么改变。

新的算法放入sort_buffer的字段，只有要排序的列（即name字段）和主键id

但这时，排序的结果就因为少了city和age字段的值，不能直接返回了，整个执行流程就变成如下所示的样子：

1. 初始化sort_buffer，确定放入两个字段，即name和id；

2. 从索引city找到第一个满足city='杭州’条件的主键id，也就是图中的ID_X；

3. 到主键id索引取出整行，取name、id这两个字段，存入sort_buffer中；

4. 从索引city取下一个记录的主键id；

5. 重复步骤3、4直到不满足city='杭州’条件为止，也就是图中的ID_Y；

6. 对sort_buffer中的数据按照字段name进行排序；

7. 遍历排序结果，取前1000行，并按照id的值回到原表中取出city、name和age三个字段返回给客户端。（**多了一次回表查询**）

这个执行流程的示意图如下，我把它称为rowid排序。

![image-20240426194011936](MYSQL实战45讲.assets/image-20240426194011936.png)

​                                                                                        图5 rowid排序

根据这个说明过程和图示，你可以想一下，这个时候执行select @b-@a，结果会是多少呢？

现在，我们就来看看结果有什么不同。

首先，图中的examined_rows的值还是4000，表示用于排序的数据是4000行。但是select @b-@a这个语句的值变成5000了。

因为这时候除了排序过程外，在排序完成后，还要根据id去原表取值。由于语句是limit 1000，因此会多读1000行。

<img src="MYSQL实战45讲.assets/image-20240426194738764.png" alt="image-20240426194738764" style="zoom:50%;" />

​                                                                                        图6 rowid排序的OPTIMIZER_TRACE部分输出

从OPTIMIZER_TRACE的结果中，你还能看到另外两个信息也变了。sort_mode变成了<sort_key, rowid>，表示参与排序的只有name和id这两个字段。

number_of_tmp_files变成10了，是因为这时候参与排序的行数虽然仍然是4000行，但是每一行都变小了，因此需要排序的总数据量就变小了，需要的临时文件也相应地变少了



## 全字段排序 VS rowid排序

对于InnoDB表来说，rowid排序会要求回表多造成磁盘读，因此不会被优先选择。

这体现了**MySQL的一个设计思想：如果内存够，就要多利用内存，尽量减少磁盘访问。**

看到这里，你就了解了，MySQL做排序是一个成本比较高的操作。那么你会问，是不是所有的order by都需要排序操作呢？如果不排序就能得到正确的结果，那对系统的消耗会小很多，语句的执行时间也会变得更短。

你可以设想下，如果能够保证从city这个索引上取出来的行，天然就是按照name递增排序的话，是不是就可以不用再排序了呢？确实是这样的。

所以，我们可以在这个市民表上创建一个city和name的联合索引，对应的SQL语句是：

```sql
alter table t add index city_user(city, name);
```

作为与city索引的对比，我们来看看这个索引的示意图。

<img src="MYSQL实战45讲.assets/image-20240426195330323.png" alt="image-20240426195330323" style="zoom:50%;" />

​                                                                                          图7 city和name联合索引示意图

在这个索引里面，我们依然可以用树搜索的方式定位到第一个满足city='杭州’的记录，并且额外确保了，接下来按顺序取“下一条记录”的遍历过程中，只要city的值是杭州，name的值就一定是有序的。

这样整个查询过程的流程就变成了：

1. 从索引(city,name)找到第一个满足city='杭州’条件的主键id；

2. 到主键id索引取出整行，取name、city、age三个字段的值，作为结果集的一部分直接返

回；

3. 从索引(city,name)取下一个记录主键id；
4.  重复步骤2、3，直到查到第1000条记录，或者是不满足city='杭州’条件时循环结束。

<img src="MYSQL实战45讲.assets/image-20240426195530556.png" alt="image-20240426195530556" style="zoom:50%;" />

​                                                                    图8 引入(city,name)联合索引后，查询语句的执行计划

可以看到，这个查询过程不需要临时表，也不需要排序。接下来，我们用explain的结果来印证一下。

![image-20240426195601594](MYSQL实战45讲.assets/image-20240426195601594.png)

​                                                         图9 引入(city,name)联合索引后，查询语句的执行计划

从图中可以看到，Extra字段中没有Using filesort了，也就是不需要排序了。而且由于(city,name)这个联合索引本身有序，所以这个查询也不用把4000行全都读一遍，只要找到满足条件的前1000条记录就可以退出了。也就是说，在我们这个例子里，只需要扫描1000次。

進一步簡化：覆盖索引。指索引上的信息足够满足查询请求，不需要再 覆回到主键索引上去取数据。

按照覆盖索引的概念，我们可以再优化一下这个查询语句的执行流程。

针对这个查询，我们可以创建一个city、name和age的联合索引，对应的SQL语句就是：

```sql
alter table t add index city_user_age(city, name, age);
```

这时，对于city字段的值相同的行来说，还是按照name字段的值递增排序的，此时的查询语句也

就不再需要排序了。这样整个查询语句的执行流程就变成了：

1. 从索引(city,name,age)找到第一个满足city='杭州’条件的记录，取出其中的city、name和age

这三个字段的值，作为结果集的一部分直接返回；

2. 从索引(city,name,age)取下一个记录，同样取出这三个字段的值，作为结果集的一部分直接

返回；

3. 重复执行步骤2，直到查到第1000条记录，或者是不满足city='杭州’条件时循环结束。

<img src="MYSQL实战45讲.assets/image-20240426195944226.png" alt="image-20240426195944226" style="zoom:50%;" />

​                                                                           图10 引入(city,name,age)联合索引后，查询语句的执行流程

然后，我们再来看看explain的结果：

![image-20240426200021609](MYSQL实战45讲.assets/image-20240426200021609.png)

​                                                                                   图11 引入(city,name,age)联合索引后，查询语句的执行计划

可以看到，Extra字段里面多了“Using index”，表示的就是使用了覆盖索引，性能上会快很多。

当然，这里并不是说要为了每个查询能用上覆盖索引，就要把语句中涉及的字段都建上联合索引，毕竟索引还是有维护代价的。这是一个需要权衡的决定。



## 小结

今天这篇文章，我和你介绍了MySQL里面order by语句的几种算法流程。

在开发系统的时候，你总是不可避免地会使用到order by语句。你心里要清楚每个语句的排序逻辑是怎么实现的，还要能够分析出在最坏情况下，每个语句的执行对系统资源的消耗，这样才能做到下笔如有神，不犯低级错误。



> 全字段索引和 RowId 索引是 MySQL 中两种不同的索引类型，它们在索引的方式和使用场景上有一些异同。
>
> 异同点如下：
>
> 1. 定义方式：全字段索引是基于表中的所有字段创建的索引，而 RowId 索引是基于 InnoDB 存储引擎的聚簇索引，它使用行的物理位置作为索引。
> 2. 索引结构：全字段索引使用 B-Tree 或哈希等数据结构来组织索引，而 RowId 索引是通过 InnoDB 存储引擎的聚簇索引来实现的，它将数据行存储在物理上相邻的位置。
> 3. 索引范围：全字段索引可以覆盖表中的所有字段，而 RowId 索引只能覆盖聚簇索引中的字段。
> 4. 查询性能：全字段索引适用于多字段的查询，可以提高查询的速度，但在更新数据时可能会影响性能。RowId 索引在聚簇索引上具有快速的查询性能，但在频繁更新数据时可能会导致性能下降。
> 5. 索引大小：全字段索引的大小通常比 RowId 索引大，因为它包含了更多的字段信息。RowId 索引的大小相对较小，因为它只包含了聚簇索引的信息。





## 思考题

假设你的表里面已经有了city_name(city, name)这个联合索引，然后你要查杭州和苏州两个城市中所有的市民的姓名，并且按名字排序，显示前100条记录。如果SQL查询语句是这么写的 ：

```
mysql> select * from t where city in ('杭州',"苏州") order by name limit 100;
```

那么，这个语句执行的时候会有排序过程吗，为什么？

如果业务端代码由你来开发，需要实现一个在数据库端不需要排序的方案，你会怎么实现呢？

进一步地，如果有分页需求，要显示第101页，也就是说语句最后要改成 “limit 10000,100”， 你的实现方法又会是什么呢？



# 17 | 如何正确地显示随机消息？

我在上一篇文章，为你讲解完order by语句的几种执行模式后，就想到了之前一个做英语学习 App的朋友碰到过的一个性能问题。今天这篇文章，我就从这个性能问题说起，和你说说MySQL 中的另外一种排序需求，希望能够加深你对MySQL排序逻辑的理解。



这个英语学习App首页有一个随机显示单词的功能，也就是根据每个用户的级别有一个单词表， 然后这个用户每次访问首页的时候，都会随机滚动显示三个单词。他们发现随着单词表变大，选 单词这个逻辑变得越来越慢，甚至影响到了首页的打开速度。



现在，如果让你来设计这个SQL语句，你会怎么写呢？

为了便于理解，我对这个例子进行了简化：去掉每个级别的用户都有一个对应的单词表这个逻 辑，直接就是从一个单词表中随机选出三个单词。这个表的建表语句和初始数据的命令如下：

```mysql
mysql> CREATE TABLE `words` (
    `id` int(11) NOT NULL AUTO_INCREMENT,
    `word` varchar(64) DEFAULT NULL,
    PRIMARY KEY (`id`)
) ENGINE=InnoDB;
delimiter ;;
create procedure idata1()
begin
    declare i int;
    set i=0;
    while i<10000 do
        insert into words(word) values(concat(char(97+(i div 1000)), char(97+(i % 1000 div 100)), char(97+(i % 100 div 10)), char(97+(i % 10))));
        set i=i+1;
    end while;
end;;
delimiter ;
call idata1();

mysql> select * from words limit 10;
+----+------+
| id | word |
+----+------+
|  1 | aaaa |
|  2 | aaab |
|  3 | aaac |
|  4 | aaad |
|  5 | aaae |
|  6 | aaaf |
|  7 | aaag |
|  8 | aaah |
|  9 | aaai |
| 10 | aaaj |
+----+------+

```

为了便于量化说明，我在这个表里面插入了10000行记录。接下来，我们就一起看看要随机选择 3个单词，有什么方法实现，存在什么问题以及如何改进。



## 内存临时表

首先，你会想到用order by rand()来实现这个逻辑。

```
mysql> select word from words order by rand() limit 3;
+------+
| word |
+------+
| bahj |
| baeb |
| fifh |
+------+

mysql> select rand();
+---------------------+
| rand()              |
+---------------------+
| 0.22126676535351833 |
+---------------------+
```

这个语句的意思很直白，随机排序取前3个。虽然这个SQL语句写法很简单，但执行流程却有点 复杂的。

我们先用explain命令来看看这个语句的执行情况。

![image-20250217161142355](MYSQL实战45讲.assets/image-20250217161142355.png)

Extra字段显示Using temporary，表示的是需要使用临时表；Using filesort，表示的是需要执行排序操作。

因此这个Extra的意思就是，需要临时表，并且需要在临时表上排序。

这里，你可以先回顾一下上一篇文章中全字段排序和rowid排序的内容。我把上一篇文章的两个 流程图贴过来，方便你复习。

<img src="MYSQL实战45讲.assets/image-20250217161448337.png" alt="image-20250217161448337" style="zoom:50%;" />



<img src="MYSQL实战45讲.assets/image-20250217161541985.png" alt="image-20250217161541985" style="zoom:50%;" />

==》rowid索引排序多了一步回表查询。。

然后，我再问你一个问题，你觉得对于临时内存表的排序来说，它会选择哪一种算法呢？

回顾一下上一篇文章的一个结论：**对于InnoDB表来说，执行全字段排序会减少磁盘访问，因此会被优先选择**。



我强调了“InnoDB表”，你肯定想到了，对于内存表，回表过程只是简单地根据数据行的位 置，直接访问内存得到数据，根本不会导致多访问磁盘。优化器没有了这一层顾虑，那么它 会优先考虑的，就是用于排序的行越少越好了，所以，MySQL这时就会选择rowid排序。



理解了这个算法选择的逻辑，我们再来看看语句的执行流程。同时，通过今天的这个例子，我们来尝试**分析一下语句的扫描行数**。



这条语句的执行流程是这样的：

1. 创建一个临时表。这个临时表使用的是**memory引擎**，表里有两个字段，第一个字段是 double类型，为了后面描述方便，记为字段R，第二个字段是varchar(64)类型，记为字段 W。并且，这个表没有建索引。

2. 从words表中，按主键顺序取出所有的word值。**对于每一个word值，调用rand()函数生成一 个大于0小于1的随机小数，并把这个随机小数和word分别存入临时表的R和W字段中**，到此，扫描行数是10000。
3. 现在临时表有10000行数据了，接下来你要在这个没有索引的内存临时表上，按照字段R排序。
4. 初始化 **sort_buffer**。sort_buffer中有两个字段，一个是double类型，另一个是整型。
5. 从内存临时表中一行一行地取出R值和位置信息（我后面会和你解释这里为什么是“位置信 息”），分别存入sort_buffer中的两个字段里。这个过程要对内存临时表做全表扫描，此时 扫描行数增加10000，变成了20000。
6. 在sort_buffer中根据R的值进行排序。注意，这个过程没有涉及到表操作，所以不会增加扫 描行数。
7. 排序完成后，取出前三个结果的位置信息，依次到内存临时表中取出word值，返回给客户 端。这个过程中，访问了表的三行数据，总扫描行数变成了20003。

接下来，我们通过慢查询日志（slow log）来验证一下我们分析得到的扫描行数是否正确。

```bash
# Query_time: 0.900376 Lock_time: 0.000347 Rows_sent: 3 Rows_examined: 20003
SET timestamp=1541402277;
select word from words order by rand() limit 3;
```

其中，Rows_examined：20003就表示这个语句执行过程中扫描了20003行，也就验证了我们分析得出的结论。

这里插一句题外话，在平时学习概念的过程中，你可以经常这样做，**先通过原理分析算出扫描行数，然后再通过查看慢查询日志，来验证自己的结论**。我自己就是经常这么做，这个过程很有 趣，分析对了开心，分析错了但是弄清楚了也很开心。

现在，我来把完整的排序执行流程图画出来。

<img src="MYSQL实战45讲.assets/image-20250217172456168.png" alt="image-20250217172456168" style="zoom:67%;" />



> sort_buffer是啥？

图中的pos就是位置信息，你可能会觉得奇怪，这里的“位置信息”是个什么概念？在上一篇文章 中，我们对InnoDB表排序的时候，明明用的还是ID字段。

这时候，我们就要回到一个基本概念：MySQL的表是用什么方法来定位“一行数据”的。



在前面第4和第5篇介绍索引的文章中，有几位同学问到，如果把一个InnoDB表的主键删掉，是 不是就没有主键，就没办法回表了？

其实不是的。如果你创建的表没有主键，或者把一个表的主键删掉了，那么**InnoDB会自己生成 一个长度为6字节的rowid来作为主键**。

这也就是排序模式里面，rowid名字的来历。实际上它表示的是：每个引擎用来唯一标识数据行 的信息。

- 对于有主键的InnoDB表来说，这个rowid就是主键ID；
- 对于没有主键的InnoDB表来说，这个rowid就是由系统生成的； 
- MEMORY引擎不是索引组织表。在这个例子里面，你可以认为它就是一个数组。因此，这个 rowid其实就是数组的下标。

到这里，我来稍微小结一下：order by rand()使用了内存临时表，内存临时表排序的时候使 用了row id排序方法。



## 磁盘临时表

那么，是不是所有的临时表都是**内存表**呢？

其实不是的。tmp_table_size这个配置限制了内存临时表的大小，默认值是16M。如果临时表大 小超过了tmp_table_size，那么内存临时表就会转成**磁盘临时表**。

磁盘临时表使用的引擎默认是InnoDB，是由参数`internal_tmp_disk_storage_engine`控制的。

当使用磁盘临时表的时候，对应的就是一个没有显式索引的InnoDB表的排序过程。

为了复现这个过程，我把tmp_table_size设置成1024，把sort_buffer_size设置成 32768, 把 max_length_for_sort_data 设置成16。



```bash
set tmp_table_size=1024;
set sort_buffer_size=32768;
set max_length_for_sort_data=16;

/* 打开 optimizer_trace，只对本线程有效 */
SET optimizer_trace='enabled=on';

/* 执行语句 */
select word from words order by rand() limit 3;

/* 查看 OPTIMIZER_TRACE 输出 */
SELECT * FROM `information_schema`.`OPTIMIZER_TRACE`\G

```

<img src="MYSQL实战45讲.assets/image-20250217173255099.png" alt="image-20250217173255099" style="zoom:50%;" />

然后，我们来看一下这次OPTIMIZER_TRACE的结果。

因为将max_length_for_sort_data设置成16，小于word字段的长度定义，所以我们看到 sort_mode里面显示的是rowid排序，这个是符合预期的，参与排序的是随机值R字段和rowid字 段组成的行。

这时候你可能心算了一下，发现不对。R字段存放的随机值就8个字节，rowid是6个字节（至于 为什么是6字节，就留给你课后思考吧），数据总行数是10000，这样算出来就有140000字节， 超过了sort_buffer_size 定义的 32768字节了。但是，number_of_tmp_files的值居然是0，难道 不需要用临时文件吗？

这个SQL语句的排序确实没有用到临时文件，采用是MySQL 5.6版本引入的一个新的排序算法， 即：**优先队列排序算法**（堆排序）。接下来，我们就看看为什么没有使用临时文件的算法，也就是**归并排序算法**，而是采用了优先队列排序算法。

其实，我们现在的SQL语句，只需要取R值最小的3个rowid。但是，如果使用归并排序算法的 话，虽然最终也能得到前3个值，但是这个算法结束后，已经将10000行数据都排好序了。

也就是说，后面的9997行也是有序的了。但，我们的查询并不需要这些数据是有序的。所以， 想一下就明白了，这浪费了非常多的计算量。



而优先队列算法，就可以精确地只得到三个最小值，执行流程如下：

1. 对于这10000个准备排序的(R,rowid)，先取前三行，构造成一个堆；（对数据结构印象模糊的同学，可以先设想成这是一个由三个元素组成的数组）
2. 取下一个行(R’,rowid’)，跟当前堆里面最大的R比较，如果R’小于R，把这个(R,rowid)从堆中 去掉，换成(R’,rowid’)；
3. 重复第2步，直到第10000个(R’,rowid’)完成比较。

这里我简单画了一个优先队列排序过程的示意图

<img src="MYSQL实战45讲.assets/image-20250217180705905.png" alt="image-20250217180705905" style="zoom:50%;" />



图6是模拟6个(R,rowid)行，通过优先队列排序找到最小的三个R值的行的过程。整个排序过程中，为了最快地拿到**当前堆的最大值**，总是保持最大值在堆顶，因此这是一个最大堆。



图5的OPTIMIZER_TRACE结果中，filesort_priority_queue_optimization这个部分的 `chosen=true`，就表示使用了优先队列排序算法，这个过程不需要临时文件，因此对应的 number_of_tmp_files是0。

这个流程结束后，我们构造的堆里面，就是这个10000行里面R值最小的三行。然后，依次把它 们的rowid取出来，去临时表里面拿到word字段，这个过程就跟上一篇文章的rowid排序的过程一样了。

我们再看一下上面一篇文章的SQL查询语句：

```sql
select city,name,age from t where city='杭州' order by name limit 1000 ;
```



你可能会问，这里也用到了limit，为什么没用优先队列排序算法呢？原因是，这条SQL语句是 limit 1000，如果使用优先队列算法的话，需要维护的堆的大小就是1000行的(name,rowid)，超 过了我设置的`sort_buffer_size`大小，所以只能使用归并排序算法。



总之，不论是使用哪种类型的临时表，order by rand()这种写法都会让计算过程非常复杂，需要 大量的扫描行数，因此排序过程的资源消耗也会很大。 再回到我们文章开头的问题，怎么正确地随机排序呢？



## 随机排序方法

我们先把问题简化一下，如果只随机选择1个word值，可以怎么做呢？思路上是这样的：

1. 取得这个表的主键id的最大值M和最小值N;
2. 用随机函数生成一个最大值到最小值之间的数 X = (M-N)*rand() +N;
3. 取不小于X的第一个ID的行。

我们把这个算法，暂时称作随机算法1。这里，我直接给你贴一下执行语句的序列:

```
mysql> select max(id),min(id) into @M,@N from t ;
set @X= floor((@M-@N+1)*rand() + @N);
select * from t where id >= @X limit 1;
```

这个方法效率很高，因为取max(id)和min(id)都是不需要扫描索引的，而第三步的select也可以用 索引快速定位，可以认为就只扫描了3行。但实际上，这个算法本身并不严格满足题目的随机要 求，因为ID中间可能有空洞，因此选择不同行的概率不一样，不是真正的随机。



比如你有4个id，分别是1、2、4、5，如果按照上面的方法，那么取到 id=4的这一行的概率是取 得其他行概率的两倍。

如果这四行的id分别是1、2、40000、40001呢？这个算法基本就能当bug来看待了。



所以，**为了得到严格随机的结果**，你可以用下面这个流程:

1. 取得整个表的行数，并记为C。 
2. 取得 Y = floor(C*rand())。 floor函数在这里的作用，就是取整数部分。 
3. 再用limit Y,1 取得一行。

我们把这个算法，称为随机算法2。下面这段代码，就是上面流程的执行语句的序列。

```sql
mysql> select count(*) into @C from t;
set @Y = floor(@C * rand());
set @sql = concat("select * from t limit ", @Y, ",1");
prepare stmt from @sql;
execute stmt;
DEALLOCATE prepare stmt;
```

由于limit 后面的参数不能直接跟变量，所以我在上面的代码中使用了**prepare+execute的方法**。 你也可以把拼接SQL语句的方法写在应用程序中，会更简单些。



这个随机算法2，解决了算法1里面明显的概率不均匀问题。

MySQL处理limit Y,1 的做法就是按顺序一个一个地读出来，丢掉前Y个，然后把下一个记录作为 返回结果，因此这一步需要扫描Y+1行。再加上，第一步扫描的C行，总共需要扫描C+Y+1行， 执行代价比随机算法1的代价要高。



当然，随机算法2跟直接order by rand()比起来，执行代价还是小很多的。



你可能问了，如果按照这个表有10000行来计算的话，C=10000，要是随机到比较大的Y值，那 扫描行数也跟20000差不多了，接近order by rand()的扫描行数，为什么说随机算法2的代价要小 很多呢？我就把这个问题留给你去课后思考吧。



现在，我们再看看，如果我们按照随机算法2的思路，要随机取3个word值呢？你可以这么做：

1. 取得整个表的行数，记为C； 
2. 根据相同的随机方法得到Y1、Y2、Y3；
3. 再执行三个limit Y, 1语句得到三行数据。

我们把这个算法，称作随机算法3。下面这段代码，就是上面流程的执行语句的序列。

```sql
mysql> select count(*) into @C from t;
set @Y1 = floor(@C * rand());
set @Y2 = floor(@C * rand());
set @Y3 = floor(@C * rand());
select * from t limit @Y1，1； //在应用代码里面取Y1、Y2、Y3值，拼出SQL后执行
select * from t limit @Y2，1；
select * from t limit @Y3，1；
```



## 小结

今天这篇文章，我是借着随机排序的需求，跟你介绍了MySQL对临时表排序的执行过程。

如果你直接使用order by rand()，这个语句需要Using temporary和 Using filesort，查询的执行代 价往往是比较大的。所以，在设计的时候你要量避开这种写法。

今天的例子里面，我们不是仅仅在数据库内部解决问题，还会让应用代码配合拼接SQL语句。在 实际应用的过程中，比较规范的用法就是：尽量将业务逻辑写在业务代码中，让数据库只做“读 写数据”的事情。因此，这类方法的应用还是比较广泛的。



### 思考题

上面的随机算法3的总扫描行数是 C+(Y1+1)+(Y2+1)+(Y3+1)，实际上它还是可以继续优化，来 进一步减少扫描行数的。

我的问题是，如果你是这个需求的开发人员，你会怎么做，来减少扫描行数呢？说说你的方案， 并说明你的方案需要的扫描行数。

> 回答

我在上篇文章的最后，留给你的问题是：我们文章中最后的一个方案是，通过三次limit Y,1 来得 alter table trade_detail modify tradeid varchar(32) CHARACTER SET utf8mb4 default null; mysql> select d.* from tradelog l , trade_detail d where d.tradeid=CONVERT(l.tradeid USING utf8) and l.id=2; 到需要的数据，你觉得有没有进一步的优化方法。

这里我给出一种方法，取Y1、Y2和Y3里面最大的一个数，记为M，最小的一个数记为N，然后 执行下面这条SQL语句：

```sql
mysql> select * from t limit N, M-N+1
```

再加上取整个表总行数的C行，这个方案的扫描行数总共只需要C+M+1行。 当然也可以先取回id值，在应用中确定了三个id值以后，再执行三次where id=X的语句也是可以 的。@倪大人 同学在评论区就提到了这个方法。

> 精選評論

@老杨同志 提出了重新整理的方法、@雪中鼠[悠闲] 提到了用rowid的方法，是类似的思路， 就是让表里面保存一个无空洞的自增值，这样就可以用我们的随机算法1来实现；

@吴宇晨 提到了拿到第一个值以后，用id迭代往下找的方案，利用了主键索引的有序性。





# 18 | 为什么这些SQL语句逻辑相同，性能却差异巨大？

在MySQL中，有很多看上去逻辑相同，但性能却差异巨大的SQL语句。对这些语句使用不当的 话，就会不经意间导致整个数据库的压力变大。

我今天挑选了三个这样的案例和你分享。希望再遇到相似的问题时，你可以做到举一反三、快速 解决问题。



## 案例一：条件字段函数操作

假设你现在维护了一个交易系统，其中交易记录表tradelog包含交易流水号（tradeid）、交易员 id（operator）、交易时间（t_modified）等字段。为了便于描述，我们先忽略其他字段。这个 表的建表语句如下：

```sql
mysql> CREATE TABLE `tradelog` (
    `id` int(11) NOTNULL,
    `tradeid` varchar(32) DEFAULTNULL,
    `operator` int(11) DEFAULTNULL,
    `t_modified` datetime DEFAULTNULL,
    PRIMARY KEY (`id`),
    KEY `tradeid` (`tradeid`),
    KEY `t_modified` (`t_modified`)
) ENGINE=InnoDB DEFAULTCHARSET=utf8mb4;

```

假设，现在已经记录了从2016年初到2018年底的所有数据，运营部门有一个需求是，要统计发 生在所有年份中7月份的交易记录总数。这个逻辑看上去并不复杂，你的SQL语句可能会这么写：

```
mysql> select count(*) from tradelog where month(t_modified)=7;
```

由于t_modified字段上有索引，于是你就很放心地在生产库中执行了这条语句，但却发现执行了 特别久，才返回了结果。

**如果你问DBA同事为什么会出现这样的情况，他大概会告诉你：如果对字段做了函数计算，就 用不上索引了，这是MySQL的规定**。

现在你已经学过了InnoDB的索引结构了，可以再追问一句为什么？为什么条件是where t_modified='2018-7-1’的时候可以用上索引，而改成where month(t_modified)=7的时候就不行 了？

下面是这个t_modified索引的示意图。方框上面的数字就是month()函数对应的值。

<img src="MYSQL实战45讲.assets/image-20250218202244731.png" alt="image-20250218202244731" style="zoom:50%;" />





如果你的SQL语句条件用的是where t_modified='2018-7-1’的话，引擎就会按照上面绿色箭头的路线，快速定位到 t_modified='2018-7-1’需要的结果。

实际上，B+树提供的这个快速定位能力，来源于同一层兄弟节点的有序性。

但是，如果计算month()函数的话，你会看到传入7的时候，在树的第一层就不知道该怎么办了。

也就是说，对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃 走树搜索功能。

需要注意的是，优化器并不是要放弃使用这个索引。



在这个例子里，放弃了树搜索功能，优化器可以选择遍历主键索引，也可以选择遍历索引 t_modified，优化器对比索引大小后发现，索引t_modified更小，遍历这个索引比遍历主键索引 来得更快。因此最终还是会选择索引t_modified。

接下来，我们使用explain命令，查看一下这条SQL语句的执行结果：

<img src="MYSQL实战45讲.assets/image-20250218202443435.png" alt="image-20250218202443435" style="zoom: 67%;" />

key="t_modified"表示的是，使用了t_modified这个索引；我在测试表数据中插入了10万行数 据，rows=100335，说明这条语句扫描了整个索引的所有值；Extra字段的**Using index，表示的 是使用了覆盖索引**。



也就是说，由于在t_modified字段加了month()函数操作，导致了全索引扫描。为了能够用上索引 的快速定位能力，我们就要把SQL语句改成基于字段本身的范围查询。

```sql
mysql> select count(*) from tradelog where
    -> (t_modified >= '2016-7-1' and t_modified<'2016-8-1') or
    -> (t_modified >= '2017-7-1' and t_modified<'2017-8-1') or
    -> (t_modified >= '2018-7-1' and t_modified<'2018-8-1');
```

当然，如果你的系统上线时间更早，或者后面又插入了之后年份的数据的话，你就需要再把其他 年份补齐。

到这里我给你说明了，由于加了month()函数操作，MySQL无法再使用索引快速定位功能，而只 能使用全索引扫描。



不过优化器在个问题上确实有“偷懒”行为，即使是对于不改变有序性的函数，也不会考虑使用索 引。比如，对于select *fromtradelog where id + 1 = 10000这个SQL语句，这个加1操作并不会 改变有序性，但是MySQL优化器还是不能用id索引快速定位到9999这一行。所以，需要你在写 SQL语句的时候，手动改写成 where id = 10000 -1才可以。



## 案例二：隐式类型转换

接下来我再跟你说一说，另一个经常让程序员掉坑里的例子。

我们一起看一下这条SQL语句：

```sql
mysql> select * from tradelog where tradeid=110717;
```

交易编号tradeid这个字段上，本来就有索引，但是explain的结果却显示，这条语句需要走全表 扫描。你可能也发现了，**tradeid的字段类型是varchar(32)**，而输入的参数却是整型，所以需要做 类型转换。



那么，现在这里就有两个问题：

1. 数据类型转换的规则是什么？ 
2. 为什么有数据类型转换，就需要走全索引扫描？

先来看第一个问题，你可能会说，数据库里面类型这么多，这种数据类型转换规则更多，我记不 住，应该怎么办呢？

这里有一个简单的方法，看 select “10” > 9的结果：

1. 如果规则是“将字符串转成数字”，那么就是做数字比较，结果应该是1； √
2. 如果规则是“将数字转成字符串”，那么就是做字符串比较，结果应该是0。 

验证结果如图3所示。

<img src="MYSQL实战45讲.assets/image-20250218203104541.png" alt="image-20250218203104541" style="zoom: 67%;" />



从图中可知，select “10” > 9返回的是1，所以你就能确认MySQL里的转换规则了：在MySQL 中，字符串和数字做比较的话，是将字符串转换成数字。



这时，你再看这个全表扫描的语句：

```sql
mysql> select * from tradelog where tradeid=110717;
```

就知道对于优化器来说，这个语句相当于 `CAST(tradidAS signed int)`：

```sql
mysql> select * from tradelog where CAST(tradidAS signed int) = 110717;
```

也就是说，这条语句触发了我们上面说到的规则：对索引字段做函数操作，优化器会放弃走树搜 索功能。

现在，我留给你一个小问题，id的类型是int，如果执行下面这个语句，是否会导致全表扫描呢？(==>应该不会)

```sql
select * from tradelog where id="83126"
```

你可以先自己分析一下，再到数据库里面去验证确认。 

接下来，我们再来看一个稍微复杂点的例子。



## 案例三：隐式字符编码转换

假设系统里还有另外一个表trade_detail，用于记录交易的操作细节。为了便于量化分析和复 现，我往交易日志表tradelog和交易详情表trade_detail这两个表里插入一些数据。

```sql
mysql> CREATE TABLE `trade_detail` (
    `id` int(11) NOTNULL,
    `tradeid` varchar(32) DEFAULTNULL,
    `trade_step` int(11) DEFAULTNULL, /*操作步骤*/
    `step_info` varchar(32) DEFAULTNULL, /*步骤信息*/
    PRIMARY KEY (`id`),
    KEY `tradeid` (`tradeid`)
) ENGINE=InnoDB DEFAULTCHARSET=utf8;
insert into tradelog values(1, 'aaaaaaaa', 1000, now());
insert into tradelog values(2, 'aaaaaaab', 1000, now());
insert into tradelog values(3, 'aaaaaaac', 1000, now());
insert into trade_detail values(1, 'aaaaaaaa', 1, 'add');
insert into trade_detail values(2, 'aaaaaaaa', 2, 'update');
insert into trade_detail values(3, 'aaaaaaaa', 3, 'commit');
insert into trade_detail values(4, 'aaaaaaab', 1, 'add');
insert into trade_detail values(5, 'aaaaaaab', 2, 'update');
insert into trade_detail values(6, 'aaaaaaab', 3, 'update again');
insert into trade_detail values(7, 'aaaaaaab', 4, 'commit');
insert into trade_detail values(8, 'aaaaaaac', 1, 'add');
insert into trade_detail values(9, 'aaaaaaac', 2, 'update');
insert into trade_detail values(10, 'aaaaaaac', 3, 'update again');
insert into trade_detail values(11, 'aaaaaaac', 4, 'commit');
```

这时候，如果要查询id=2的交易的所有操作步骤信息，SQL语句可以这么写：

```sql
mysql> select d.* from tradelog l, trade_detail d where d.tradeid=l.tradeid and l.id=2; /*语句Q1*/
```

<img src="MYSQL实战45讲.assets/image-20250218203549761.png" alt="image-20250218203549761" style="zoom: 67%;" />



我们一起来看下这个结果： 

1. 第一行显示优化器会先在交易记录表tradelog上查到id=2的行，这个步骤用上了主键索引，rows=1表示只扫描一行； 
2. 第二行key=NULL，表示没有用上交易详情表trade_detail上的tradeid索引，进行了全表扫 描。

在这个执行计划里，是从tradelog表中取tradeid字段，再去trade_detail表里查询匹配字段。因 此，我们把tradelog称为**驱动表**，把trade_detail称为被驱动表，把tradeid称为关联字段。



接下来，我们看下这个explain结果表示的执行流程：

<img src="MYSQL实战45讲.assets/image-20250218203737682.png" alt="image-20250218203737682" style="zoom:50%;" />



图中：

- 第1步，是根据id在tradelog表里找到L2这一行；
- 第2步，是从L2中取出tradeid字段的值； 
- 第3步，是根据tradeid值到trade_detail表中查找条件匹配的行。**explain的结果里面第二行的 key=NULL表示的就是，这个过程是通过遍历主键索引的方式**，一个一个地判断tradeid的值是 否匹配。

进行到这里，你会发现第3步不符合我们的预期。因为表trade_detail里tradeid字段上是有索引 的，我们本来是希望通过使用tradeid索引能够快速定位到等值的行。但，这里并没有。

如果你去问DBA同学，他们可能会告诉你，**因为这两个表的字符集不同，一个是utf8，一个是 utf8mb4**，所以做表连接查询的时候用不上关联字段的索引。这个回答，也是通常你搜索这个问 题时会得到的答案。



但是你应该再追问一下，为什么字符集不同就用不上索引呢？

我们说问题是出在执行步骤的第3步，如果单独把这一步改成SQL语句的话，那就是：

```
mysql> select * from trade_detail where tradeid=$L2.tradeid.value;
```

其中，$L2.tradeid.value的字符集是utf8mb4。

参照前面的两个例子，你肯定就想到了，字符集utf8mb4是utf8的超集，所以当这两个类型的字 符串在做比较的时候，MySQL内部的操作是，先把utf8字符串转成utf8mb4字符集，再做比较。

> 这个设定很好理解，utf8mb4是utf8的超集。类似地，在程序设计语言里面，做自动类型转换 的时候，为了避免数据在转换过程中由于截断导致数据错误，也都是“按数据长度增加的方 向”进行转换的。

因此， 在执行上面这个语句的时候，需要将被驱动数据表里的字段一个个地转换成utf8mb4，再 跟L2做比较。

也就是说，实际上这个语句等同于下面这个写法：

```sql
select * from trade_detail where CONVERT(traideid USING utf8mb4)=$L2.tradeid.value;
```

CONVERT()函数，在这里的意思是把输入的字符串转成utf8mb4字符集。 

这就再次触发了我们上面说到的原则：对索引字段做函数操作，优化器会放弃走树搜索功能。

到这里，你终于明确了，**字符集不同只是条件之一，连接过程中要求在被驱动表的索引字段 上加函数操作，是直接导致对被驱动表做全表扫描的原因**。



作为对比验证，我给你提另外一个需求，“查找trade_detail表里id=4的操作，对应的操作者是 谁”，再来看下这个语句和它的执行计划。

```sql
mysql>select l.operator from tradelog l , trade_detail d where d.tradeid=l.tradeid and d.id=4;
```

<img src="MYSQL实战45讲.assets/image-20250218204152620.png" alt="image-20250218204152620" style="zoom: 67%;" />



这个语句里trade_detail 表成了驱动表，但是explain结果的第二行显示，这次的查询操作用上了 被驱动表tradelog里的索引(tradeid)，扫描行数是1。

这也是两个tradeid字段的join操作，为什么这次能用上被驱动表的tradeid索引呢？我们来分析一 下。



假设驱动表trade_detail里id=4的行记为R4，那么在连接的时候（图5的第3步），被驱动表 tradelog上执行的就是类似这样的SQL语句：

```
select operator from tradelog where traideid =$R4.tradeid.value;
```

这时候$R4.tradeid.value的字符集是utf8, 按照字符集转换规则，要转成utf8mb4，所以这个过程 就被改写成：

```
select operator from tradelog where traideid =CONVERT($R4.tradeid.value USING utf8mb4);
```

你看，这里的CONVERT函数是加在输入参数上的，这样就可以用上被驱动表的traideid索引。 理解了原理以后，就可以用来指导操作了。如果要优化语句的执行过程，有两种做法：

```
select d.* from tradelog l, trade_detail d where d.tradeid=l.tradeid and l.id=2;
```

1、比较常见的优化方法是，把trade_detail表上的tradeid字段的字符集也改成utf8mb4，`CHARACTER SET utf8mb4`这样就 没有字符集转换的问题了。

```
alter table trade_detail modify tradeid varchar(32) CHARACTER SET utf8mb4 default null;
```



2、如果能够修改字段的字符集的话，是最好不过了。但如果数据量比较大， 或者业务上暂时不 能做这个DDL的话，那就只能采用修改SQL语句的方法了。

```sql
mysql> select d.* from tradelog l , trade_detail d where d.tradeid=CONVERT(l.tradeid USING utf8) and l.id=2;
```

<img src="MYSQL实战45讲.assets/image-20250219111146043.png" alt="image-20250219111146043" style="zoom:67%;" />



这里，我主动把 l.tradeid转成utf8，就避免了被驱动表上的字符编码转换，从explain结果可以看 到，这次索引走对了。



## 小结

今天我给你举了三个例子，其实是在说同一件事儿，即：**对索引字段做函数操作，可能会破坏 索引值的有序性**，因此优化器就决定放弃走树搜索功能。

第二个例子是隐式类型转换，第三个例子是隐式字符编码转换，它们都跟第一个例子一样，因为 要求在索引字段上做函数操作而导致了全索引扫描。

MySQL的优化器确实有“偷懒”的嫌疑，即使简单地把where id+1=1000改写成where id=1000-1就 能够用上索引快速查找，也不会主动做这个语句重写。

因此，每次你的业务代码升级时，把可能出现的、新的SQL语句explain一下，是一个很好的习 惯。



### 思考题

今天我留给你的课后问题是，你遇到过别的、类似今天我们提到的性能问题吗？你认为原因是什 么，又是怎么解决的呢？

> 回答

在上一篇文章最后，我留给你的问题是，希望你可以分享一下之前碰到过的、与文章中类似的场 景。 @封建的风 提到一个有趣的场景，值得一说。我把他的问题重写一下，表结构如下：

```sql
mysql> CREATE TABLE `table_a` (
    `id` int(11) NOTNULL,
    `b` varchar(10) DEFAULTNULL,
    PRIMARY KEY (`id`),
    KEY `b` (`b`)
) ENGINE=InnoDB;
```

假设现在表里面，有100万行数据，其中有10万行数据的b的值是’1234567890’， 假设现在执行语句是这么写的:

```
mysql> select * from table_a where b='1234567890abcd';
```

这时候，MySQL会怎么执行呢？

最理想的情况是，MySQL看到字段b定义的是varchar(10)，那肯定返回空呀。可惜，MySQL并没 有这么做。

那要不，就是把’1234567890abcd’拿到索引里面去做匹配，肯定也没能够快速判断出索引树b上 并没有这个值，也很快就能返回空结果。

但实际上，MySQL也不是这么做的。 这条SQL语句的执行很慢，流程是这样的：

1. 在传给**引擎**执行的时候，做了字符截断。因为引擎里面这个行只定义了长度是10，所以只截 了前10个字节，就是’1234567890’进去做匹配； 
2. 这样满足条件的数据有10万行； 
3. 因为是select *， 所以要做10万次回表；
4. 但是每次回表以后查出整行，到server层一判断，b的值都不是’1234567890abcd’;
5. 返回结果是空。

这个例子，是我们文章内容的一个很好的补充。虽然执行过程中可能经过函数操作，但是最终在 拿到结果后，server层还是要做一轮判断的。

评论区留言点赞板：

>  @赖阿甘 提到了等号顺序问题，时间上MySQL优化器执行过程中，where 条件部分， a=b和 b=a的写法是一样的。
>
> @沙漠里的骆驼 提到了一个常见的问题。相同的模板语句，但是匹配行数不同，语句执行时 间相差很大。这种情况，在语句里面有order by这样的操作时会更明显。
>
> @Justin 回答了我们正文中的问题，如果id 的类型是整数，传入的参数类型是字符串的时候， 可以用上索引





# 19 | 为什么我只查一行的语句，也执行这么慢？

一般情况下，如果我跟你说查询性能优化，你首先会想到一些复杂的语句，想到查询需要返回大 量的数据。但有些情况下，“查一行”，也会执行得特别慢。今天，我就跟你聊聊这个有趣的话 题，看看什么情况下，会出现这个现象。



需要说明的是，如果MySQL数据库本身就有很大的压力，导致数据库服务器CPU占用率很高或 ioutil（IO利用率）很高，这种情况下所有语句的执行都有可能变慢，不属于我们今天的讨论范 围。



为了便于描述，我还是构造一个表，基于这个表来说明今天的问题。这个表有两个字段id和c， 并且我在里面插入了10万行记录。

```sql
mysql> CREATE TABLE `t` (
    `id` int(11) NOTNULL,
    `c` int(11) DEFAULTNULL,
    PRIMARY KEY (`id`)
) ENGINE=InnoDB;


delimiter ;;
create procedure idata()
begin
    declare i int;
    set i=1;
    while(i<=100000)do
        insert into t values(i,i);
        set i=i+1;
    end while;
end;;
delimiter ;
call idata();
```

> 补充：

1. 查看所有存储过程：

```
SHOW PROCEDURE STATUS;
```

这将显示数据库中所有存储过程的信息，包括名称、创建时间等。

1. 查看特定存储过程的定义：

```
SHOW CREATE PROCEDURE procedure_name;
```

将 `procedure_name` 替换为要查看的存储过程的名称。这将显示指定存储过程的完整定义。

1. 删除存储过程：

```
DROP PROCEDURE IF EXISTS procedure_name;
```



接下来，我会用几个不同的场景来举例，有些是前面的文章中我们已经介绍过的知识点，你看看 能不能一眼看穿，来检验一下吧。



## 第一类：查询长时间不返回

如图1所示，在表t执行下面的SQL语句：

```
mysql> select * from t where id=1;

```

查询结果长时间不返回。

<img src="MYSQL实战45讲.assets/image-20250219113617178.png" alt="image-20250219113617178" style="zoom:50%;" />

一般碰到这种情况的话，大概率是表t被锁住了。接下来分析原因的时候，一般都是首先执行一 下`show processlist`命令，看看当前语句处于什么状态。

然后我们再针对每种状态，去分析它们产生的原因、如何复现，以及如何处理。



### 等MDL锁

如图2所示，就是使用showprocesslist命令查看Waiting for table metadata lock的示意图。

<img src="MYSQL实战45讲.assets/image-20250219113745848.png" alt="image-20250219113745848" style="zoom:50%;" />

出现这个状态表示的是，现在有一个线程正在表t上请求或者持有MDL写锁，把select语句堵住了。

在第6篇文章《全局锁和表锁 ：给表加个字段怎么有这么多阻碍？》中，我给你介绍过一种复现方法。但需要说明的是，那个复现过程是基于MySQL 5.6版本的。而MySQL 5.7版本修改了MDL 的加锁策略，所以就不能复现这个场景了。

不过，在MySQL 5.7版本下复现这个场景，也很容易。如图3所示，我给出了简单的复现步骤。

```sql
lock table t write;

==>
UNLOCK TABLES; //释放所有锁定的表
```

<img src="MYSQL实战45讲.assets/image-20250219113936727.png" alt="image-20250219113936727" style="zoom:50%;" />

session A 通过lock table命令持有表t的MDL写锁，而session B的查询需要获取MDL读锁。所 以，session B进入等待状态。

这类问题的处理方式，就是找到谁持有MDL写锁，然后把它kill掉。

但是，由于在showprocesslist的结果里面，session A的Command列是“Sleep”，导致查找起来 很不方便。不过有了performance_schema和sys系统库以后，就方便多了。（MySQL启动时需 要设置performance_schema=on，相比于设置为off会有10%左右的性能损失)。

通过查询sys.schema_table_lock_waits这张表，我们就可以直接找出造成阻塞的process id，把 这个连接用kill 命令断开即可。

<img src="MYSQL实战45讲.assets/image-20250219114215096.png" alt="image-20250219114215096" style="zoom:67%;" />

```
select blocking_pid from sys.schema_table_lock_waits;
```



### 等flush

接下来，我给你举另外一种查询被堵住的情况。 我在表t上，执行下面的SQL语句：

```
mysql> select * from information_schema.processlist where id=1;
```

你可以看一下图5。我查出来这个线程的状态是Waiting for table flush，你可以设想一下这是什 么原因。

<img src="MYSQL实战45讲.assets/image-20250219120307433.png" alt="image-20250219120307433" style="zoom:67%;" />

这个状态表示的是，现在有一个线程正要对表t做flush操作。MySQL里面对表做flush操作的用 法，一般有以下两个：

```sql
flush tables t with read lock;
flush tables with read lock;
```

这两个flush语句，如果指定表t的话，代表的是只关闭表t；如果没有指定具体的表名，则表示关 闭MySQL里所有打开的表。

但是正常这两个语句执行起来都很快，除非它们也被别的线程堵住了。

所以，出现Waiting for table flush状态的可能情况是：有一个flush tables命令被别的语句堵住了，然后它又堵住了我们的select语句。

现在，我们一起来复现一下这种情况，复现步骤如图6所示：

<img src="MYSQL实战45讲.assets/image-20250219120508511.png" alt="image-20250219120508511" style="zoom:50%;" />



在session A中，我故意每行都调用一次sleep(1)，这样这个语句默认要执行10万秒（对10W条记录执行休眠1s），在这期间表 t一直是被session A“打开”着。然后，session B的flush tables t命令再要去关闭表t，就需要等 session A的查询结束。这样，session C要再次查询的话，就会被flush 命令堵住了。

图7是这个复现步骤的showprocesslist结果。这个例子的排查也很简单，你看到这个show processlist的结果，肯定就知道应该怎么做了。

<img src="MYSQL实战45讲.assets/image-20250219120728166.png" alt="image-20250219120728166" style="zoom:67%;" />

### 等行锁

现在，经过了表级锁的考验，我们的select 语句终于来到引擎里了。

```
mysql> select * from t where id=1 lock in share mode;
```

> 共享锁（Shared Lock）是一种读取锁，它允许多个会话同时获取共享锁并读取数据，但阻止其他会话对同一数据进行写操作。这意味着其他会话可以同时读取被共享锁保护的数据，但不能修改它。
>
> 在执行这个查询语句时，如果其他会话已经对满足条件的数据行持有排他锁（Exclusive Lock），那么当前会话将会等待，直到排他锁被释放。如果没有其他会话持有排他锁，当前会话将获取共享锁并读取数据。

上面这条语句的用法你也很熟悉了，我们在第8篇《事务到底是隔离的还是不隔离的？》文章介 绍当前读时提到过。 

由于访问id=1这个记录时要加读锁，如果这时候已经有一个事务在这行记录上持有一个写锁，我 们的select语句就会被堵住。

复现步骤和现场如下：

<img src="MYSQL实战45讲.assets/image-20250219121313178.png" alt="image-20250219121313178" style="zoom:50%;" />



<img src="MYSQL实战45讲.assets/image-20250219121513028.png" alt="image-20250219121513028" style="zoom: 67%;" />

显然，session A启动了事务，占有写锁，还不提交，是导致session B被堵住的原因。

这个问题并不难分析，但问题是怎么查出是谁占着这个写锁。如果你用的是MySQL 5.7版本，可 以通过sys.innodb_lock_waits 表查到。

```sql
mysql> select * from sys.innodb_lock_waits where locked_table='`test`.`t`'\G;
```

<img src="MYSQL实战45讲.assets/image-20250219121857983.png" alt="image-20250219121857983" style="zoom:50%;" />

可以看到，这个信息很全，4号线程是造成堵塞的罪魁祸首。而干掉这个罪魁祸首的方式，就是 KILLQUERY 4或KILL 4。

不过，这里不应该显示“KILLQUERY 4”。这个命令表示停止4号线程当前正在执行的语句，而这 个方法其实是没有用的。因为占有行锁的是update语句，这个语句已经是之前执行完成了的， 现在执行KILLQUERY，无法让这个事务去掉id=1上的行锁。



实际上，**KILL 4才有效**，也就是说直接断开这个连接。**这里隐含的一个逻辑就是，连接被断开的 时候，会自动回滚这个连接里面正在执行的线程，也就释放了id=1上的行锁**。



## 第二类：查询慢

经过了重重封“锁”，我们再来看看一些查询慢的例子。

先来看一条你一定知道原因的SQL语句：

```
select * from t where c=50000 limit 1;
```

由于字段c上没有索引，这个语句只能走id主键顺序扫描，因此需要扫描5万行。

作为确认，你可以看一下慢查询日志。注意，这里为了把所有语句记录到slowlog里，我在连接 后先执行了 set long_query_time=0，将慢查询日志的时间阈值设置为0。

<img src="MYSQL实战45讲.assets/image-20250219122119634.png" alt="image-20250219122119634" style="zoom:50%;" />



Rows_examined显示扫描了50000行。你可能会说，不是很慢呀，11.5毫秒就返回了，我们线上 一般都配置超过1秒才算慢查询。但你要记住：坏查询不一定是慢查询。我们这个例子里面只 有10万行记录，数据量大起来的话，执行时间就线性涨上去了。

扫描行数多，所以执行慢，这个很好理解。



但是接下来，我们再看一个只扫描一行，但是执行很慢的语句。

如图12所示，是这个例子的slowlog。可以看到，执行的语句是

```
mysql> select * from t where id=1；
```

虽然扫描行数是1，但执行时间却长达800毫秒。

<img src="MYSQL实战45讲.assets/image-20250219200808825.png" alt="image-20250219200808825" style="zoom:67%;" />

是不是有点奇怪呢，这些时间都花在哪里了？

如果我把这个slowlog的截图再往下拉一点，你可以看到下一个语句，select *fromt where id=1 lock in share mode，执行时扫描行数也是1行，执行时间是0.2毫秒。

<img src="MYSQL实战45讲.assets/image-20250219200849354.png" alt="image-20250219200849354" style="zoom:67%;" />

可能有的同学已经有答案了。如果你还没有答案的话，我再给你一个提示信息，图14是这两个语句的执行输出结果。

<img src="MYSQL实战45讲.assets/image-20250219200929025.png" alt="image-20250219200929025" style="zoom:50%;" />



第一个语句的查询结果里c=1，带lock in share mode的语句返回的是c=1000001。看到这里应该 有更多的同学知道原因了。如果你还是没有头绪的话，也别着急。我先跟你说明一下复现步骤， 再分析原因。

<img src="MYSQL实战45讲.assets/image-20250219200959322.png" alt="image-20250219200959322" style="zoom:50%;" />

你看到了，session A先用start transaction with consistent snapshot命令启动了一个事务，之后 session B才开始执行update 语句。

session B执行完100万次update语句后，id=1这一行处于什么状态呢？你可以从图16中找到答案。

<img src="MYSQL实战45讲.assets/image-20250219201035004.png" alt="image-20250219201035004" style="zoom:50%;" />

session B更新完100万次，生成了100万个回滚日志(undo log)。

带lock in share mode的SQL语句，是当前读，因此会直接读到1000001这个结果，所以速度很快；而select *fromt where id=1这个语句，是一致性读，因此需要从1000001开始，依次执行 undo log，执行了100万次以后，才将1这个结果返回。

注意，undo log里记录的其实是“把2改成1”，“把3改成2”这样的操作逻辑，画成减1的目的是方便你看图。



## 小结

今天我给你举了在一个简单的表上，执行“查一行”，可能会出现的被锁住和执行慢的例子。这其 中涉及到了表锁、行锁和一致性读的概念。

在实际使用中，碰到的场景会更复杂。但大同小异，你可以按照我在文章中介绍的定位方法，来定位并解决问题。



### 思考题

我们在举例加锁读的时候，用的是这个语句，select *fromt where id=1 lock in share mode。由于id上有索引，所以可以直接定位到id=1这一行，因此读锁也是只加在了这一行上。

但如果是下面的SQL语句，

```sql
begin;
select * from t where c=5 for update;
commit;
```

这个语句序列是怎么加锁的呢？加的锁又是什么时候释放呢？

> 回答

在21的开头回答了这期问题。有同学的回答中还说明了读提交隔离级别下，在语句执行完 成后，是只有行锁的。而且语句执行完成后，InnoDB就会把不满足条件的行行锁去掉。

当然了，c=5这一行的行锁，还是会等到commit的时候才释放的。



# 20 | 幻读是什么，幻读有什么问题？

在上一篇文章最后，我给你留了一个关于加锁规则的问题。今天，我们就从这个问题说起吧。

为了便于说明问题，这一篇文章，我们就先使用一个小一点儿的表。建表和初始化语句如下（为 了便于本期的例子说明，我把上篇文章中用到的表结构做了点儿修改）：

```sql
CREATE TABLE `t` (
    `id` int(11) NOTNULL,
    `c` int(11) DEFAULTNULL,
    `d` int(11) DEFAULTNULL,
    PRIMARY KEY (`id`),
    KEY `c` (`c`)
) ENGINE=InnoDB;
insert into t values(0,0,0),(5,5,5),
(10,10,10),(15,15,15),(20,20,20),(25,25,25);

```

这个表除了主键id外，还有一个索引c，初始化语句在表中插入了6行数据。

上期我留给你的问题是，下面的语句序列，是怎么加锁的，加的锁又是什么时候释放的呢？

```sql
begin;
select * from t where d=5 for update;
commit;
```



比较好理解的是，这个语句会命中d=5的这一行，对应的主键id=5，因此**在select 语句执行完成 后，id=5这一行会加一个写锁**，而且由于两阶段锁协议，这个写锁会在执行commit语句的时候释放。

**由于字段d上没有索引，因此这条查询语句会做全表扫描。那么，其他被扫描到的，但是不满足条件的5行记录上，会不会被加锁呢**？ (会)

我们知道，InnoDB的默认事务隔离级别是可重复读，所以本文接下来没有特殊说明的部分，都是设定在可重复读隔离级别下。



## 幻读是什么？

现在，我们就来分析一下，如果只在id=5这一行加锁，而其他行的不加锁的话，会怎么样。

下面先来看一下这个场景（注意：这是我假设的一个场景）：

<img src="MYSQL实战45讲.assets/image-20250220174045136.png" alt="image-20250220174045136" style="zoom:50%;" />

可以看到，session A里执行了三次查询，分别是Q1、Q2和Q3。它们的SQL语句相同，都是 select *fromt where d=5 for update。这个语句的意思你应该很清楚了，**查所有d=5的行，而且使用的是当前读，并且加上写锁**。

现在，我们来看一下这三条SQL语句，分别会返回什么结果。

1. Q1只返回id=5这一行；
2. 在T2时刻，session B把id=0这一行的d值改成了5，因此T3时刻Q2查出来的是id=0和id=5这 两行；
3. 在T4时刻，session C又插入一行（1,1,5），因此T5时刻Q3查出来的是id=0、id=1和id=5的 这三行。

其中，Q3读到id=1这一行的现象，被称为“幻读”。也就是说，**幻读指的是一个事务在前后两次查 询同一个范围的时候，后一次查询看到了前一次查询没有看到的行**。

这里，我需要对“幻读”做一个说明：

1. 在可重复读隔离级别下，普通的查询是**快照读**，是不会看到别的事务插入的数据的。因此， 幻读在“**当前读**”下才会出现。
2. 上面session B的修改结果，被session A之后的select语句用“当前读”看到，不能称为幻读。 幻读仅专指“新插入的行”。

如果只从第8篇文章《事务到底是隔离的还是不隔离的？》我们学到的事务可见性规则来分析的 话，上面这三条SQL语句的返回结果都没有问题。

因为这三个查询都是加了for update，都是当前读。而当前读的规则，就是要能读到所有已经提 交的记录的最新值。并且，session B和sessionC的两条语句，执行后就会提交，所以Q2和Q3就 是应该看到这两个事务的操作效果，而且也看到了，这跟事务的可见性规则并不矛盾。



但是，这是不是真的没问题呢？

不，这里还真就有问题。



## 幻读有什么问题？

**首先是语义上的**。session A在T1时刻就声明了，“我要把所有d=5的行锁住，不准别的事务进行读写操作”。而实际上，这个语义**被破坏了**。

如果现在这样看感觉还不明显的话，我再往session B和session C里面分别加一条SQL语句，你 再看看会出现什么现象。

<img src="MYSQL实战45讲.assets/image-20250220174522286.png" alt="image-20250220174522286" style="zoom:50%;" />

session B的第二条语句update t set c=5 where id=0，语义是“我把id=0、d=5这一行的c值，改成 了5”。

由于在T1时刻，session A 还只是给id=5这一行加了行锁， 并没有给id=0这行加上锁。因 此，session B在T2时刻，是可以执行这两条update语句的。这样，就破坏了 session A 里Q1语 句要锁住所有d=5的行的加锁声明。

session C也是一样的道理，对id=1这一行的修改，也是破坏了Q1的加锁声明。



**其次，是数据一致性的问题。**

我们知道，锁的设计是为了保证数据的一致性。而这个一致性，不止是数据库内部数据状态在此 刻的一致性，还包含了数据和日志在逻辑上的一致性。

为了说明这个问题，我给session A在T1时刻再加一个更新语句，即：update t set d=100 where d=5;

<img src="MYSQL实战45讲.assets/image-20250220174733761.png" alt="image-20250220174733761" style="zoom:50%;" />



update的加锁语义和select …for update 是一致的，所以这时候加上这条update语句也很合理。 session A声明说“要给d=5的语句加上锁”，就是为了要更新数据，新加的这条update语句就是把 它认为加上了锁的这一行的d值修改成了100。

现在，我们来分析一下图3执行完成后，数据库里会是什么结果。

1. 经过T1时刻，id=5这一行变成 (5,5,100)，当然这个结果最终是在T6时刻正式提交的; 
2. 经过T2时刻，id=0这一行变成(0,5,5); 
3. 经过T4时刻，表里面多了一行(1,5,5); 
4. 其他行跟这个执行序列无关，保持不变。

这样看，这些数据也没啥问题，但是我们再来看看这时候binlog里面的内容。

1. T2时刻，session B事务提交，写入了两条语句； 
2. T4时刻，session C事务提交，写入了两条语句； 
3. T6时刻，session A事务提交，写入了update t set d=100 where d=5 这条语句。

我统一放到一起的话，就是这样的:

```sql
update t set d=5 where id=0; /*(0,0,5)*/
update t set c=5 where id=0; /*(0,5,5)*/
insert into t values(1,1,5); /*(1,1,5)*/
update t set c=5 where id=1; /*(1,5,5)*/
update t set d=100 where d=5;/*所有d=5的行，d改成100*/
```

好，你应该看出问题了。这个语句序列，不论是拿到备库去执行，还是以后用binlog来克隆一个 库，这三行的结果，都变成了 (0,5,100)、(1,5,100)和(5,5,100)。

也就是说，id=0和id=1这两行，发生了数据不一致。这个问题很严重，是不行的。

到这里，我们再回顾一下，这个数据不一致到底是怎么引入的？

我们分析一下可以知道，这是我们假设“select *fromt where d=5 for update这条语句只给d=5这 一行，也就是id=5的这一行加锁”导致的。



所以我们认为，上面的设定不合理，要改。

那怎么改呢？**我们把扫描过程中碰到的行，也都加上写锁，再来看看执行效果**。

<img src="MYSQL实战45讲.assets/image-20250220175112998.png" alt="image-20250220175112998" style="zoom:50%;" />

由于session A把所有的行都加了写锁，所以session B在执行第一个update语句的时候就被锁住 了。需要等到T6时刻session A提交以后，session B才能继续执行。

这样对于id=0这一行，在数据库里的最终结果还是 (0,5,5)。在binlog里面，执行序列是这样的：

```sql
insert into t values(1,1,5); /*(1,1,5)*/
update t set c=5 where id=1; /*(1,5,5)*/

update t set d=100 where d=5;/*所有d=5的行，d改成100*/

update t set d=5 where id=0; /*(0,0,5)*/
update t set c=5 where id=0; /*(0,5,5)*/
```

可以看到，按照日志顺序执行，id=0这一行的最终结果也是(0,5,5)。所以，id=0这一行的问题解 决了。

但同时你也可以看到，id=1这一行，在数据库里面的结果是(1,5,5)，而根据binlog的执行结果是 (1,5,100)，也就是说幻读的问题还是没有解决。为什么我们已经这么“凶残”地，把所有的记录都 上了锁，还是阻止不了id=1这一行的插入和更新呢？

**原因很简单。在T3时刻，我们给所有行加锁的时候，id=1这一行还不存在，不存在也就加不上锁**。



也就是说，即使把所有的记录都加上锁，还是阻止不了新插入的记录，这也是为什么“幻 读”会被单独拿出来解决的原因。



到这里，其实我们刚说明完文章的标题 ：幻读的定义和幻读有什么问题。

接下来，我们再看看InnoDB怎么解决幻读的问题。



## 如何解决幻读？

现在你知道了，产生幻读的原因是，行锁只能锁住行，但是新插入记录这个动作，要更新的是记 录之间的“间隙”。因此，为了解决幻读问题，InnoDB只好引入新的锁，也就是**间隙锁(Gap Lock)**。



顾名思义，间隙锁，锁的就是两个值之间的空隙。比如文章开头的表t，初始化插入了6个记录， 这就产生了7个间隙。

<img src="MYSQL实战45讲.assets/image-20250220175517126.png" alt="image-20250220175517126" style="zoom:50%;" />

这样，当你执行 select *fromt where d=5 for update的时候，就不止是给数据库中已有的6个记 录加上了行锁，还同时加了7个间隙锁。这样就确保了无法再插入新的记录。



也就是说这时候，在一行行扫描的过程中，不仅将给行加上了行锁，还给行两边的空隙，也加上 了间隙锁。



现在你知道了，数据行是可以加上锁的实体，数据行之间的间隙，也是可以加上锁的实体。但是 间隙锁跟我们之前碰到过的锁都不太一样。



比如行锁，分成读锁和写锁。下图就是这两种类型行锁的冲突关系。



<img src="MYSQL实战45讲.assets/image-20250220175609394.png" alt="image-20250220175609394" style="zoom:50%;" />



也就是说，跟行锁有冲突关系的是“另外一个行锁”。

但是间隙锁不一样，跟间隙锁存在冲突关系的，是“往这个间隙中插入一个记录”这个操 作。间隙锁之间都不存在冲突关系。



这句话不太好理解，我给你举个例子：

<img src="MYSQL实战45讲.assets/image-20250220175712674.png" alt="image-20250220175712674" style="zoom:50%;" />

这里session B并不会被堵住。因为表t里并没有c=7这个记录，因此session A加的是间隙锁 (5,10)。而session B也是在这个间隙加的间隙锁。它们有共同的目标，即：保护这个间隙，不允 许插入值。但，它们之间是不冲突的。



**间隙锁和行锁合称next-key lock，每个next-key lock是前开后闭区间。**也就是说，我们的表t初始 化以后，如果用select * from t for update要把整个表所有记录锁起来，就形成了7个next-key lock，分别是 (-∞,0]、(0,5]、(5,10]、(10,15]、(15,20]、(20, 25]、(25, +supremum]。

> 备注：这篇文章中，如果没有特别说明，我们把间隙锁记为开区间，把next-key lock记为前开 后闭区间。

你可能会问说，这个supremum从哪儿来的呢？ 这是因为+∞是开区间。实现上，InnoDB给每个索引加了一个不存在的最大值supremum，这样 才符合我们前面说的“都是前开后闭区间”。



**间隙锁和next-key lock的引入，帮我们解决了幻读的问题，但同时也带来了一些“困扰”**。



在前面的文章中，就有同学提到了这个问题。我把他的问题转述一下，对应到我们这个例子的表 来说，业务逻辑这样的：任意锁住一行，如果这一行不存在的话就插入，如果存在这一行就更新它的数据，代码如下：

```sql
begin;
select * from t where id=N for update;

/*如果行不存在*/
insert into t values(N,N,N);

/*如果行存在*/
update t set d=N set id=N;

commit
```

可能你会说，这个不是insert …on duplicate key update 就能解决吗？但其实在有多个唯一键的时 候，这个方法是不能满足这位提问同学的需求的。至于为什么，我会在后面的文章中再展开说明。

现在，我们就只讨论这个逻辑。 这个同学碰到的现象是，这个逻辑一旦有并发，就会碰到死锁。你一定也觉得奇怪，这个逻辑每次操作前用for update锁起来，已经是最严格的模式了，怎么还会有死锁呢？



> 注：ON DUPLICATE KEY UPDATE
>
> 在这个语法中，您需要指定要插入的表名、列名和对应的值。如果插入的数据导致了唯一键（UNIQUE KEY）或主键（PRIMARY KEY）的冲突，即已经存在具有相同键值的记录，那么将执行 `UPDATE` 部分的操作，更新已存在的记录。

```sql
INSERT INTO table_name (column1, column2, ...)
VALUES (value1, value2, ...)
ON DUPLICATE KEY UPDATE column1 = value1, column2 = value2, ...;

==> 例子
INSERT INTO users (id, name, age)
VALUES (1, 'John', 25)
ON DUPLICATE KEY UPDATE name = VALUES(name), age = age + 1;
```



这里，我用两个session来模拟并发，并假设N=9。

<img src="MYSQL实战45讲.assets/image-20250220180806342.png" alt="image-20250220180806342" style="zoom:50%;" />

你看到了，其实都不需要用到后面的update语句，就已经形成死锁了。我们按语句执行顺序来 分析一下：



1. session A 执行select …for update语句，**由于id=9这一行并不存在，因此会加上间隙锁 (5,10);** 
2. session B 执行select …for update语句，同样会加上间隙锁(5,10)，间隙锁之间不会冲突，因此这个语句可以执行成功； 
3. session B 试图插入一行(9,9,9)，被session A的间隙锁挡住了，只好进入等待； 
4. session A试图插入一行(9,9,9)，被session B的间隙锁挡住了。

至此，两个session进入互相等待状态，形成死锁。当然，InnoDB的死锁检测马上就发现了这对 死锁关系，让session A的insert语句报错返回了。

你现在知道了，间隙锁的引入，可能会导致同样的语句锁住更大的范围，这其实是影响了并发度的。其实，这还只是一个简单的例子，在下一篇文章中我们还会碰到更多、更复杂的例 子



你可能会说，为了解决幻读的问题，我们引入了这么一大串内容，有没有更简单一点的处理方法 呢。



我在文章一开始就说过，如果没有特别说明，今天和你分析的问题都是在可重复读隔离级别下 的，

**间隙锁是在可重复读隔离级别下才会生效的。所以，你如果把隔离级别设置为读提交的话， 就没有间隙锁了**。

但同时，你要解决可能出现的数据和日志不一致问题，需要把binlog格式设置 为row。这，也是现在不少公司使用的配置组合。



前面文章的评论区有同学留言说，他们公司就使用的是**读提交隔离级别加binlog_format=row的 组合**。他曾问他们公司的DBA说，你为什么要这么配置。DBA直接答复说，因为大家都这么用呀。

> "读提交"（Read Committed）是 MySQL 数据库的一种隔离级别，而 "binlog_format=row" 是 MySQL 的二进制日志格式设置。
>
> 1. **读提交隔离级别**：读提交是一种事务隔离级别，它确保一个事务只能读取到已经提交的数据，而不能读取到其他事务尚未提交的数据。这意味着在读提交隔离级别下，事务只能看到已经提交的数据，而不会看到其他事务尚未提交的数据。这可以提供更高的并发性和一致性。
> 2. **binlog_format=row**：binlog_format 是 MySQL 的二进制日志格式设置之一。二进制日志（Binary Log）是 MySQL 用于记录数据库更改操作的一种日志。binlog_format=row 是一种设置，它指定二进制日志记录的格式为行级别。**在行级别的二进制日志中，每个修改操作都会以行的形式记录，包括修改前和修改后的数据**。这种格式可以提供更详细和精确的日志记录，以便在进行数据恢复或复制时使用。
>
> 因此，"读提交隔离级别加binlog_format=row的组合" 意味着在该公司的 MySQL 环境中，事务的隔离级别设置为读提交，同时二进制日志的格式设置为行级别。这样的组合可以提供更高的并发性、一致性和更详细的日志记录，适用于需要高性能和数据一致性的应用场景。



所以，这个同学在评论区就问说，这个配置到底合不合理。

关于这个问题本身的答案是，如果读提交隔离级别够用，也就是说，业务不需要可重复读的保 证，这样考虑到读提交下操作数据的锁范围更小（没有间隙锁），这个选择是合理的。

但其实我想说的是，配置是否合理，跟业务场景有关，需要具体问题具体分析。

但是，如果DBA认为之所以这么用的原因是“大家都这么用”，那就有问题了，或者说，迟早会出 问题。



比如说，大家都用读提交，可是逻辑备份的时候，mysqldump为什么要把备份线程设置成可重复 读呢？（这个我在前面的文章中已经解释过了，你可以再回顾下第6篇文章《全局锁和表锁 ：给 表加个字段怎么有这么多阻碍？》的内容）

然后，在备份期间，备份线程用的是可重复读，而业务线程用的是读提交。同时存在两种事务隔 离级别，会不会有问题？

进一步地，这两个不同的隔离级别现象有什么不一样的，关于我们的业务，“用读提交就够了”这 个结论是怎么得到的？

如果业**务开发和运维团队**这些问题都没有弄清楚，那么“没问题”这个结论，本身就是有问题的。



## 小结

今天我们从上一篇文章的课后问题说起，提到了全表扫描的加锁方式。我们发现即使给所有的行 都加上行锁，仍然无法解决幻读问题，因此引入了间隙锁的概念。

我碰到过很多对数据库有一定了解的业务开发人员，他们在设计数据表结构和业务SQL语句的时 候，对行锁有很准确的认识，但却很少考虑到间隙锁。最后的结果，就是生产库上会经常出现由 于间隙锁导致的死锁现象



行锁确实比较直观，判断规则也相对简单，间隙锁的引入会影响系统的并发度，也增加了锁分析 的复杂度，但也有章可循。下一篇文章，我就会为你讲解InnoDB的加锁规则，帮你理顺这其中 的“章法”。

### 思考题

作为对下一篇文章的预习，我给你留下一个思考题。

<img src="MYSQL实战45讲.assets/image-20250220181556559.png" alt="image-20250220181556559" style="zoom:50%;" />



如果你之前没有了解过本篇文章的相关内容，一定觉得这三个语句简直是风马牛不相及。但实际 上，这里session B和session C的insert 语句都会进入锁等待状态。

你可以试着分析一下，出现这种情况的原因是什么？

这里需要说明的是，这其实是我在下一篇文章介绍加锁规则后才能回答的问题，是留给你作为预 习的，其中session C被锁住这个分析是有点难度的。如果你没有分析出来，也不要气馁，我会 在下一篇文章和你详细说明。

你也可以说说，你的线上MySQL配置的是什么隔离级别，为什么会这么配置？你有没有碰到什 么场景，是必须使用可重复读隔离级别的呢？



> 回答

这里，我展开回答一下评论区几位同学的问题。 

- @令狐少侠 说，以前一直认为间隙锁只在二级索引上有。现在你知道了，有间隙的地方就可能有间隙锁。
-  @浪里白条 同学问，如果是varchar类型，加锁规则是什么样的。 回答：实际上在判断间隙的时候，varchar和int是一样的，排好序以后，相邻两个值之间就有间隙。 
- 有几位同学提到说，上一篇文章自己验证的结果跟案例一不同，就是在session A执行完这两 个语句：

```
begin;
select * from t where d=5 for update; /*Q1*/
```

以后，session B 的update 和session C的insert 都会被堵住。这是不是跟文章的结论矛盾？

其实不是的，这个例子用的是反证假设，就是假设不堵住，会出现问题；然后，推导出session A需要锁整个表所有的行和所有间隙。



# 21 | 为什么我只改一行的语句，锁这么多



在上一篇文章中，我和你介绍了间隙锁和next-key lock的概念，但是并没有说明加锁规则。间隙 锁的概念理解起来确实有点儿难，尤其在配合上行锁以后，很容易在判断是否会出现锁等待的问 题上犯错。

所以今天，我们就先从这个加锁规则开始吧。

首先说明一下，这些加锁规则我没在别的地方看到过有类似的总结，以前我自己判断的时候都是 想着代码里面的实现来脑补的。这次为了总结成不看代码的同学也能理解的规则，是我又重新刷 了代码临时总结出来的。所以，这个规则有以下两条前提说明：

1. MySQL后面的版本可能会改变加锁策略，所以这个规则只限于截止到现在的最新版本，即 5.x系列<=5.7.24，8.0系列 <=8.0.13。
2. 如果大家在验证中有发现bad case的话，请提出来，我会再补充进这篇文章，使得一起学习 本专栏的所有同学都能受益。

因为间隙锁在可重复读隔离级别下才有效，所以本篇文章接下来的描述，若没有特殊说明，默认 是可重复读隔离级别。



我总结的加锁规则里面，包含了两个“原则”、两个“优化”和一个“bug”。

```json
1. 原则1：加锁的基本单位是next-key lock。希望你还记得，next-key lock是前开后闭区间。
2. 原则2：查找过程中访问到的对象才会加锁。

3. 优化1：索引上的等值查询，给唯一索引加锁的时候，next-key lock退化为行锁。
4. 优化2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock退化为间隙锁。

5. 一个bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。

```



我还是以上篇文章的表t为例，和你解释一下这些规则。表t的建表语句和初始化语句如下。

```sql
CREATE TABLE `t` (
    `id` int(11) NOT NULL,
    `c` int(11) DEFAULT NULL,
    `d` int(11) DEFAULT NULL,
    PRIMARY KEY (`id`),
    KEY `c` (`c`)
) ENGINE=InnoDB;

insert into t values(0,0,0),(5,5,5),
(10,10,10),(15,15,15),(20,20,20),(25,25,25);

```

接下来的例子基本都是配合着图片说明的，所以我建议你可以对照着文稿看，有些例子可能 会“毁三观”，也建议你读完文章后亲手实践一下。

## 案例一：等值查询间隙锁

第一个例子是关于等值条件操作间隙：

<img src="MYSQL实战45讲.assets/image-20250220192847692.png" alt="image-20250220192847692" style="zoom: 67%;" />



由于表t中没有id=7的记录，所以用我们上面提到的加锁规则判断一下的话：

1. 根据原则1，加锁单位是next-key lock，session A加锁范围就是(5,10]；
2. 同时根据优化2，这是一个等值查询(id=7)，而id=10不满足查询条件，next-key lock退化成间 隙锁，因此最终加锁的范围是(5,10)。

所以，session B要往这个间隙里面插入id=8的记录会被锁住，但是session C修改id=10这行是可以的。



## 案例二：非唯一索引等值锁

第二个例子是关于覆盖索引上的锁：

<img src="MYSQL实战45讲.assets/image-20250220193303217.png" alt="image-20250220193303217" style="zoom:50%;" />

看到这个例子，你是不是有一种“该锁的不锁，不该锁的乱锁”的感觉？我们来分析一下吧。

这里session A要给索引c上c=5的这一行加上读锁。

1. 根据原则1，加锁单位是next-key lock，因此会给(0,5]加上next-key lock。
2. 要注意c是普通索引（非唯一索引），因此仅访问c=5这一条记录是不能马上停下来的，需要向右遍历，查到 c=10才放弃。根据原则2，访问到的都要加锁，因此要给(5,10]加next-key lock。
3. 但是同时这个符合优化2：等值判断，向右遍历，最后一个值不满足c=5这个等值条件，因此 退化成间隙锁(5,10)。
4. 根据原则2 ，**只有访问到的对象才会加锁，这个查询使用覆盖索引，并不需要访问主键索 引，所以主键索引上没有加任何锁**，这就是为什么session B的update语句可以执行完成。

但session C要插入一个(7,7,7)的记录，就会被session A的间隙锁(5,10)锁住。

需要注意，在这个例子中，**lock in share mode只锁覆盖索引**，但是如果是for update就不一样 了。 

执行 **for update时，系统会认为你接下来要更新数据，因此会顺便给主键索引上满足条件的 行加上行锁**。



这个例子说明，锁是加在索引上的；同时，它给我们的指导是，如果你要用lock in share mode 来给行加读锁避免数据被更新的话，就必须得绕过覆盖索引的优化，在查询字段中加入索引中不 存在的字段。比如，将session A的查询语句改成select d fromt where c=5 lock in share mode。 你可以自己验证一下效果。



## 案例三：主键索引范围锁

第三个例子是关于范围查询的。

举例之前，你可以先思考一下这个问题：对于我们这个表t，下面这两条查询语句，加锁范围相同吗？

```sql
mysql> select * from t where id=10 for update;
mysql> select * from t where id>=10 and id<11 for update;
```

你可能会想，id定义为int类型，这两个语句就是等价的吧？其实，它们并不完全等价。

在逻辑上，这两条查语句肯定是等价的，但是它们的加锁规则不太一样。现在，我们就让 session A执行第二个查询语句，来看看加锁效果。

<img src="MYSQL实战45讲.assets/image-20250220194000874.png" alt="image-20250220194000874" style="zoom:50%;" />

现在我们就用前面提到的加锁规则，来分析一下session A 会加什么锁呢？

1、开始执行的时候，要找到第一个id=10的行，因此本该是next-key lock(5,10]。 根据优化1， 主键id上的等值条件，退化成行锁，只加了id=10这一行的行锁。

2、范围查找就往后继续找，找到id=15这一行停下来，因此需要加next-key lock(10,15]。（====》不是等值查询不会优化）



所以，session A这时候锁的范围就是主键索引上，行锁id=10和next-key lock(10,15]。这 样，session B和session C的结果你就能理解了。

这里你需要注意一点，**首次session A定位查找id=10的行的时候**，是当做等值查询来判断的，而 向右扫描到id=15的时候，用的是范围查询判断。



## 案例四：非唯一索引范围锁

接下来，我们再看两个范围查询加锁的例子，你可以对照着案例三来看。

需要注意的是，与案例三不同的是，案例四中查询语句的where部分用的是字段c。

<img src="MYSQL实战45讲.assets/image-20250220194537209.png" alt="image-20250220194537209" style="zoom:50%;" />

这次session A用字段c来判断，加锁规则跟案例三唯一的不同是：在第一次用c=10定位记录的时 候，索引c上加了(5,10]这个next-key lock后，由于索引c是非唯一索引，没有优化规则，也就是 说不会蜕变为行锁，因此最终sesion A加的锁是，索引c上的(5,10] 和(10,15] 这两个next-key lock。



所以从结果上来看，sesson B要插入（8,8,8)的这个insert语句时就被堵住了。

这里需要扫描到c=15才停止扫描，是合理的，因为InnoDB要扫到c=15，才知道不需要继续往后找了。



## 案例五：唯一索引范围锁bug

前面的四个案例，我们已经用到了加锁规则中的两个原则和两个优化，接下来再看一个关于加锁 规则中bug的案例。

<img src="MYSQL实战45讲.assets/image-20250220194748634.png" alt="image-20250220194748634" style="zoom:50%;" />

session A是一个范围查询，按照原则1的话，应该是索引id上只加(10,15]这个next-key lock，并且因为id是唯一键，所以循环判断到id=15这一行就应该停止了。

但是实现上，**InnoDB会往前扫描到第一个不满足条件的行为止**，也就是id=20。而且由于这是个 范围扫描，因此索引id上的(15,20]这个next-key lock也会被锁上。

所以你看到了，session B要更新id=20这一行，是会被锁住的。同样地，session C要插入id=16 的一行，也会被锁住。

照理说，这里锁住id=20这一行的行为，其实是没有必要的。因为扫描到id=15，就可以确定不用 往后再找了。但实现上还是这么做了，因此我认为这是个bug。

我也曾找社区的专家讨论过，官方bug系统上也有提到，但是并未被verified。所以，认为这是 bug这个事儿，也只能算我的一家之言，如果你有其他见解的话，也欢迎你提出来。



## 案例六：非唯一索引上存在"等值"的例子

接下来的例子，是为了更好地说明“间隙”这个概念。这里，我给表t插入一条新记录。

```sql
mysql> insert into t values(30,10,30);
```

新插入的这一行c=10，也就是说现在表里有两个c=10的行。那么，这时候索引c上的间隙是什么 状态了呢？你要知道，由于非唯一索引上包含主键的值，所以是不可能存在“相同”的两行的。

<img src="MYSQL实战45讲.assets/image-20250220195208761.png" alt="image-20250220195208761" style="zoom: 50%;" />



可以看到，虽然有两个c=10，但是它们的主键值id是不同的（分别是10和30），因此这两个 c=10的记录之间，也是有间隙的。

图中我画出了索引c上的主键id。为了跟间隙锁的开区间形式进行区别，我用(c=10,id=30)这样的 形式，来表示索引上的一行。

现在，我们来看一下案例六。

这次我们用delete语句来验证。注意，delete语句加锁的逻辑，其实跟select ... for update 是类 似的，也就是我在文章开始总结的两个“原则”、两个“优化”和一个“bug”。

<img src="MYSQL实战45讲.assets/image-20250220195313699.png" alt="image-20250220195313699" style="zoom:50%;" />

这时，session A在遍历的时候，先访问第一个c=10的记录。同样地，根据原则1，这里加的是 (c=5,id=5)到(c=10,id=10)这个next-key lock。

然后，session A向右查找，直到碰到(c=15,id=15)这一行，循环才结束。根据优化2，这是一个 等值查询，向右查找到了不满足条件的行，所以会退化成(c=10,id=10) 到 (c=15,id=15)的间隙锁。



也就是说，这个delete语句在索引c上的加锁范围，就是下图中蓝色区域覆盖的部分。

<img src="MYSQL实战45讲.assets/image-20250220195436229.png" alt="image-20250220195436229" style="zoom:50%;" />

这个蓝色区域左右两边都是虚线，表示开区间，即(c=5,id=5)和(c=15,id=15)这两行上都没有锁。



## 案例七：limit 语句加锁

> ==》会减少扫描范围

例子6也有一个对照案例，场景如下所示：

<img src="MYSQL实战45讲.assets/image-20250220195511779.png" alt="image-20250220195511779" style="zoom:50%;" />

这个例子里，session A的delete语句加了 limit 2。你知道表t里c=10的记录其实只有两条，因此 加不加limit 2，删除的效果都是一样的，但是加锁的效果却不同。可以看到，session B的insert 语句执行通过了，跟案例六的结果不同。



这是因为，案例七里的delete语句明确加了limit 2的限制，因此在遍历到(c=10, id=30)这一行之 后，满足条件的语句已经有两条，循环就结束了。

因此，索引c上的加锁范围就变成了从（c=5,id=5)到（c=10,id=30)这个前开后闭区间，如下图所示：

<img src="MYSQL实战45讲.assets/image-20250220195612189.png" alt="image-20250220195612189" style="zoom:50%;" />

可以看到，(c=10,id=30）之后的这个间隙并没有在加锁范围里，因此insert语句插入c=12是可以 执行成功的。

这个例子对我们实践的指导意义就是，在删除数据的时候尽量加limit。这样不仅可以控制删除 数据的条数，让操作更安全，还可以减小加锁的范围。



## 案例八：一个死锁的例子

前面的例子中，我们在分析的时候，是按照next-key lock的逻辑来分析的，因为这样分析比较方 便。最后我们再看一个案例，目的是说明：next-key lock实际上是间隙锁和行锁加起来的结果。

你一定会疑惑，这个概念不是一开始就说了吗？不要着急，我们先来看下面这个例子：

<img src="MYSQL实战45讲.assets/image-20250220195730644.png" alt="image-20250220195730644" style="zoom: 50%;" />



```
begin;
select id from t where c=10 lock in share mode;
                                                 update t set d=d+1 where c=10;
insert into t values(8,8,8);                                             
```

现在，我们按时间顺序来分析一下为什么是这样的结果。

1. session A 启动事务后执行查询语句加lock in share mode，在索引c上加了next-key lock(5,10] 和间隙锁(10,15)；
2. session B 的update语句也要在索引c上加next-key lock(5,10] ，进入锁等待；
3. 然后session A要再插入(8,8,8)这一行，被session B的间隙锁锁住。由于出现了死 锁，InnoDB让session B回滚。

你可能会问，session B的next-key lock不是还没申请成功吗？

其实是这样的，**session B的“加next-key lock(5,10] ”操作，实际上分成了两步，先是加(5,10)的间 隙锁，加锁成功；然后加c=10的行锁，这时候才被锁住的**。

也就是说，我们在分析加锁规则的时候可以用next-key lock来分析。但是要知道，具体执行的时 候，是要分成间隙锁和行锁两段来执行的。





## 小结

这里我再次说明一下，我们上面的所有案例都是在可重复读隔离级别(repeatable-read)下验证 的。同时，可重复读隔离级别遵守两阶段锁协议，所有加锁的资源，都是在事务提交或者回滚的 时候才释放的。



在最后的案例中，你可以清楚地知道next-key lock实际上是由间隙锁加行锁实现的。如果切换到 读提交隔离级别(read-committed)的话，就好理解了，过程中去掉间隙锁的部分，也就是只剩下 行锁的部分。



其实读提交隔离级别在外键场景下还是有间隙锁，相对比较复杂，我们今天先不展开。



另外，**在读提交隔离级别下还有一个优化，即：语句执行过程中加上的行锁，在语句执行完成 后，就要把“不满足条件的行”上的行锁直接释放了，不需要等到事务提交**。



也就是说，读提交隔离级别下，锁的范围更小，锁的时间更短，这也是不少业务都默认使用读提 交隔离级别的原因。

不过，我希望你学过今天的课程以后，可以对next-key lock的概念有更清晰的认识，并且会用加 锁规则去判断语句的加锁范围。

在业务需要使用可重复读隔离级别的时候，能够更细致地设计操作数据库的语句，解决幻读问题 的同时，最大限度地提升系统并行处理事务的能力。

经过这篇文章的介绍，你再看一下上一篇文章最后的思考题，再来尝试分析一次。



### 思考题

我把题目重新描述和简化一下：还是我们在文章开头初始化的表t，里面有6条记录，图12的语句 序列中，为什么session B的insert操作，会被锁住呢？

<img src="MYSQL实战45讲.assets/image-20250220200809560.png" alt="image-20250220200809560" style="zoom: 67%;" />

另外，如果你有兴趣多做一些实验的话，可以设计好语句序列，在执行之前先自己分析一下，然 后实际地验证结果是否跟你的分析一致。

> 回答

我们用上一篇的加锁规则来分析一下，看看session A的select语句加了哪些锁：

1. 由于是order by c desc，第一个要定位的是索引c上“最右边的”c=20的行，所以会加上间隙锁 (20,25)和next-key lock (15,20]。
2. 在索引c上向左遍历，要扫描到c=10才停下来，所以**next-key lock会加到(5,10]**，这正是阻塞 session B的insert语句的原因。
3. 在扫描过程中，c=20、c=15、c=10这三行都存在值，由于是select *，所以会在主键id上加 三个行锁。

因此，session A 的select语句锁的范围就是：

1. 索引c上 (5, 25)；
2. 主键索引上id=15、20两个行锁。

这里，我再啰嗦下，你会发现我在文章中，每次加锁都会说明是加在“哪个索引上”的。因为，**锁就是加在索引上的，这是InnoDB的一个基础设定**，需要你在分析问题的时候要一直记得。



> @Justin 同学提了个好问题，<=到底是间隙锁还是行锁？其实，这个问题，你要跟“执行过 程”配合起来分析。在InnoDB要去找“第一个值”的时候，是按照等值去找的，用的是等值判断 的规则；找到第一个值以后，要在索引内找“下一个值”，对应于我们规则中说的范围查找。
>
> @信信 提了一个不错的问题，要知道最终的加锁是根据实际执行情况来的。所以，如果一个 select *from…for update 语句，优化器决定使用全表扫描，那么就会把主键索引上next-key lock全加上。
>
> @nero 同学的问题，提示我需要提醒大家注意，“有行”才会加行锁。如果查询条件没有命中 行，那就加next-key lock。当然，等值判断的时候，需要加上优化2（即：索引上的等值查 询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock退化为间隙锁。）。

















# 22 | MySQL有哪些“饮鸩止渴”提高性能的方法？

不知道你在实际运维过程中有没有碰到这样的情景：业务高峰期，生产环境的MySQL压力太 大，没法正常响应，需要短期内、临时性地提升一些性能。 我以前做业务护航的时候，就偶尔会碰上这种场景。用户的开发负责人说，不管你用什么方案， 让业务先跑起来再说。 但，如果是无损方案的话，肯定不需要等到这个时候才上场。今天我们就来聊聊这些临时方案， 并着重说一说它们可能存在的风险。



## 短连接风暴

 正常的短连接模式就是连接到数据库后，执行很少的SQL语句就断开，下次需要的时候再重连。 如果使用的是短连接，在业务高峰期的时候，就可能出现连接数突然暴涨的情况。 



我在第1篇文章《基础架构：一条SQL查询语句是如何执行的？》中说过，

MySQL建立连接的过 程，成本是很高的。除了正常的网络连接三次握手外，还需要做登录权限判断和获得这个连接的 数据读写权限。 在数据库压力比较小的时候，这些额外的成本并不明显。 但是，短连接模型存在一个风险，就是一旦数据库处理得慢一些，连接数就会暴涨。

**max_connections参数**，用来控制一个MySQL实例同时存在的连接数的上限，超过这个值，系统就会拒绝接下来的连接请求，并报错提示“Too many connections”。对于被拒绝连接的请求来 说，从业务角度看就是数据库不可用。



**在机器负载比较高的时候**，处理现有请求的时间变长，每个连接保持的时间也更长。这时，再有 新建连接的话，就可能会超过max_connections的限制。



碰到这种情况时，一个比较自然的想法，就是调高max_connections的值。但这样做是有风险 的。因为设计max_connections这个参数的目的是想保护MySQL，如果我们把它改得太大，让更 多的连接都可以进来，那么系统的负载可能会进一步加大，大量的资源耗费在权限验证等逻辑 上，结果可能是适得其反，已经连接的线程拿不到CPU资源去执行业务的SQL请求。



### 两种有损方法

 那么这种情况下，你还有没有别的建议呢？我这里还有两种方法，但要注意，这些方法都是**有损的**。



**第一种方法：先处理掉那些占着连接但是不工作的线程**。

 max_connections的计算，不是看谁在running，是只要连着就占用一个计数位置。对于那些不需 要保持的连接，我们可以通过kill connection主动踢掉。

这个行为跟事先设置wait_timeout的效果 是一样的。设置wait_timeout参数表示的是，一个线程空闲wait_timeout这么多秒之后，就会被 MySQL直接断开连接。



但是需要注意，在`show processlist`的结果里，踢掉显示为sleep的线程，可能是有损的。我们来 看下面这个例子。

![image-20241225203005539](MYSQL实战45讲.assets/image-20241225203005539.png)

在上面这个例子里，如果断开session A的连接，因为这时候session A还没有提交，所以MySQL 只能按照回滚事务来处理；而断开session B的连接，就没什么大影响。所以，如果按照优先级 来说，你应该优先断开像session B这样的事务外空闲的连接。(先断开读操作的sleep进程)



但是，怎么判断哪些是事务外空闲的呢？session C在T时刻之后的30秒执行showprocesslist， 看到的结果是这样的。

<img src="MYSQL实战45讲.assets/image-20241225203342065.png" alt="image-20241225203342065" style="zoom: 67%;" />



图中id=4和id=5的两个会话都是Sleep 状态。而要看事务具体状态的话，你可以查 information_schema库的innodb_trx表。

```sql
select * from information_schema.innodb_trx \G;
```

<img src="MYSQL实战45讲.assets/image-20241225203421367.png" alt="image-20241225203421367" style="zoom:50%;" />



这个结果里，trx_mysql_thread_id=4，表示id=4的线程还处在事务中。 因此，如果是连接数过多，你可以**优先断开事务外空闲太久的连接**；如果这样还不够，再考虑断 开事务内空闲太久的连接。



从服务端断开连接使用的是`KILL <connection_id>;` 的命令， 一个客户端处于sleep状态时，它的连接 被服务端主动断开后，这个客户端并不会马上知道。直到客户端在发起下一个请求的时候，才会 收到这样的报错“ERROR 2013 (HY000): Lost connection to MySQL server during query”。



从数据库端主动断开连接可能是有损的，尤其是有的应用端收到这个错误后，不重新连接，而是 直接用这个已经不能用的句柄重试查询。这会导致从应用端看上去，“MySQL一直没恢复”。 你可能觉得这是一个冷笑话，但实际上我碰到过不下10次。 所以，如果你是一个支持业务的DBA，不要假设所有的应用代码都会被正确地处理。即使只是 一个断开连接的操作，也要确保通知到业务开发团队。



**第二种方法：减少连接过程的消耗。** 



有的业务代码会在短时间内先大量申请数据库连接做备用，如果现在数据库确认是被连接行为打 挂了，那么一种可能的做法，是让数据库跳过权限验证阶段。

 跳过权限验证的方法是：重启数据库，并使用**–skip-grant-tables参数**启动。

这样，整个MySQL会 跳过所有的权限验证阶段，包括连接过程和语句执行过程在内。

 但是，这种方法特别符合我们标题里说的“饮鸩止渴”，风险极高，是我特别不建议使用的方案。

 尤其你的库外网可访问的话，就更不能这么做了。

 **在MySQL 8.0版本里，如果你启用–skip-grant-tables参数，MySQL会默认把 --skip-networking参 数打开，表示这时候数据库只能被本地的客户端连接**。

可见，MySQL官方对skip-grant-tables这 个参数的安全问题也很重视。 除了短连接数暴增可能会带来性能问题外，实际上，我们在线上碰到更多的是查询或者更新语句 导致的性能问题。其中，查询问题比较典型的有两类，一类是由新出现的慢查询导致的，一类是 由QPS（每秒查询数）突增导致的。而关于更新语句导致的性能问题，我会在下一篇文章和你展 开说明。



## 慢查询性能问题 



在MySQL中，会引发性能问题的慢查询，大体有以下三种可能： 1. 索引没有设计好； 2. SQL语句没写好； 3. MySQL选错了索引。

接下来，我们就具体分析一下这三种可能，以及对应的解决方案。



导致慢查询的第一种可能是，**索引没有设计好**。

这种场景一般就是通过紧急创建索引来解决。MySQL 5.6版本以后，创建索引都支持Online DDL 了，对于那种高峰期数据库已经被这个语句打挂了的情况，最高效的做法就是直接执行alter table 语句



比较理想的是能够在备库先执行。假设你现在的服务是一主一备，主库A、备库B，这个方案的 大致流程是这样的：

1. 在备库B上执行 `set sql_log_bin=off`，也就是不写binlog，然后执行alter table 语句加上索 引；
2. 执行主备切换； 
3. 这时候主库是B，备库是A。在A上执行 set sql_log_bin=off，然后执行alter table 语句加上 索引。



这是一个“古老”的DDL方案。平时在做变更的时候，你应该考虑类似gh-ost这样的方案，更加稳 妥。但是在需要紧急处理时，上面这个方案的效率是最高的。



导致慢查询的第二种可能是，**语句没写好**。 



比如，我们犯了在第18篇文章《为什么这些SQL语句逻辑相同，性能却差异巨大？》中提到的 那些错误，导致语句没有使用上索引。

这时，我们可以通过改写SQL语句来处理。

MySQL 5.7提供了**query_rewrite功能**，可以把输入的 一种语句改写成另外一种模式。 比如，语句被错误地写成了 `select *from t where id + 1 = 10000`，你可以通过下面的方式，增加 一个语句改写规则。

```sql
mysql> insert into query_rewrite.rewrite_rules(pattern, replacement, pattern_database) values ("select * from t where id + 1 = ?", "select * from t where id = ? - 1", "db1");

call query_rewrite.flush_rewrite_rules()
```

这里，call query_rewrite.flush_rewrite_rules()这个存储过程，是让插入的新规则生效，也就是我 们说的“查询重写”。你可以用图4中的方法来确认改写规则是否生效。



<img src="MYSQL实战45讲.assets/image-20241225204639614.png" alt="image-20241225204639614" style="zoom: 67%;" />



导致慢查询的第三种可能，就是碰上了我们在第10篇文章《MySQL为什么有时候会选错索 引？》中提到的情况，**MySQL选错了索引**。 

这时候，应急方案就是给这个语句加上force index。



这时候，应急方案就是给这个语句加上force index。 同样地，使用查询重写功能，给原来的语句加上force index，也可以解决这个问题。



上面我和你讨论的由慢查询导致性能问题的三种可能情况，实际上出现最多的是前两种，即：索 引没设计好和语句没写好。而这两种情况，恰恰是完全可以避免的。比如，通过下面这个过程， 我们就可以预先发现问题。

1. 上线前，在测试环境，把**慢查询日志（slowlog）**打开，并且把long_query_time设置成0， 确保每个语句都会被记录入慢查询日志；
2. 在测试表里插入模拟线上的数据，做一遍回归测试；

```yaml
#my.cnf
slow_query_log = 1
slow_query_log_file = /path/to/slow_query.log
long_query_time = 0 ## If a query takes longer than this many seconds, the server increments the Slow_queries status variable
```

3. 观察慢查询日志里每类语句的输出，特别留意Rows_examined字段是否与预期一致。（我 们在前面文章中已经多次用到过Rows_examined方法了，相信你已经动手尝试过了。如果 还有不明白的，欢迎给我留言，我们一起讨论）。



不要吝啬这段花在上线前的“额外”时间，因为这会帮你省下很多故障复盘的时间。 如果新增的SQL语句不多，手动跑一下就可以。而如果是新项目的话，或者是修改了原有项目的 表结构设计，**全量回归测试**都是必要的。这时候，你需要工具帮你检查所有的SQL语句的返回结 果。比如，你可以使用开源工具pt-query-digest(https://www.percona.com/doc/perconatoolkit/3.0/pt-query-digest.html)。



## QPS突增问题

有时候由于业务突然出现高峰，或者应用程序bug，导致某个语句的QPS突然暴涨，也可能导致 MySQL压力过大，影响服务。

我之前碰到过一类情况，是由一个新功能的bug导致的。当然，最理想的情况是让业务把这个功能下掉，服务自然就会恢复。

而下掉一个功能，如果从数据库端处理的话，对应于不同的背景，有不同的方法可用。我这里再 和你展开说明一下。

1. 一种是由全新业务的bug导致的。假设你的DB运维是比较规范的，也就是说白名单是一个个 加的。这种情况下，如果你能够确定业务方会下掉这个功能，只是时间上没那么快，那么就 可以从数据库端直接把白名单去掉。
2. 如果这个新功能使用的是单独的数据库用户，可以用管理员账号把这个用户删掉，然后断开 现有连接。这样，这个新功能的连接不成功，由它引发的QPS就会变成0。

3. 如果这个新增的功能跟主体功能是部署在一起的，那么我们只能通过处理语句来限制。这 时，我们可以使用上面提到的查询重写功能，**把压力最大的SQL语句直接重写成"select 1"返回**。 当然，这个操作的风险很高，需要你特别细致。它可能存在两个副作用：
   1. 如果别的功能里面也用到了这个SQL语句模板，会有误伤； 
   2. 很多业务并不是靠这一个语句就能完成逻辑的，所以如果单独把这一个语句以select 1的结 果返回的话，可能会导致后面的业务逻辑一起失败。



所以，方案3是用于止血的，跟前面提到的去掉权限验证一样，应该是你所有选项里优先级最低 的一个方案。 同时你会发现，其实方案1和2都要依赖于规范的运维体系：**虚拟化、白名单机制、业务账号分离**。由此可见，更多的准备，往往意味着更稳定的系统。



## 小结

今天这篇文章，我以业务高峰期的性能问题为背景，和你介绍了一些紧急处理的手段。 

这些处理手段中，既包括了粗暴地拒绝连接和断开连接，也有通过重写语句来绕过一些坑的方法；

既有临时的高危方案，也有未雨绸缪的、相对安全的预案。 

在实际开发中，我们也要尽量避免一些低效的方法，比如避免大量地使用短连接。

同时，如果你做业务开发的话，要知道，**连接异常断开是常有的事，你的代码里要有正确地重连并重试的机制**。 

DBA虽然可以通过语句重写来暂时处理问题，但是这本身是一个风险高的操作，做好SQL审计 可以减少需要这类操作的机会。 

其实，你可以看得出来，在这篇文章中我提到的解决方法主要集中在server层。

在下一篇文章 中，我会继续和你讨论一些跟InnoDB有关的处理方法。 

最后，又到了我们的思考题时间了。

今天，我留给你的课后问题是，你是否碰到过，在业务高峰期需要临时救火的场景？你又是怎么 处理的呢？



# 23 | MySQL是怎么保证数据不丢的？

今天这篇文章，我会继续和你介绍在业务高峰期临时提升性能的方法。从文章标题“MySQL是怎 么保证数据不丢的？”，你就可以看出来，今天我和你介绍的方法，跟数据的可靠性有关。



在专栏前面文章和答疑篇中，我都着重介绍了WAL机制（你可以再回顾下第2篇、第9篇、第12 篇和第15篇文章中的相关内容），得到的**结论是：只要redo log和binlog保证持久化到磁盘，就 能确保MySQL异常重启后，数据可以恢复**。



评论区有同学又继续追问，redo log的写入流程是怎么样的，如何保证redo log真实地写入了磁 盘。那么今天，我们就再一起**看看MySQL写入binlog和redo log的流程**。



## binlog的写入机制

其实，binlog的写入逻辑比较简单：事务执行过程中，先把日志写到**binlog cache**，事务提交的时候，再把binlog cache写到binlog文件中。



**一个事务的binlog是不能被拆开的**，因此不论这个事务多大，也要确保一次性写入。这就涉及到 了binlog cache的保存问题。



系统给binlog cache分配了一片内存，每个线程一个，参数 binlog_cache_size用于控制单个线程 内binlog cache所占内存的大小。如果超过了这个参数规定的大小，就要暂存到磁盘。

事务提交的时候，执行器把binlog cache里的完整事务写入到binlog中，并清空binlog cache。状态如图1所示。

<img src="MYSQL实战45讲.assets/image-20250221182320911.png" alt="image-20250221182320911" style="zoom: 50%;" />

可以看到，每个线程有自己binlog cache，但是共用同一份binlog文件。

- 图中的**write**，指的就是指把日志写入到文件系统的page cache，并没有把数据持久化到磁盘，所以速度比较快。 
- 图中的**fsync**，才是将数据持久化到磁盘的操作。一般情况下，我们认为fsync才占磁盘的 IOPS。



write 和fsync的时机，是由参数sync_binlog控制的：

1. sync_binlog=0的时候，表示每次提交事务都只write，不fsync；
2. sync_binlog=1的时候，表示每次提交事务都会执行fsync；
3. sync_binlog=N(N>1)的时候，表示每次提交事务都write，但累积N个事务后才fsync。

因此，在出现IO瓶颈的场景里，将sync_binlog设置成一个比较大的值，可以提升性能。在实际 的业务场景中，考虑到丢失日志量的可控性，一般不建议将这个参数设成0，比较常见的是将其 设置为100~1000中的某个数值。



但是，将sync_binlog设置为N，对应的**风险是：如果主机发生异常重启，会丢失最近N个事务的 binlog日志**。



## redo log的写入机制

在专栏的第15篇答疑文章中，我给你介绍了redo log buffer。事务在执行过程中，生成的redo log是要先写到redo log buffer的。



> 然后就有同学问了，**redo log buffer里面的内容，是不是每次生成后都要直接持久化到磁盘呢？**

答案是，不需要。

如果事务执行期间MySQL发生异常重启，那这部分日志就丢了。由于事务并没有提交，所以这 时日志丢了也不会有损失。



> 那么，另外一个问题是，事务还没提交的时候，redo log buffer中的部分日志有没有可能被持久 化到磁盘呢？ 

答案是，确实会有。



这个问题，要从redo log可能存在的三种状态说起。这三种状态，对应的就是图2 中的三个颜色块。

<img src="MYSQL实战45讲.assets/image-20250221182844107.png" alt="image-20250221182844107" style="zoom:50%;" />

这三种状态分别是：

1. 存在redo log buffer中，物理上是在MySQL**进程内存**中，就是图中的红色部分； 
2. 写到磁盘(write)，但是没有持久化（fsync)，物理上是在文件系统的page cache里面，也就 是图中的黄色部分； 
3. 持久化到磁盘，对应的是hard disk，也就是图中的绿色部分。

日志写到redo log buffer是很快的，wirte到page cache也差不多，但是持久化到磁盘的速度就慢多了。



为了控制redo log的写入策略，InnoDB提供了innodb_flush_log_at_trx_commit参数，它有三种 可能取值：

1. 设置为0的时候，表示每次事务提交时都只是把redo log留在redo log buffer中; 
2. **设置为1的时候，表示每次事务提交时都将redo log直接持久化到磁盘**； 
3. 设置为2的时候，表示每次事务提交时都只是把redo log写到page cache



InnoDB有一个后台线程，每隔1秒，就会把redo log buffer中的日志，调用write写到文件系统的 page cache，然后调用fsync持久化到磁盘。

> 注意，事务执行中间过程的redo log也是直接写在redo log buffer中的，这些redo log也会被后台线程一起持久化到磁盘。也就是说，一个没有提交的事务的redo log，也是可能已经持久化到磁 盘的。



实际上，除了后台线程每秒一次的轮询操作外，还有两种场景会让一个没有提交的事务的redo log写入到磁盘中。

1. 一种是redo log buffer占用的空间即将达到 innodb_log_buffer_size一半的时候， 后台线程会主动写盘。注意，由于这个事务并没有提交，所以这个写盘动作只是write，而没有调用fsync，也就是只留在了文件系统的page cache。

2. **另一种是，并行的事务提交的时候，顺带将这个事务的redo log buffer持久化到磁盘**。假设一个事务A执行到一半，已经写了一些redo log到buffer中，这时候有另外一个线程 的事务B提交，如果innodb_flush_log_at_trx_commit设置的是1，那么按照这个参数的逻 辑，事务B要把redo log buffer里的日志全部持久化到磁盘。这时候，就会带上事务A在redo log buffer里的日志一起持久化到磁盘。

这里需要说明的是，我们介绍两阶段提交的时候说过，时序上redo log先prepare， 再写binlog， 最后再把redo log commit。

如果把innodb_flush_log_at_trx_commit设置成1，那么redo log在prepare阶段就要持久化一次， 因为有一个崩溃恢复逻辑是要依赖于prepare 的redo log，再加上binlog来恢复的。（如果你印象 有点儿模糊了，可以再回顾下第15篇文章中的相关内容）。

**每秒一次后台轮询刷盘，再加上崩溃恢复这个逻辑，InnoDB就认为redo log在commit的时候就 不需要fsync了，只会write到文件系统的page cache中就够了**。



通常我们说**MySQL的“双1”配置**，指的就是sync_binlog和innodb_flush_log_at_trx_commit都设 置成 1。也就是说，一个事务完整提交前，需要等待两次刷盘，一次是redo log（prepare 阶 段），一次是binlog。



这时候，你可能有一个疑问，这意味着我从MySQL看到的TPS是每秒两万的话，每秒就会写四 万次磁盘。但是，我用工具测试出来，磁盘能力也就两万左右，怎么能实现两万的TPS？



解释这个问题，就要用到**组提交（group commit）**机制了。

这里，我需要先和你介绍**日志逻辑序列号（log sequence number，LSN）**的概念。LSN是单调 递增的，用来对应redo log的一个个写入点。每次写入长度为length的redo log， LSN的值就会加 上length。



LSN也会写到InnoDB的数据页中，来确保数据页不会被多次执行重复的redo log。关于LSN和 redo log、checkpoint的关系，我会在后面的文章中详细展开。

如图3所示，是三个并发事务(trx1, trx2, trx3)在prepare 阶段，都写完redo log buffer，持久化到 磁盘的过程，对应的LSN分别是50、120 和160

<img src="MYSQL实战45讲.assets/image-20250221193220514.png" alt="image-20250221193220514" style="zoom:67%;" />



从图中可以看到，

1. trx1是第一个到达的，会被选为这组的 leader； 
2. 等trx1要开始写盘的时候，这个组里面已经有了三个事务，这时候LSN也变成了160； 
3. trx1去写盘的时候，带的就是LSN=160，因此等trx1返回时，所有LSN小于等于160的redo log，都已经被持久化到磁盘；
4. 这时候trx2和trx3就可以直接返回了。

所以，一次组提交里面，组员越多，节约磁盘IOPS的效果越好。但如果只有单线程压测，那就只能老老实实地一个事务对应一次持久化操作了。



在并发更新场景下，第一个事务写完redo log buffer以后，接下来这个fsync越晚调用，组员可能 越多，节约IOPS的效果就越好。

为了让一次fsync带的组员更多，MySQL有一个很有趣的优化：拖时间。在介绍两阶段提交的时 候，我曾经给你画了一个图，现在我把它截过来。

<img src="MYSQL实战45讲.assets/image-20250221193537705.png" alt="image-20250221193537705" style="zoom:50%;" />

图中，我把“写binlog”当成一个动作。但实际上，写binlog是分成两步的：

1. 先把binlog从binlog cache中写到磁盘上的binlog文件；
2. 调用fsync持久化。

MySQL为了让组提交的效果更好，把redo log做fsync的时间拖到了步骤1之后。也就是说，上面的图变成了这样：



<img src="MYSQL实战45讲.assets/image-20250221193702691.png" alt="image-20250221193702691" style="zoom:50%;" />



这么一来，binlog也可以组提交了。在执行图5中第4步把binlog fsync到磁盘时，如果有多个事务 的binlog已经写完了，也是一起持久化的，这样也可以减少IOPS的消耗。



不过通常情况下第3步执行得会很快，所以binlog的write和fsync间的间隔时间短，导致能集合到 一起持久化的binlog比较少，因此binlog的组提交的效果通常不如redo log的效果那么好。

如果你想提升binlog组提交的效果，可以通过设置 binlog_group_commit_sync_delay和 binlog_group_commit_sync_no_delay_count来实现。

1. `binlog_group_commit_sync_delay`参数，表示延迟多少微秒后才调用fsync; 
2. `binlog_group_commit_sync_no_delay_count`参数，表示累积多少次以后才调用fsync。

这两个条件是或的关系，也就是说只要有一个满足条件就会调用fsync。

所以，当binlog_group_commit_sync_delay设置为0的时 候，binlog_group_commit_sync_no_delay_count也无效了。



之前有同学在评论区问到，WAL机制是减少磁盘写，可是每次提交事务都要写redo log和 binlog，这磁盘读写次数也没变少呀？

现在你就能理解了，WAL机制主要得益于两个方面：

1. redo log 和 binlog都是顺序写，磁盘的顺序写比随机写速度要快；
2. 组提交机制，可以大幅度降低磁盘的IOPS消耗。



分析到这里，我们再来回答这个问题：**如果你的MySQL现在出现了性能瓶颈，而且瓶颈在IO 上，可以通过哪些方法来提升性能呢**？

针对这个问题，可以考虑以下三种方法： 

1. 设置 binlog_group_commit_sync_delay和 binlog_group_commit_sync_no_delay_count参 数，减少binlog的写盘次数。这个方法是基于“额外的故意等待”来实现的，因此可能会增加 语句的响应时间，但没有丢失数据的风险。
2. 将sync_binlog 设置为大于1的值（比较常见是100~1000）。这样做的风险是，主机掉电时 会丢binlog日志。
3. 将innodb_flush_log_at_trx_commit设置为2。这样做的风险是，主机掉电的时候会丢数据。

我不建议你把innodb_flush_log_at_trx_commit 设置成0。因为把这个参数设置成0，表示redo log只保存在内存中，这样的话MySQL本身异常重启也会丢数据，风险太大。而**redo log写到文件系统的page cache的速度也是很快的，所以将这个参数设置成2跟设置成0其实性能差不多**， 但这样做MySQL异常重启时就不会丢数据了，相比之下风险会更小。





## 小结

在专栏的第2篇和第15篇文章中，我和你分析了，如果redo log和binlog是完整的，MySQL是如 何保证crash-safe的。今天这篇文章，我着重和你介绍的是MySQL是“怎么保证redo log和binlog 是完整的”。

希望这三篇文章串起来的内容，能够让你对crash-safe这个概念有更清晰的理解。



之前的第15篇答疑文章发布之后，有同学继续留言问到了一些跟日志相关的问题，这里为了方 便你回顾、学习，我再集中回答一次这些问题。



问题1：执行一个update语句以后，我再去执行hexdump命令直接查看ibd文件内容，为什么没 有看到数据有改变呢？ 

回答：这可能是因为WAL机制的原因。update语句执行完成后，InnoDB只保证写完了redo log、内存，可能还没来得及将数据写到磁盘。



问题2：为什么binlog cache是每个线程自己维护的，而redo log buffer是全局共用的？

回答：**MySQL这么设计的主要原因是，binlog是不能“被打断的”**。一个事务的binlog必须连续 写，因此要整个事务完成后，再一起写到文件里。而redo log并没有这个要求，中间有生成的日志可以写到redo log buffer中。redo log buffer中的 内容还能“搭便车”，其他事务提交的时候可以被一起写到磁盘中。



问题3：事务执行期间，还没到提交阶段，如果发生crash的话，redo log肯定丢了，这会不会导 致主备不一致呢？

回答：不会。因为这时候binlog 也还在binlog cache里，没发给备库。crash以后redo log和binlog 都没有了，从业务角度看这个事务也没有提交，所以数据是一致的。



问题4：如果binlog写完盘以后发生crash，这时候还没给客户端答复就重启了。等客户端再重连 进来，发现事务已经提交成功了，这是不是bug？

回答：不是。 你可以设想一下更极端的情况，整个事务都提交成功了，redo log commit完成了，备库也收到 binlog并执行了。但是主库和客户端网络断开了，导致事务成功的包返回不回去，这时候客户端 也会收到“网络断开”的异常。这种也只能算是事务成功的，不能认为是bug。



实际上数据库的crash-safe保证的是：

1. 如果客户端收到事务成功的消息，事务就一定持久化了； 
2. 如果客户端收到事务失败（比如主键冲突、回滚等）的消息，事务就一定失败了；
3. 如果客户端收到“执行异常”的消息，应用需要重连后通过查询当前状态来继续后续的逻辑。 此时数据库只需要保证内部（数据和日志之间，主库和备库之间）一致就可以了。



### 思考题

今天我留给你的思考题是：你的生产库设置的是“双1”吗？ 如果平时是的话，你有在什么场景下 改成过“非双1”吗？你的这个操作又是基于什么决定的？

另外，我们都知道这些设置可能有损，如果发生了异常，你的止损方案是什么？

> 回答

上期我留给你的问题是，你在什么时候会把线上生产库设置成“非双1”。

我目前知道的场景，有 以下这些： 

1. **业务高峰期**。一般如果有预知的高峰期，DBA会有预案，把主库设置成“非双1”。 
2. **备库延迟，为了让备库尽快赶上主库**。@永恒记忆和@Second Sight提到了这个场景。 
3. **用备份恢复主库的副本**，应用binlog的过程，这个跟上一种场景类似。 
4. **批量导入数据**的时候。

一般情况下，把生产库改成“非双1”配置，是设置innodb_flush_logs_at_trx_commit=2、 sync_binlog=1000。

> `innodb_flush_logs_at_trx_commit` 是 MySQL 中的一个参数，用于控制 InnoDB 存储引擎在事务提交时如何刷新日志到磁盘。
>
> 该参数有以下几个可选值：
>
> 1. **0**：表示事务提交时不进行日志刷新操作。这是最低的性能设置，但也是最不可靠的设置，因为在发生故障时可能会丢失最多一个事务的数据。
> 2. **1**：表示每次事务提交时都会将日志缓冲区的内容刷新到磁盘。这是默认设置，也是最常用的设置。它提供了最高的数据可靠性，但也会对性能产生一定的影响，因为每次提交都需要进行磁盘写入操作。
> 3. **2**：表示每次事务提交时会将日志缓冲区的内容刷新到磁盘，但是会将日志写入操作委托给操作系统进行异步处理。这种设置可以提供较高的性能，但在发生故障时可能会丢失最多一个事务的数据。



# 24 | MySQL是怎么保证主备一致的？

在前面的文章中，我不止一次地和你提到了binlog，大家知道binlog可以用来归档，也可以用来 做主备同步，但它的内容是什么样的呢？为什么备库执行了binlog就可以跟主库保持一致了呢？ 今天我就正式地和你介绍一下它。



毫不夸张地说，MySQL能够成为现下最流行的开源数据库，binlog功不可没。



在最开始，MySQL是以容易学习和**方便的高可用架构**，被开发人员青睐的。而它的几乎所有的 高可用架构，都直接依赖于binlog。虽然这些高可用架构已经呈现出越来越复杂的趋势，但都是 从最基本的一主一备演化过来的。



今天这篇文章我主要为你介绍主备的基本原理。理解了背后的设计原理，你也可以从业务开发的 角度，来借鉴这些设计思想。



## MySQL主备的基本原理

如图1所示就是基本的主备切换流程。

<img src="MYSQL实战45讲.assets/image-20250224122528594.png" alt="image-20250224122528594" style="zoom:50%;" />

在状态1中，客户端的读写都直接访问节点A，而节点B是A的备库，只是将A的更新都同步过 来，到本地执行。这样可以保持节点B和A的数据是相同的。

当需要切换的时候，就切成状态2。这时候客户端读写访问的都是节点B，而节点A是B的备库。



在状态1中，虽然节点B没有被直接访问，但是我依然建议你把节点B（也就是备库）设置成只读 （readonly）模式。这样做，有以下几个考虑：

1. 有时候一些运营类的查询语句会被放到备库上去查，设置为只读可以防止误操作；
2. 防止切换逻辑有bug，比如切换过程中出现双写，造成主备不一致；
3. 可以用readonly状态，来判断节点的角色。

你可能会问，我把备库设置成只读了，还怎么跟主库保持同步更新呢？

这个问题，你不用担心。因为r**eadonly设置对超级(super)权限用户是无效的，而用于同步更新的 线程，就拥有超级权限**。

接下来，我们再看看节点A到B这条线的内部流程是什么样的。图2中画出的就是一个update 语句在节点A执行，然后同步到节点B的完整流程图。

<img src="MYSQL实战45讲.assets/image-20250224122915398.png" alt="image-20250224122915398" style="zoom: 67%;" />

图2中，包含了我在上一篇文章中讲到的binlog和redo log的写入机制相关的内容，可以看到：主 库接收到客户端的更新请求后，执行内部事务的更新逻辑，**同时写binlog**。

备库B跟主库A之间维持了一个长连接。主库A内部有一个线程，专门用于服务备库B的这个长连 接。一个事务日志同步的完整过程是这样的：

1. 在备库B上通过**change master**命令，设置主库A的IP、端口、用户名、密码，以及要**从哪个位置开始请求binlog**，这个位置包含文件名和日志偏移量。 
2. 在备库B上执行**start slave**命令，这时候备库会启动两个线程，就是图中的**io_thread和 sql_thread**。其中io_thread负责与主库建立连接。 
3. 主库A校验完用户名、密码后，开始按照备库B传过来的位置，从本地读取binlog，发给B。 
4. 备库B拿到binlog后，写到本地文件，称为**中转日志（relay log，中继日志）**。 
5. sql_thread读取中转日志，解析出日志里的命令，并执行

这里需要说明，后来由于多线程复制方案的引入，sql_thread演化成为了多个线程，跟我们今天 要介绍的原理没有直接关系，暂且不展开。

分析完了这个长连接的逻辑，我们再来看一个问题：binlog里面到底是什么内容，为什么备库拿 过去可以直接执行。



## binlog的三种格式对比

我在第15篇答疑文章中，和你提到过binlog有两种格式，**一种是statement，一种是row**。

可能你在其他资料上还会看到有**第三种格式，叫作mixed**，其实它就是前两种格式的混合。

> 当binlog_format=statement时，binlog里面记录的就是SQL语句的原文。
>
> 



为了便于描述binlog的这三种格式间的区别，我创建了一个表，并初始化几行数据。

```sql
mysql> CREATE TABLE `t` (
    `id` int(11) NOTNULL,
    `a` int(11) DEFAULTNULL,
    `t_modified` timestamp NOTNULL DEFAULTCURRENT_TIMESTAMP,
    PRIMARY KEY (`id`),
    KEY `a` (`a`),
    KEY `t_modified`(`t_modified`)
) ENGINE=InnoDB;
insert into t values(1,1,'2018-11-13');
insert into t values(2,2,'2018-11-12');
insert into t values(3,3,'2018-11-11');
insert into t values(4,4,'2018-11-10');
insert into t values(5,5,'2018-11-09');
```

如果要在表中删除一行数据的话，我们来看看这个delete语句的binlog是怎么记录的。

注意，下面这个语句包含注释，如果你用MySQL客户端来做这个实验的话，要记得加-c参数，否 则客户端会自动去掉注释。

```sql
mysql> delete from t /*comment*/ where a>=4 and t_modified<='2018-11-10' limit 1;
```



当binlog_format=statement时，binlog里面记录的就是SQL语句的原文。

你可以用命令看binlog中的内容。

```sql
mysql> show binlog events in 'master.000001';

==》
mysql> show binlog events in 'mysql-bin.000007' limit 1;
+------------------+-----+-------------+-----------+-------------+-----------------------------------------+
| Log_name         | Pos | Event_type  | Server_id | End_log_pos | Info                                    |
+------------------+-----+-------------+-----------+-------------+-----------------------------------------+
| mysql-bin.000007 |   4 | Format_desc |    784033 |         126 | Server ver: 8.0.30-txsql, Binlog ver: 4 |
+------------------+-----+-------------+-----------+-------------+-----------------------------------------+
1 row in set (0.00 sec)
```

<img src="MYSQL实战45讲.assets/image-20250224144017189.png" alt="image-20250224144017189" style="zoom: 67%;" />

现在，我们来看一下图3的输出结果。

- 第一行SET@@SESSION.GTID_NEXT='ANONYMOUS’  （匿名）你可以先忽略，后面文章我们会在 介绍主备切换的时候再提到； 
- 第二行是一个BEGIN，跟第四行的commit对应，表示中间是一个事务； 
- 第三行就是真实执行的语句了。可以看到，在真实执行的delete命令之前，还有一个“use ‘test’”命令。这条命令不是我们主动执行的，而是MySQL根据当前要操作的表所在的数据库， 自行添加的。这样做可以保证日志传到备库去执行的时候，不论当前的工作线程在哪个库里，都能够正确地更新到test库的表t。 use 'test’命令之后的delete 语句，就是我们输入的SQL原文了。**可以看到，binlog“忠实”地记 录了SQL命令，甚至连注释也一并记录了**。 
- 最后一行是一个COMMIT。你可以看到里面写着xid=61。你还记得这个XID是做什么用的吗？ 如果记忆模糊了，可以再回顾一下第15篇文章中的相关内容。



为了说明statement 和 row格式的区别，我们来看一下这条delete命令的执行效果图：

<img src="MYSQL实战45讲.assets/image-20250224144544254.png" alt="image-20250224144544254" style="zoom: 67%;" />

可以看到，运行这条delete命令产生了一个warning，原因是当前binlog设置的是statement格 式，并且语句中有limit，所以这个命令可能是unsafe的。

为什么这么说呢？这是因为delete 带limit，很可能会出现主备数据不一致的情况。比如上面这个例子：

1. 如果delete语句使用的是索引a，那么会根据索引a找到第一个满足条件的行，也就是说删除 的是a=4这一行；
2. 但如果使用的是索引t_modified，那么删除的就是 t_modified='2018-11-09’也就是a=5这一 行。

由于statement格式下，记录到binlog里的是语句原文，因此可能会出现这样一种情况：在主库 执行这条SQL语句的时候，用的是索引a；而在备库执行这条SQL语句的时候，却使用了索引 t_modified。因此，MySQL认为这样写是有风险的。



那么，如果我把binlog的格式改为binlog_format=‘row’， 是不是就没有这个问题了呢？我们先来看看这时候binog中的内容吧。

<img src="MYSQL实战45讲.assets/image-20250224144923069.png" alt="image-20250224144923069" style="zoom:67%;" />

可以看到，与statement格式的binlog相比，前后的BEGIN和COMMIT是一样的。

但是，row格式 的binlog里没有了SQL语句的原文，而是替换成了**两个event：Table_map和Delete_rows**。

1. Table_map event，用于说明接下来要操作的表是test库的表t; 
2. Delete_rows event，用于定义删除的行为。

其实，我们通过图5是看不到详细信息的，还需要借助mysqlbinlog工具，用下面这个命令解析和 查看binlog中的内容。因为图5中的信息显示，这个事务的binlog是从8900这个位置开始的，所以 可以用start-position参数来指定从这个位置的日志开始解析。

```sql
mysqlbinlog -w data/master.000001 --start-position=8900;

==》8.0 新版本 没有-w
mysqlbinlog -h remote_host -u username -p -P port_number  data/master.000001 --start-position=760;
```

<img src="MYSQL实战45讲.assets/image-20250224150115588.png" alt="image-20250224150115588" style="zoom:67%;" />

从这个图中，我们可以看到以下几个信息：

- server id 1，表示这个事务是在server_id=1的这个库上执行的。 
- 每个event都有CRC32的值，这是因为我把参数binlog_checksum设置成了CRC32。
- Table_map event跟在图5中看到的相同，显示了接下来要打开的表，map到数字226。现在我 们这条SQL语句只操作了一张表，如果要操作多张表呢？每个表都有一个对应的Table_map event、都会map到一个单独的数字，用于区分对不同表的操作。
- 我们在mysqlbinlog的命令中，使用了-vv参数是为了把内容都解析出来，所以从结果里面可以 看到各个字段的值（比如，@1=4、 @2=4这些值）。
- binlog_row_image的默认配置是FULL，因此Delete_event里面，包含了删掉的行的所有字段 的值。如果把binlog_row_image设置为MINIMAL，则只会记录必要的信息，在这个例子里， 就是只会记录id=4这个信息。
- 最后的Xid event，用于表示事务被正确地提交了。

你可以看到，当binlog_format使用row格式的时候，binlog里面记录了真实删除行的主键id，这样 binlog传到备库去的时候，就肯定会删除id=4的行，不会有主备删除不同行的问题。



## 为什么会有mixed格式的binlog？

基于上面的信息，我们来讨论一个问题：为什么会有mixed这种binlog格式的存在场景？

推论过程是这样的：

- 因为有些statement格式的binlog可能会导致主备不一致，所以要使用row格式。 
- 但row格式的缺点是，很占空间。比如你用一个delete语句删掉10万行数据，用statement的 话就是一个SQL语句被记录到binlog中，占用几十个字节的空间。但如果用row格式的binlog， 就要把这10万条记录都写到binlog中。这样做，不仅会占用更大的空间，同时写binlog也要耗 费IO资源，影响执行速度。
- 所以，MySQL就取了个折中方案，也就是有了mixed格式的binlog。mixed格式的意思 是，MySQL自己会判断这条SQL语句是否可能引起主备不一致，如果有可能，就用row格式， 否则就用statement格式。

也就是说，mixed格式可以利用statment格式的优点，同时又避免了数据不一致的风险。

因此，如果你的线上MySQL设置的binlog格式是statement的话，那基本上就可以认为这是一个 不合理的设置。你至少应该把binlog的格式设置为mixed。

比如我们这个例子，设置为mixed后，就会记录为row格式；而如果执行的语句去掉limit 1，就会 记录为statement格式。



**当然我要说的是，现在越来越多的场景要求把MySQL的binlog格式设置成row**。这么做的理由有 很多，我来给你举**一个可以直接看出来的好处：恢复数据**。



接下来，我们就分别从delete、insert和update这三种SQL语句的角度，来看看数据恢复的问题。

- 通过图6你可以看出来，即使我执行的是delete语句，row格式的binlog也会把被删掉的行的整行 信息保存起来。所以，如果你在执行完一条delete语句以后，发现删错数据了，可以直接把 binlog中记录的delete语句转成insert，把被错删的数据插入回去就可以恢复了。
- 如果你是执行错了insert语句呢？那就更直接了。row格式下，insert语句的binlog里会记录所有的 字段信息，这些信息可以用来精确定位刚刚被插入的那一行。这时，你直接把insert语句转成 delete语句，删除掉这被误插入的一行数据就可以了。
- 如果执行的是update语句的话，binlog里面会记录修改前整行的数据和修改后的整行数据。所 以，如果你误执行了update语句的话，只需要把这个event前后的两行信息对调一下，再去数据 库里面执行，就能恢复这个更新操作了。

其实，由delete、insert或者update语句导致的数据操作错误，需要恢复到操作之前状态的情 况，也时有发生。MariaDB的Flashback工具就是基于上面介绍的原理来回滚数据的。



虽然mixed格式的binlog现在已经用得不多了，但这里我还是要再借用一下mixed格式来说明一个 问题，来看一下这条SQL语句：

```sql
mysql> insert into t values(10,10, now());
```

如果我们把binlog格式设置为mixed，你觉得MySQL会把它记录为**row格式**还是statement格式呢？



先不要着急说结果，我们一起来看一下这条语句执行的效果。

<img src="MYSQL实战45讲.assets/image-20250224151013305.png" alt="image-20250224151013305" style="zoom: 67%;" />

可以看到，**MySQL用的居然是statement格式**。你一定会奇怪，如果这个binlog过了1分钟才传给 备库的话，那主备的数据不就不一致了吗？

接下来，我们再用mysqlbinlog工具来看看：

<img src="MYSQL实战45讲.assets/image-20250224151055346.png" alt="image-20250224151055346" style="zoom: 67%;" />

从图中的结果可以看到，原来binlog在记录event的时候，多记了一条命令：SET TIMESTAMP=1546103491。它用 SETTIMESTAMP命令约定了接下来的now()函数的返回时间。



因此，不论这个binlog是1分钟之后被备库执行，还是3天后用来恢复这个库的备份，这个insert 语句插入的行，值都是固定的。也就是说，通过这条SETTIMESTAMP命令，MySQL就确保了 主备数据的一致性。



我之前看过有人在重放binlog数据的时候，是这么做的：用mysqlbinlog解析出日志，然后把里面 的statement语句直接拷贝出来执行。

你现在知道了，这个方法是有风险的。因为有些语句的执行结果是依赖于上下文命令的，直接执 行的结果很可能是错误的。 所以，用binlog来恢复数据的标准做法是，用 mysqlbinlog工具解析出来，然后把解析结果整个发 给MySQL执行。类似下面的命令：

```sql
mysqlbinlog master.000001 --start-position=2738 --stop-position=2973 | mysql -h127.0.0.1 -P13000 -u$user -p$pwd
```

这个命令的意思是，将 master.000001 文件里面从**第2738字节**到第2973字节中间这段内容解析 出来，放到MySQL去执行。



## 循环复制问题

通过上面对MySQL中binlog基本内容的理解，你现在可以知道，binlog的特性确保了在备库执行 相同的binlog，可以得到与主库相同的状态。

因此，我们可以认为正常情况下主备的数据是一致的。也就是说，图1中A、B两个节点的内容是 一致的。其实，图1中我画的是M-S结构，但实际生产上使用比较多的是**双M结构**，也就是图9所 示的主备切换流程。

<img src="MYSQL实战45讲.assets/image-20250224151535792.png" alt="image-20250224151535792" style="zoom: 50%;" />

对比图9和图1，你可以发现，**双M结构和M-S结构，其实区别只是多了一条线，即：节点A和B 之间总是互为主备关系。这样在切换的时候就不用再修改主备关系**。



但是，双M结构还有一个问题需要解决。

业务逻辑在节点A上更新了一条语句，然后再把生成的binlog 发给节点B，节点B执行完这条更新 语句后也会生成binlog。（我建议你把参数log_slave_updates设置为on，表示备库执行relay log 后生成binlog）。



那么，如果节点A同时是节点B的备库，相当于又把节点B新生成的binlog拿过来执行了一次，然 后节点A和B间，会不断地循环执行这个更新语句，也就是循环复制了。这个要怎么解决呢？



从上面的图6中可以看到，**MySQL在binlog中记录了这个命令第一次执行时所在实例的server id**。因此，我们可以用下面的逻辑，来解决两个节点间的循环复制的问题：

1. 规定两个库的server id必须不同，如果相同，则它们之间不能设定为主备关系； 
2. 一个备库接到binlog并在重放的过程中，生成与原binlog的server id相同的新的binlog； 
3. 每个库在收到从自己的主库发过来的日志后，先判断server id，如果跟自己的相同，表示这 个日志是自己生成的，就直接丢弃这个日志。



按照这个逻辑，如果我们设置了双M结构，日志的执行流就会变成这样：

1. 从节点A更新的事务，binlog里面记的都是A的server id； 
2. 传到节点B执行一次以后，节点B生成的binlog 的server id也是A的server id； 
3. 再传回给节点A，A判断到这个server id与自己的相同，就不会再处理这个日志。所以，死循 环在这里就断掉了。



## 小结

今天这篇文章，我给你介绍了MySQL binlog的格式和一些基本机制，是后面我要介绍的读写分 离等系列文章的背景知识，希望你可以认真消化理解。

binlog在MySQL的各种高可用方案上扮演了重要角色。今天介绍的可以说是所有MySQL高可用 方案的基础。在这之上演化出了诸如多节点、半同步、MySQL group replication等相对复杂的方案。

我也跟你介绍了MySQL不同格式binlog的优缺点，和设计者的思考。希望你在做系统开发时候， 也能借鉴这些设计思想。



### 思考题

说到循环复制问题的时候，我们说MySQL通过判断server id的方式，断掉死循环。但是，这个机 制其实并不完备，在某些场景下，还是有可能出现死循环。 你能构造出一个这样的场景吗？又应该怎么解决呢？

> 回答

上期我留给你的问题是，什么情况下双M结构会出现循环复制。

一种场景是，在一个主库更新事务后，用命令set global server_id=x修改了server_id。等日志再 传回来的时候，发现server_id跟自己的server_id不同，就只能执行了。



另一种场景是，有三个节点的时候，如图7所示，trx1是在节点 B执行的，因此binlog上的 server_id就是B，binlog传给节点 A，然后A和A’搭建了双M结构，就会出现循环复制。

<img src="MYSQL实战45讲.assets/image-20250224152059301.png" alt="image-20250224152059301" style="zoom:67%;" />



这种三节点复制的场景，做数据库迁移的时候会出现。

如果出现了循环复制，可以在A或者A’上，执行如下命令：

```sql
stop slave；
CHANGE MASTER TO IGNORE_SERVER_IDS=(server_id_of_B);
start slave;
```

这样这个节点收到日志后就不会再执行。过一段时间后，再执行下面的命令把这个值改回来。

```sql
stop slave；
CHANGE MASTER TO IGNORE_SERVER_IDS=();
start slave;
```





# 25 | MySQL是怎么保证高可用的？

在上一篇文章中，我和你介绍了binlog的基本内容，在一个主备关系中，每个备库接收主库的 binlog并执行。

正常情况下，只要主库执行更新生成的所有binlog，都可以传到备库并被正确地执行，备库就能 达到跟主库一致的状态，这就是最终一致性。

但是，MySQL要提供高可用能力，只有最终一致性是不够的。为什么这么说呢？今天我就着重 和你分析一下。



这里，我再放一次上一篇文章中讲到的双M结构的主备切换流程图。

<img src="MYSQL实战45讲.assets/image-20250224161131666.png" alt="image-20250224161131666" style="zoom: 67%;" />



## 主备延迟

主备切换可能是一个主动运维动作，比如软件升级、主库所在机器按计划下线等，也可能是被动 操作，比如主库所在机器掉电。

接下来，我们先一起看看主动切换的场景。



在介绍主动切换流程的详细步骤之前，我要先跟你说明一个概念，即“同步延迟”。与数据同步有 关的时间点主要包括以下三个：

1. 主库A执行完成一个事务，写入binlog，我们把这个时刻记为T1;
2. 之后传给备库B，我们把备库B接收完这个binlog的时刻记为T2;
3. 备库B执行完成这个事务，我们把这个时刻记为T3。

所谓主备延迟，就是同一个事务，在备库执行完成的时间和主库执行完成的时间之间的差值，也 就是T3-T1。



你可以在备库上执行show slave status命令，它的返回结果里面会显示:seconds_behind_master，用于表示当前备库延迟了多少秒。



seconds_behind_master的计算方法是这样的：

1. 每个事务的binlog 里面都有一个时间字段，用于记录主库上写入的时间；
2. 备库取出当前正在执行的事务的时间字段的值，计算它与当前系统时间的差值，得到 seconds_behind_master。

可以看到，其实seconds_behind_master这个参数计算的就是T3-T1。所以，我们可以用 seconds_behind_master来作为主备延迟的值，这个值的时间精度是秒。

你可能会问，如果主备库机器的系统时间设置不一致，会不会导致主备延迟的值不准？

其实不会的。因为，备库连接到主库的时候，会通过执行SELECTUNIX_TIMESTAMP()函数来 获得当前主库的系统时间。如果这时候发现主库的系统时间与自己不一致，备库在执行 seconds_behind_master计算的时候会自动扣掉这个差值。

需要说明的是，**在网络正常的时候，日志从主库传给备库所需的时间是很短的，即T2-T1的值是 非常小的**。也就是说，网络正常情况下，主备延迟的主要来源是备库接收完binlog和执行完这个 事务之间的时间差。

所以说，主备延迟最直接的表现是，备库消费中转日志（relay log）的速度，比主库生产binlog 的速度要慢。接下来，我就和你一起分析下，这可能是由哪些原因导致的。



## 主备延迟的来源

首先，有些部署条件下，备库所在机器的性能要比主库所在的机器性能差。

一般情况下，有人这么部署时的想法是，反正备库没有请求，所以可以用差一点儿的机器。或 者，他们会把20个主库放在4台机器上，而把备库集中在一台机器上。

其实我们都知道，更新请求对IOPS的压力，在主库和备库上是无差别的。所以，做这种部署 时，一般都会将备库设置为“非双1”的模式。

但实际上，更新过程中也会触发大量的读操作。所以，当备库主机上的多个备库都在争抢资源的 时候，就可能会导致主备延迟了。

当然，这种部署现在比较少了。因为主备可能发生切换，备库随时可能变成主库，所以**主备库选用相同规格的机器，并且做对称部署，是现在比较常见的情况**。



> 追问1：但是，做了对称部署以后，还可能会有延迟。这是为什么呢？

**这就是第二种常见的可能了，即备库的压力大**。一般的想法是，主库既然提供了写能力，那么 备库可以提供一些读能力。或者一些运营后台需要的分析语句，不能影响正常业务，所以只能在 备库上跑。



我真就见过不少这样的情况。由于主库直接影响业务，大家使用起来会比较克制，反而忽视了备 库的压力控制。结果就是，备库上的查询耗费了大量的CPU资源，影响了同步速度，造成主备延迟。



这种情况，我们一般可以这么处理：

1. 一主多从。除了备库外，可以多接几个从库，让这些从库来分担读的压力。
2. 通过binlog输出到外部系统，比如Hadoop这类系统，让外部系统提供统计类查询的能力。

其中，一主多从的方式大都会被采用。因为**作为数据库系统，还必须保证有定期全量备份的能 力。而从库，就很适合用来做备份**。

> 备注：这里需要说明一下，从库和备库在概念上其实差不多。在我们这个专栏里，为了方便描 述，我把会在HA过程中被选成新主库的，称为备库，其他的称为从库。



> 追问2：采用了一主多从，保证备库的压力不会超过主库，还有什么情况可能导致主备延迟吗？

这就是第三种可能了，即**大事务**。 

大事务这种情况很好理解。因为主库上必须等事务执行完成才会写入binlog，再传给备库。所 以，如果一个主库上的语句执行10分钟，那这个事务很可能就会导致从库延迟10分钟。

不知道你所在公司的DBA有没有跟你这么说过：不要一次性地用delete语句删除太多数据。其 实，这就是一个典型的大事务场景。



比如，一些归档类的数据，平时没有注意删除历史数据，等到空间快满了，业务开发人员要一次 性地删掉大量历史数据。

同时，**又因为要避免在高峰期操作会影响业务（至少有这个意识还是很 不错的），所以会在晚上执行这些大量数据的删除操作**。

结果，负责的DBA同学半夜就会收到延迟报警。然后，DBA团队就要求你后续再删除数据的时 候，要控制每个事务删除的数据量，分成多次删除。



另一种典型的大事务场景，就是大表DDL。这个场景，我在前面的文章中介绍过。处理方案 就是，计划内的DDL，建议使用gh-ost方案（这里，你可以再回顾下第13篇文章《为什么表数据 删掉一半，表文件大小不变？》中的相关内容）。

> DDL（Data Definition Language）是指用于定义和管理数据库结构的语句。它用于创建、修改和删除数据库对象，例如表、索引、视图、触发器等。
>
> 常见的 MySQL DDL 语句包括：
>
> - `CREATE`：用于创建数据库、表、视图、索引等对象。
> - `ALTER`：用于修改数据库对象的结构，例如添加、修改或删除列、约束等。
> - `DROP`：用于删除数据库对象，例如删除表、视图、索引等。
> - `TRUNCATE`：用于快速删除表中的所有数据，但保留表结构。
> - `RENAME`：用于重命名数据库对象，例如重命名表、列等。
> - `GRANT`：用于授予用户或角色访问数据库对象的权限。
> - `REVOKE`：用于撤销用户或角色对数据库对象的访问权限。
>
> ### **DDL 与 DML 的区别**
>
> - **DDL（数据定义语言）**：用于定义和管理数据库结构（如表、索引等）。
>   - 示例：`CREATE`、`ALTER`、`DROP`。
> - **DML（数据操作语言）**：用于操作数据库中的数据（如插入、更新、删除等）。
>   - 示例：`INSERT`、`UPDATE`、`DELETE`。
> - **DQL（数据查询语言）**：用于查询数据库中的数据。
>   - 示例：`SELECT`。
> - **DCL（数据控制语言）**：用于控制数据库访问权限。
>   - 示例：`GRANT`、`REVOKE`。





> 追问3：如果主库上也不做大事务了，还有什么原因会导致主备延迟吗？

造成主备延迟还有一个大方向的原因，就是**备库的并行复制能力**。这个话题，我会留在下一篇 文章再和你详细介绍。



## 主备切换时的策略

其实还是有不少其他情况会导致主备延迟，如果你还碰到过其他场景，欢迎你在评论区给我留 言，我来和你一起分析、讨论。 由于主备延迟的存在，所以在主备切换的时候，就相应的有不同的策略。

### 可靠性优先策略

在图1的双M结构下，从状态1到状态2切换的详细过程是这样的： 

1. 判断备库B现在的seconds_behind_master，如果小于某个值（比如5秒）继续下一步，否则 持续重试这一步； 
2. 把主库A改成只读状态，即把readonly设置为true； 
3. 判断备库B的seconds_behind_master的值，直到这个值变成0为止； 
4. 把备库B改成可读写状态，也就是把readonly设置为false； 
5. 把业务请求切到备库B。



这个切换流程，一般是由专门的HA系统来完成的，我们暂时称之为可靠性优先流程。

<img src="MYSQL实战45讲.assets/image-20250224163147352.png" alt="image-20250224163147352" style="zoom:50%;" />

备注：图中的SBM，是seconds_behind_master参数的简写。



可以看到，这个切换流程中是有不可用时间的。因为在步骤2之后，主库A和备库B都处于 readonly状态，也就是说这时系统处于不可写状态，直到步骤5完成后才能恢复。

在这个不可用状态中，比较耗费时间的是步骤3，可能需要耗费好几秒的时间。这也是为什么需 要在步骤1先做判断，确保seconds_behind_master的值足够小。

试想如果一开始主备延迟就长达30分钟，而不先做判断直接切换的话，系统的不可用时间就会 长达30分钟，这种情况一般业务都是不可接受的。

当然，系统的不可用时间，是由这个数据可靠性优先的策略决定的。你也可以选择可用性优先的 策略，来把这个不可用时间几乎降为0。



### 可用性优先策略

如果我强行把步骤4、5调整到最开始执行，也就是说不等主备数据同步，直接把连接切到备库 B，并且让备库B可以读写，那么系统几乎就没有不可用时间了。

我们把这个切换流程，暂时称作可用性优先流程。这个切换流程的代价，就是可能出现数据不一 致的情况。

接下来，我就和你分享一个可用性优先流程产生数据不一致的例子。假设有一个表 t：

```sql
mysql> CREATE TABLE `t` (
    `id` int(11) unsigned NOTNULLAUTO_INCREMENT,
    `c` int(11) unsigned DEFAULTNULL,
    PRIMARY KEY (`id`)
) ENGINE=InnoDB;
insert into t(c) values(1),(2),(3);
```

这个表定义了一个自增主键id，初始化数据后，主库和备库上都是3行数据。接下来，业务人员 要继续在表t上执行两条插入语句的命令，依次是：

```
insert into t(c) values(4);
insert into t(c) values(5);
```

假设，现在主库上其他的数据表有大量的更新，导致主备延迟达到5秒。在插入一条c=4的语句后，发起了主备切换。

图3是可用性优先策略，且binlog_format=mixed时的切换流程和数据结果。

<img src="MYSQL实战45讲.assets/image-20250224163556694.png" alt="image-20250224163556694" style="zoom: 67%;" />

现在，我们一起分析下这个切换流程： 

1. 步骤2中，主库A执行完insert语句，插入了一行数据（4,4），之后开始进行主备切换。 
2. 步骤3中，由于主备之间有5秒的延迟，所以备库B还没来得及应用“插入c=4”这个中转日志， 就开始接收客户端“插入 c=5”的命令。 
3. 步骤4中，备库B插入了一行数据（4,5），并且把这个binlog发给主库A。 
4. 步骤5中，备库B执行“插入c=4”这个中转日志，插入了一行数据（5,4）。而直接在备库B执 行的“插入c=5”这个语句，传到主库A，就插入了一行新数据（5,5）。

最后的结果就是，主库A和备库B上出现了两行不一致的数据。可以看到，这个数据不一致，是 由可用性优先流程导致的。



那么，如果我还是用可用性优先策略，但设置binlog_format=row，情况又会怎样呢？

因为row格式在记录binlog的时候，会记录新插入的行的所有字段值，所以最后只会有一行不一 致。而且，两边的主备同步的应用线程会报错duplicate keyerror并停止。也就是说，这种情况 下，备库B的(5,4)和主库A的(5,5)这两行数据，都不会被对方执行。

图4中我画出了详细过程，你可以自己再分析一下。

<img src="MYSQL实战45讲.assets/image-20250224163910855.png" alt="image-20250224163910855" style="zoom: 67%;" />



从上面的分析中，你可以看到一些结论：

1. 使用row格式的binlog时，数据不一致的问题更容易被发现。而使用mixed或者statement格式的binlog时，数据很可能悄悄地就不一致了。如果你过了很久才发现数据不一致的问题， 很可能这时的数据不一致已经不可查，或者连带造成了更多的数据逻辑不一致。 
2. 主备切换的可用性优先策略会导致数据不一致。因此，大多数情况下，我都建议你使用可靠 性优先策略。毕竟对数据服务来说的话，数据的可靠性一般还是要优于可用性的。



但事无绝对，有没有哪种情况数据的可用性优先级更高呢？

答案是，有的。

我曾经碰到过这样的一个场景：

- 有一个库的作用是记录操作日志。这时候，如果数据不一致可以通过binlog来修补，而这个短 暂的不一致也不会引发业务问题。
- 同时，业务系统依赖于这个日志写入逻辑，如果这个库不可写，会导致线上的业务操作无法执行。

这时候，你可能就需要选择先强行切换，事后再补数据的策略。

当然，事后复盘的时候，我们想到了一个改进措施就是，让业务逻辑不要依赖于这类日志的写 入。也就是说，日志写入这个逻辑模块应该可以降级，比如写到本地文件，或者写到另外一个临 时库里面。

这样的话，这种场景就又可以使用可靠性优先策略了。



**接下来我们再看看，按照可靠性优先的思路，异常切换会是什么效果**？

假设，主库A和备库B间的主备延迟是30分钟，这时候主库A掉电了，HA系统要切换B作为主库。我们在主动切换的时候，可以等到主备延迟小于5秒的时候再启动切换，但这时候已经别无选择了。

<img src="MYSQL实战45讲.assets/image-20250224164500717.png" alt="image-20250224164500717" style="zoom:67%;" />



采用可靠性优先策略的话，你就必须得等到备库B的seconds_behind_master=0之后，才能切 换。但现在的情况比刚刚更严重，并不是系统只读、不可写的问题了，而是系统处于完全不可用 的状态。因为，主库A掉电后，我们的连接还没有切到备库B。

你可能会问，那能不能直接切换到备库B，但是保持B只读呢？ 这样也不行。

因为，这段时间内，中转日志还没有应用完成，如果直接发起主备切换，客户端查询看不到之前 执行完成的事务，会认为有“数据丢失”。

虽然随着中转日志的继续应用，这些数据会恢复回来，但是对于一些业务来说，查询到“暂时丢 失数据的状态”也是不能被接受的。(钱相关的数据)



聊到这里你就知道了，**在满足数据可靠性的前提下，MySQL高可用系统的可用性，是依赖于主备延迟的。延迟的时间越小，在主库故障的时候，服务恢复需要的时间就越短，可用性就越高**。



## 小结

今天这篇文章，我先和你介绍了MySQL高可用系统的基础，就是主备切换逻辑。紧接着，我又 和你讨论了几种会导致主备延迟的情况，以及相应的改进方向。



然后，由于主备延迟的存在，切换策略就有不同的选择。所以，我又和你一起分析了可靠性优先 和可用性优先策略的区别。



在实际的应用中，我更建议使用可靠性优先的策略。毕竟保证数据准确，应该是数据库服务的底 线。在这个基础上，通过减少主备延迟，提升系统的可用性。



> 思考题

一般现在的数据库运维系统都有备库延迟监控，其实就是在备库上执行 showslave status，采集 seconds_behind_master的值。

假设，现在你看到你维护的一个备库，它的延迟监控的图像类似图6，是一个45°斜向上的线段， 你觉得可能是什么原因导致呢？你又会怎么去确认这个原因呢？

<img src="MYSQL实战45讲.assets/image-20250224164854785.png" alt="image-20250224164854785" style="zoom: 50%;" />

（主库挂了？）

> 回答

上期的问题是，什么情况下，备库的主备延迟会表现为一个45度的线段？评论区有不少同学的 回复都说到了重点：备库的同步在这段时间完全被堵住了。

产生这种现象典型的场景主要包括两种：

- 一种是大事务（包括大表DDL、一个事务操作很多行）；
- 还有一种情况比较隐蔽，就是备库起了一个长事务，比如

```
begin;
select * from t limit 1;
```

然后就不动了。

这时候主库对表t做了一个加字段操作，即使这个表很小，这个DDL在备库应用的时候也会被堵住，也~~不~~能看到这个现象。



评论区还有同学说是不是**主库多线程、从库单线程，备库跟不上主库的更新节奏导致的**？今天这篇文章，我们刚好讲的是并行复制。所以，你知道了，这种情况会导致主备延迟，但**不会表现为这种标准的呈45度的直线**。



# 26 | 备库为什么会延迟好几个小时？

在上一篇文章中，我和你介绍了几种可能导致备库延迟的原因。你会发现，这些场景里，不论是 偶发性的查询压力，还是备份，对备库延迟的影响一般是分钟级的，而且在备库恢复正常以后都 能够追上来。



但是，如果备库执行日志的速度持续低于主库生成日志的速度，那这个延迟就有可能成了小时级 别。而且对于一个压力持续比较高的主库来说，备库很可能永远都追不上主库的节奏。(有点像MQ的生产与消费不匹配)



这就涉及到今天我要给你介绍的话题：备库并行复制能力。

为了便于你理解，我们再一起看一下第24篇文章《MySQL是怎么保证主备一致的？》的主备流程图。

<img src="MYSQL实战45讲.assets/image-20250224165533469.png" alt="image-20250224165533469" style="zoom:50%;" />

谈到主备的并行复制能力，我们要关注的是图中黑色的两个箭头。一个箭头代表了客户端写入主 库，另一箭头代表的是备库上sql_thread执行中转日志（relay log）。如果用箭头的粗细来代表 并行度的话，那么真实情况就如图1所示，第一个箭头要明显粗于第二个箭头。

**在主库上，影响并发度的原因就是各种锁了**。

由于InnoDB引擎**支持行锁**，除了所有并发事务都 在更新同一行（热点行）这种极端场景外，它对业务并发度的支持还是很友好的。所以，你在性 能测试的时候会发现，并发压测线程32就比单线程时，总体吞吐量高。

而日志在备库上的执行，就是图中备库上sql_thread更新数据(DATA)的逻辑。如果是用单线程的 话，就会导致备库应用日志不够快，造成主备延迟。

**在官方的5.6版本之前，MySQL只支持单线程复制，由此在主库并发高、TPS高时就会出现严重的主备延迟问题**。



从单线程复制到最新版本的多线程复制，中间的演化经历了好几个版本。接下来，我就跟你说说 MySQL多线程复制的演进过程。

其实说到底，所有的多线程复制机制，都是要把图1中只有一个线程的sql_thread，拆成多个线 程，也就是都符合下面的这个模型：

<img src="MYSQL实战45讲.assets/image-20250224165746623.png" alt="image-20250224165746623" style="zoom:50%;" />

图2中，**coordinator（协调者）**就是原来的**sql_thread**, 不过现在它不再直接更新数据了，只负责读取中转日 志和分发事务。真正更新日志的，变成了**worker线程**。

而work线程的个数，就是由参数 slave_parallel_workers决定的。根据我的经验，把这个值设置为8~16之间最好（32核物理机的 情况），毕竟备库还有可能要提供读查询，不能把CPU都吃光了。

接下来，你需要先思考一个问题：**事务能不能按照轮询的方式分发给各个worker**，也就是第一个 事务分给worker_1，第二个事务发给worker_2呢？

其实是**不行的**。因为，事务被分发给worker以后，不同的worker就独立执行了。但是，由于CPU 的调度策略，很可能第二个事务最终比第一个事务先执行。而如果这时候刚好这两个事务更新的 是同一行，也就意味着，同一行上的两个事务，在主库和备库上的执行顺序相反，会导致主备不 一致的问题。



接下来，请你再设想一下另外一个问题：**同一个事务的多个更新语句，能不能分给不同的worker 来执行呢**？

答案是，**也不行**。举个例子，一个事务更新了表t1和表t2中的各一行，如果这两条更新语句被分 到不同worker的话，虽然最终的结果是主备一致的，但如果表t1执行完成的瞬间，备库上有一个 查询，就会看到这个事务“更新了一半的结果”，**破坏了事务逻辑的隔离性**。



所以，coordinator在分发的时候，需要满足以下这两个基本要求：

1. 不能造成更新覆盖。这就要求更新同一行的两个事务，必须被分发到同一个worker中。 
2. 同一个事务不能被拆开，必须放到同一个worker中。

各个版本的多线程复制，都遵循了这两条基本原则。接下来，我们就看看各个版本的并行复制策略。



## MySQL 5.5版本的并行复制策略

官方MySQL 5.5版本是不支持并行复制的。但是，在2012年的时候，我自己服务的业务出现了 严重的主备延迟，原因就是备库只有单线程复制。然后，我就先后写了两个版本的并行策略。

这里，我给你介绍一下这两个版本的并行策略，即按表分发策略和按行分发策略，以帮助你理解 MySQL官方版本并行复制策略的迭代。



### 按表分发策略

按表分发事务的基本思路是，如果两个事务更新不同的表，它们就可以并行。因为数据是存储在 表里的，所以按表分发，可以保证两个worker不会更新同一行。

当然，如果有跨表的事务，还是要把两张表放在一起考虑的。如图3所示，就是按表分发的规则。

<img src="MYSQL实战45讲.assets/image-20250224170440726.png" alt="image-20250224170440726" style="zoom:50%;" />

可以看到，每个worker线程对应一个hash表，用于保存当前正在这个worker的“执行队列”里的事 务所涉及的表。hash表的key是“库名.表名”，value是一个数字，表示队列中有多少个事务修改这个表。

在有事务分配给worker时，事务里面涉及的表会被加到对应的hash表中。worker执行完成后，这 个表会被从hash表中去掉。



图3中，hash_table_1表示，现在worker_1的“待执行事务队列”里，有4个事务涉及到db1.t1表， 有1个事务涉及到db2.t2表；hash_table_2表示，现在worker_2中有一个事务会更新到表t3的数 据。



假设在图中的情况下，coordinator从中转日志中读入一个新事务T，这个事务修改的行涉及到表 t1和t3。

现在我们用事务T的分配流程，来看一下分配规则。

1. 由于事务T中涉及修改表t1，而worker_1队列中有事务在修改表t1，事务T和队列中的某个事 务要修改同一个表的数据，这种情况我们说事务T和worker_1是冲突的。 
2. 按照这个逻辑，顺序判断事务T和每个worker队列的冲突关系，会发现事务T跟worker_2也冲突。 
3. 事务T跟多于一个worker冲突，coordinator线程就进入等待。 
4. 每个worker继续执行，同时修改hash_table。假设hash_table_2里面涉及到修改表t3的事务先执行完成，就会从hash_table_2中把db1.t3这一项去掉。
5. 这样coordinator会发现跟事务T冲突的worker只有worker_1了，因此就把它分配给 worker_1。
6. coordinator继续读下一个中转日志，继续分配事务。

也就是说，每个事务在分发的时候，跟所有worker的冲突关系包括以下三种情况：

1. 如果跟所有worker都不冲突，coordinator线程就会把这个事务分配给最空闲的woker; 
2. 如果跟多于一个worker冲突，coordinator线程就进入等待状态，直到和这个事务存在冲突关 系的worker只剩下1个； 
3. 如果只跟一个worker冲突，coordinator线程就会把这个事务分配给这个存在冲突关系的 worker。

这个按表分发的方案，在多个表负载均匀的场景里应用效果很好。但是，如果碰到热点表，比如 所有的更新事务都会涉及到某一个表的时候，所有事务都会被分配到同一个worker中，就变成单 线程复制了。



### 按行分发策略

要解决热点表的并行复制问题，就需要一个按行并行复制的方案。按行复制的核心思路是：如果 两个事务没有更新相同的行，它们在备库上可以并行执行。显然，这个模式要求binlog格式必须 是row。



这时候，我们判断一个事务T和worker是否冲突，用的就规则就不是“修改同一个表”，而是“修改同一行”。

按行复制和按表复制的数据结构差不多，也是为每个worker，分配一个hash表。只是要实现按 行分发，这时候的key，就必须是“库名+表名+唯一键的值”。



但是，这个“唯一键”只有主键id还是不够的，我们还需要考虑下面这种场景，表t1中除了主键， 还有唯一索引a：

```sql
CREATE TABLE `t1` (
    `id` int(11) NOTNULL,
    `a` int(11) DEFAULTNULL,
    `b` int(11) DEFAULTNULL,
    PRIMARY KEY (`id`),
    UNIQUE KEY `a` (`a`)
) ENGINE=InnoDB;
insert into t1 values(1,1,1),(2,2,2),(3,3,3),(4,4,4),(5,5,5);

```

假设，接下来我们要在主库执行这两个事务：

<img src="MYSQL实战45讲.assets/image-20250224175811790.png" alt="image-20250224175811790" style="zoom:50%;" />



可以看到，这两个事务要更新的行的主键值不同，但是如果它们被分到不同的worker，就有可能 session B的语句先执行。这时候id=1的行的a的值还是1，就会报唯一键冲突。

因此，基于行的策略，事务hash表中还需要考虑唯一键，即key应该是“库名+表名+索引a的名字 +a的值”。



比如，在上面这个例子中，我要在表t1上执行update t1 set a=1 where id=2语句，在binlog里面 记录了整行的数据修改前各个字段的值，和修改后各个字段的值。

因此，coordinator在解析这个语句的binlog的时候，这个事务的hash表就有三个项:

1. key=hash_func(db1+t1+“PRIMARY”+2), value=2; 这里value=2是因为修改前后的行id值不 变，出现了两次。 
2. key=hash_func(db1+t1+“a”+2), value=1，表示会影响到这个表a=2的行。 
3. key=hash_func(db1+t1+“a”+1), value=1，表示会影响到这个表a=1的行。

可见，相比于按表并行分发策略，按行并行策略在决定线程分发的时候，需要消耗更多的 计算资源。你可能也发现了，这两个方案其实都有一些约束条件：

1. 要能够从binlog里面解析出表名、主键值和唯一索引的值。也就是说，主库的binlog格式必须是row；
2. 表必须有主键； 
3. **不能有外键。**表上如果有外键，级联更新的行不会记录在binlog中，这样冲突检测就不准确。

但，好在这三条约束规则，本来就是DBA之前要求业务开发人员必须遵守的线上使用规范，所 以这两个并行复制策略在应用上也没有碰到什么麻烦。



对比按表分发和按行分发这两个方案的话，按行分发策略的并行度更高。不过，如果是要操作很多行的大事务的话，按行分发的策略有两个问题：

1. 耗费内存。比如一个语句要删除100万行数据，这时候hash表就要记录100万个项。 
2. 耗费CPU。解析binlog，然后计算hash值，对于大事务，这个成本还是很高的。

所以，我在实现这个策略的时候会设置一个阈值，单个事务如果超过设置的行数阈值（比如，如 果单个事务更新的行数超过10万行），就暂时**退化为单线程模式**，退化过程的逻辑大概是这样的：

1. coordinator暂时先hold住这个事务； 
2. 等待所有worker都执行完成，变成空队列； 
3. coordinator直接执行这个事务； 
4. 恢复并行模式。

读到这里，你可能会感到奇怪，这两个策略又没有被合到官方，我为什么要介绍这么详细呢？其 实，介绍这两个策略的目的是抛砖引玉，方便你理解后面要介绍的社区版本策略。



## MySQL 5.6版本的并行复制策略

官方MySQL5.6版本，支持了并行复制，只是支持的粒度是**按库并行**。理解了上面介绍的按表分 发策略和按行分发策略，你就理解了，用于决定分发策略的hash表里，key就是数据库名。

这个策略的并行效果，取决于压力模型。如果在主库上有多个DB，并且各个DB的压力均衡，使 用这个策略的效果会很好。

相比于按表和按行分发，这个策略有两个优势：

1. 构造hash值的时候很快，只需要库名；而且一个实例上DB数也不会很多，不会出现需要构 造100万个项这种情况。
2. 不要求binlog的格式。因为statement格式的binlog也可以很容易拿到库名。

但是，如果你的主库上的表都放在同一个DB里面，这个策略就没有效果了；或者如果不同DB的 热点不同，比如一个是业务逻辑库，一个是系统配置库，那也起不到并行的效果（db的数据要均衡）。

理论上你可以创建不同的DB，把相同热度的表均匀分到这些不同的DB中，强行使用这个策略。 不过据我所知，由于需要特地移动数据，这个策略用得并不多。



## MariaDB的并行复制策略

在第23篇文章中，我给你介绍了**redo log组提交(group commit)优化**， 而MariaDB的并行复制策略利用的就是这个特性：

1. 能够在同一组里提交的事务，一定不会修改同一行； 
2. 主库上可以并行执行的事务，备库上也一定是可以并行执行的。

在实现上，MariaDB是这么做的：

1. 在一组里面一起提交的事务，有一个相同的commit_id，下一组就是commit_id+1； 
2. commit_id直接写到binlog里面； 
3. 传到备库应用的时候，相同commit_id的事务分发到多个worker执行； 
4. 这一组全部执行完成后，coordinator再去取下一批。

当时，这个策略出来的时候是相当惊艳的。因为，之前业界的思路都是在“分析binlog，并拆分到 worker”上。而MariaDB的这个策略，目标是“模拟主库的并行模式”。

但是，这个策略有一个问题，它并没有实现“真正的模拟主库并发度”这个目标。在主库上，一组事务在commit的时候，下一组事务是同时处于“执行中”状态的。

如图5所示，假设了三组事务在主库的执行情况，你可以看到在trx1、trx2和trx3提交的时候，trx4、trx5和trx6是在执行的。这样，在第一组事务提交完成的时候，下一组事务很快就会进 入commit状态。

<img src="MYSQL实战45讲.assets/image-20250225175023309.png" alt="image-20250225175023309" style="zoom:50%;" />

而按照MariaDB的并行复制策略，备库上的执行效果如图6所示。

<img src="MYSQL实战45讲.assets/image-20250225175042617.png" alt="image-20250225175042617" style="zoom:50%;" />

可以看到，在备库上执行的时候，要等第一组事务完全执行完成后，第二组事务才能开始执行， 这样系统的吞吐量就不够。

另外，这个方案很容易被大事务拖后腿。假设trx2是一个超大事务，那么在备库应用的时 候，trx1和trx3执行完成后，就只能等trx2完全执行完成，下一组才能开始执行。这段时间，只有 一个worker线程在工作，是对资源的浪费。

不过即使如此，这个策略仍然是一个很漂亮的创新。因为，它对原系统的改造非常少，实现也很优雅。



## MySQL 5.7的并行复制策略

在MariaDB并行复制实现之后，官方的MySQL5.7版本也提供了类似的功能，由参数slave-parallel-type来控制并行复制策略：

1. 配置为**DATABASE**，表示使用MySQL 5.6版本的按库并行策略； 
2. 配置为 LOGICAL_CLOCK，表示的就是类似MariaDB的策略。不过，MySQL 5.7这个策 略，针对并行度做了优化。这个优化的思路也很有趣儿。

你可以先考虑这样一个问题：同时处于“执行状态”的所有事务，是不是可以并行？ 答案是，不能。

因为，这里面可能有由于锁冲突而处于锁等待状态的事务。如果这些事务在备库上被分配到不同 的worker，就会出现备库跟主库不一致的情况。

而上面提到的MariaDB这个策略的核心，是“所有处于commit”状态的事务可以并行。事务处于 commit状态，表示已经通过了锁冲突的检验了。

这时候，你可以再回顾一下两阶段提交，我把前面第23篇文章中介绍过的两阶段提交过程图贴过来。

<img src="MYSQL实战45讲.assets/image-20250225175450956.png" alt="image-20250225175450956" style="zoom:50%;" />

其实，不用等到commit阶段，只要能够到达redo log prepare阶段，就表示事务已经通过锁冲突的检验了。



因此，MySQL 5.7并行复制策略的思想是：

1. 同时处于prepare状态的事务，在备库执行时是可以并行的； 
2. 处于prepare状态的事务，与处于commit状态的事务之间，在备库执行时也是可以并行的。

我在第23篇文章，讲binlog的组提交的时候，介绍过两个参数：

1. binlog_group_commit_sync_delay参数，表示延迟多少微秒后才调用fsync; 
2. binlog_group_commit_sync_no_delay_count参数，表示累积多少次以后才调用fsync。



这两个参数是用于故意拉长binlog从write到fsync的时间，以此减少binlog的写盘次数。在MySQL 5.7的并行复制策略里，它们可以用来制造更多的“同时处于prepare阶段的事务”。这样就增加了 备库复制的并行度。



也就是说，这两个参数，既可以“故意”让主库提交得慢些，又可以让备库执行得快些。在MySQL 5.7处理备库延迟的时候，可以考虑调整这两个参数值，来达到提升备库复制并发度的目的。



## MySQL 5.7.22的并行复制策略

在2018年4月份发布的MySQL 5.7.22版本里，MySQL增加了一个新的并行复制策略，基于 WRITESET的并行复制。

相应地，新增了一个参数binlog-transaction-dependency-tracking，用来控制是否启用这个新策 略。这个参数的可选值有以下三种。

1. **COMMIT_ORDER**，表示的就是前面介绍的，根据同时进入prepare和commit来判断是否可 以并行的策略。 
2. **WRITESET**，表示的是对于事务涉及更新的每一行，计算出这一行的hash值，组成集合 writeset。如果两个事务没有操作相同的行，也就是说它们的writeset没有交集，就可以并 行。 
3. **WRITESET_SESSION**，是在WRITESET的基础上多了一个约束，即在主库上同一个线程 先后执行的两个事务，在备库执行的时候，要保证相同的先后顺序。

当然为了唯一标识，这个hash值是通过“库名+表名+索引名+值”计算出来的。如果一个表上除了 有主键索引外，还有其他唯一索引，那么对于每个唯一索引，insert语句对应的writeset就要多增 加一个hash值。

你可能看出来了，这跟我们前面介绍的基于MySQL 5.5版本的按行分发的策略是差不多的。不 过，MySQL官方的这个实现还是有很大的优势：

1. writeset是在主库生成后直接写入到binlog里面的，这样在备库执行的时候，不需要解析 binlog内容（event里的行数据），节省了很多计算量； 
2. 不需要把整个事务的binlog都扫一遍才能决定分发到哪个worker，更省内存； 
3. 由于备库的分发策略不依赖于binlog内容，所以binlog是statement格式也是可以的。

因此，MySQL 5.7.22的并行复制策略在通用性上还是有保证的。

当然，对于“表上没主键”和“外键约束”的场景，WRITESET策略也是没法并行的，也会暂时退化 为单线程模型。



## 小结

在今天这篇文章中，我和你介绍了MySQL的各种多线程复制策略。

为什么要有多线程复制呢？这是因为单线程复制的能力全面低于多线程复制，对于更新压力较大 的主库，备库是可能一直追不上主库的。从现象上看就是，备库上seconds_behind_master的值 越来越大。

在介绍完每个并行复制策略后，我还和你分享了不同策略的优缺点：

- 如果你是DBA，就需要根据不同的业务场景，选择不同的策略； 
- 如果是你业务开发人员，也希望你能从中获取灵感用到平时的开发工作中。

从这些分析中，你也会发现大事务不仅会影响到主库，也是造成备库复制延迟的主要原因之一。 因此，在平时的开发工作中，我建议你尽量减少大事务操作，把大事务拆成小事务。



官方MySQL5.7版本新增的备库并行策略，修改了binlog的内容，也就是说binlog协议并不是向上 兼容的，在主备切换、版本升级的时候需要把这个因素也考虑进去。



### 思考题

假设一个MySQL 5.7.22版本的主库，单线程插入了很多数据，过了3个小时后，我们要给这个主 库搭建一个相同版本的备库。



这时候，你为了更快地让备库追上主库，要开并行复制。在binlog-transaction-dependencytracking参数的COMMIT_ORDER、WRITESET和WRITE_SESSION这三个取值中，你会选择哪一个呢？

你选择的原因是什么？如果设置另外两个参数，你认为会出现什么现象呢？

> 回答

上一篇文章最后，我给你留的问题是，如果主库都是单线程压力模式，在从库追主库的过程 中，binlog-transaction-dependency-tracking 应该选用什么参数？

这个问题的答案是，应该将这个**参数设置为WRITESET**。

由于主库是单线程压力模式，所以每个事务的commit_id都不同，那么设置为COMMIT_ORDER 模式的话，从库也只能单线程执行。

同样地，由于WRITESET_SESSION模式要求在备库应用日志的时候，同一个线程的日志必须与主库上执行的先后顺序相同，也会导致主库单线程压力模式下退化成单线程复制。

所以，应该将binlog-transaction-dependency-tracking 设置为WRITESET。



# 27 | 主库出问题了，从库怎么办？

在前面的第24、25和26篇文章中，我和你介绍了MySQL主备复制的基础结构，但这些都是一主 一备的结构。



大多数的互联网应用场景都是读多写少，因此你负责的业务，在发展过程中很可能先会遇到读性 能的问题。

而**在数据库层解决读性能问题，就要涉及到接下来两篇文章要讨论的架构：一主多从**。



今天这篇文章，我们就先聊聊一主多从的切换正确性。然后，我们在下一篇文章中再聊聊解决一主多从的查询逻辑正确性的方法。

如图1所示，就是一个基本的一主多从结构。

<img src="MYSQL实战45讲.assets/image-20250225181734213.png" alt="image-20250225181734213" style="zoom:50%;" />

图中，虚线箭头表示的是主备关系，也就是A和A’互为主备， 从库B、C、D指向的是主库A。

一主多从的设置，一般用于读写分离，主库负责所有的写入和一部分读，其他的读请求则由从库分担。



今天我们要讨论的就是，在一主多从架构下，主库故障后的主备切换问题。

如图2所示，就是主库发生故障，主备切换后的结果。

<img src="MYSQL实战45讲.assets/image-20250225181944778.png" alt="image-20250225181944778" style="zoom:50%;" />

相比于一主一备的切换流程，一主多从结构在切换完成后，A’会成为新的主库，从库B、C、D也 要改接到A’。

正是由于多了从库B、C、D重新指向的这个过程，所以主备切换的复杂性也相应增加了。



接下来，我们再一起看看一个切换系统会怎么完成一主多从的主备切换过程。

## 基于位点的主备切换

这里，我们需要先来回顾一个知识点。

当我们把节点B设置成节点A’的从库的时候，需要执行一条change master命令：

```yaml
CHANGE MASTER TO
MASTER_HOST=$host_name
MASTER_PORT=$port
MASTER_USER=$user_name
MASTER_PASSWORD=$password
MASTER_LOG_FILE=$master_log_name
MASTER_LOG_POS=$master_log_pos
```

这条命令有这么6个参数：

- MASTER_HOST、MASTER_PORT、MASTER_USER和MASTER_PASSWORD四个参 数，分别代表了主库A’的IP、端口、用户名和密码。 
- 最后两个参数MASTER_LOG_FILE和MASTER_LOG_POS表示，要从主库的 master_log_name文件的master_log_pos这个位置的日志继续同步。而这个位置就是我们所 说的同步位点，也就是主库对应的文件名和日志偏移量。

那么，这里就有一个问题了，节点B要设置成A’的从库，就要执行change master命令，就不可 避免地要设置位点的这两个参数，但是这两个参数到底应该怎么设置呢？

原来节点B是A的从库，本地记录的也是A的位点。但是相同的日志，A的位点和A’的位点是不同 的。

因此，**从库B要切换的时候，就需要先经过“找同步位点”这个逻辑**。



这个位点很难精确取到，只能取一个大概位置。为什么这么说呢？

我来和你分析一下看看这个位点一般是怎么获取到的，你就清楚其中不精确的原因了。



考虑到切换过程中不能丢数据，所以我们找位点的时候，总是要找一个“稍微往前”的，然后再通过判断跳过那些在从库B上已经执行过的事务。

一种取同步位点的方法是这样的：

1. 等待新主库A’把中转日志（relay log）全部同步完成； 
2. 在A’上执行showmaster status命令，得到当前A’上最新的File 和 Position； 
3. 取原主库A故障的时刻T； 
4. 用mysqlbinlog工具解析A’的File，得到T时刻的位点。

```
mysqlbinlog File --stop-datetime=T --start-datetime=T
```

<img src="MYSQL实战45讲.assets/image-20250225183202933.png" alt="image-20250225183202933" style="zoom:50%;" />

- end_log_pos

图中，end_log_pos后面的值“123”，表示的就是A’这个实例，在T时刻写入新的binlog的位置。 然后，我们就可以把123这个值作为$master_log_pos ，用在节点B的change master命令里。

当然这个值并不精确。为什么呢？

你可以设想有这么一种情况，假设在T这个时刻，主库A已经执行完成了一个insert 语句插入了一 行数据R，并且已经将binlog传给了A’和B，然后在传完的瞬间主库A的主机就掉电了。

那么，这时候系统的状态是这样的：

1. 在从库B上，由于同步了binlog， R这一行已经存在；
2. 在新主库A’上， R这一行也已经存在，日志是写在123这个位置之后的； 
3. 我们在从库B上执行change master命令，指向A’的File文件的123位置，就会把插入R这一行 数据的binlog又同步到从库B去执行。

这时候，从库B的同步线程就会报告 **Duplicate entry ‘id_of_R’ for key ‘PRIMARY’ 错误**，提示出现了主键冲突，然后停止同步。

所以，通常情况下，我们在切换任务的时候，要先主动跳过这些错误，有两种常用的方 法。 一种做法是，主动跳过一个事务。跳过命令的写法是：

```sql
set global sql_slave_skip_counter=1;
start slave;
```

因为切换过程中，可能会不止重复执行一个事务，所以我们需要在从库B刚开始接到新主库 A’时，持续观察，每次碰到这些错误就停下来，执行一次跳过命令，直到不再出现停下来的情 况，以此来跳过可能涉及的所有事务。

另外一种方式是，通过设置slave_skip_errors参数，直接设置跳过指定的错误。

在执行主备切换时，有这么两类错误，是经常会遇到的：

- 1062错误是插入数据时唯一键冲突； 
- 1032错误是删除数据时找不到行。

因此，我们可以把slave_skip_errors 设置为 “1032,1062”，这样中间碰到这两个错误时就直接跳过。

这里需要注意的是，这种直接跳过指定错误的方法，针对的是主备切换时，由于找不到精确的同步位点，所以只能采用这种方法来创建从库和新主库的主备关系。



这个背景是，我们很清楚在主备切换过程中，直接跳过1032和1062这两类错误是无损的，所以 set global sql_slave_skip_counter=1; start slave; 才可以这么设置slave_skip_errors参数。等到主备间的同步关系建立完成，并稳定执行一段时间 之后，我们还需要把这个参数设置为空，以免之后真的出现了主从数据不一致，也跳过了。



## GTID

通过sql_slave_skip_counter跳过事务和通过slave_skip_errors忽略错误的方法，虽然都最终可以 建立从库B和新主库A’的主备关系，但这两种操作都很复杂，而且容易出错。所以，MySQL 5.6 版本引入了GTID，彻底解决了这个困难。

那么，GTID到底是什么意思，又是如何解决找同步位点这个问题呢？现在，我就和你简单介绍 一下。

TID的全称是Global Transaction Identifier，也就是全局事务ID，是一个事务在提交的时候生成 的，是这个事务的唯一标识。它由两部分组成，格式是：

```
GTID=server_uuid:gno
```

其中： 

- server_uuid是一个实例第一次启动时自动生成的，是一个全局唯一的值； 
- gno是一个整数，初始值是1，每次提交事务的时候分配给这个事务，并加1。

这里我需要和你说明一下，在MySQL的官方文档里，GTID格式是这么定义的：

```
GTID=source_id:transaction_id
```

这里的source_id就是server_uuid；而后面的这个transaction_id，我觉得容易造成误导，所以我 改成了gno。为什么说使用transaction_id容易造成误解呢？

因为，在MySQL里面我们说transaction_id就是指事务id，事务id是在事务执行过程中分配的，如果这个事务回滚了，事务id也会递增，而**gno是在事务提交的时候才会分配**。

从效果上看，GTID往往是连续的，因此我们用gno来表示更容易理解。

GTID模式的启动也很简单，我们只需要在启动一个MySQL实例的时候，加上参数gtid_mode=on 和enforce_gtid_consistency=on就可以了。

在GTID模式下，每个事务都会跟一个GTID一一对应。这个GTID有两种生成方式，而使用哪种 方式取决于session变量gtid_next的值

1. 如果gtid_next=automatic，代表使用默认值。这时，MySQL就会把server_uuid:gno分配给 GTID=server_uuid:gno GTID=source_id:transaction_id 这个事务。 

   a. 记录binlog的时候，先记录一行 SET@@SESSION.GTID_NEXT=‘server_uuid:gno’; 

   b. 把这个GTID加入本实例的GTID集合。

2. 如果gtid_next是一个指定的GTID的值，比如通过set gtid_next='current_gtid’指定为 current_gtid，那么就有两种可能： 

   a. 如果current_gtid已经存在于实例的GTID集合中，接下来执行的这个事务会直接被系统忽 略； 

   b. 如果current_gtid没有存在于实例的GTID集合中，就将这个current_gtid分配给接下来要执 行的事务，也就是说系统不需要给这个事务生成新的GTID，因此gno也不用加1。

注意，一个current_gtid只能给一个事务使用。这个事务提交后，如果要执行下一个事务，就要 执行set 命令，把gtid_next设置成另外一个gtid或者automatic。

这样，每个MySQL实例都维护了一个GTID集合，用来对应“这个实例执行过的所有事务”。

这样看上去不太容易理解，接下来我就用一个简单的例子，来和你说明GTID的基本用法。



我们在实例X中创建一个表t。

```sql
CREATE TABLE `t` (
    `id` int(11) NOTNULL,
    `c` int(11) DEFAULTNULL,
    PRIMARY KEY (`id`)
) ENGINE=InnoDB;
insert into t values(1,1)
```

<img src="MYSQL实战45讲.assets/image-20250225193831391.png" alt="image-20250225193831391" style="zoom: 67%;" />

可以看到，事务的BEGIN之前有一条SET@@SESSION.GTID_NEXT命令。这时，如果实例X有从库，那么将CREATE TABLE和insert语句的binlog同步过去执行的话，执行事务之前就会先 执行这两个SET命令， 这样被加入从库的GTID集合的，就是图中的这两个GTID。

假设，现在这个实例X是另外一个实例Y的从库，并且此时在实例Y上执行了下面这条插入语句：

```
insert into t values(1,1);
```

并且，这条语句在实例Y上的GTID是 “aaaaaaaa-cccc-dddd-eeee-ffffffffffff:10”。



那么，实例X作为Y的从库，就要同步这个事务过来执行，显然会出现主键冲突，导致实例X的同 步线程停止。这时，我们应该怎么处理呢？

处理方法就是，你可以执行下面的这个语句序列：

```sql
set gtid_next='aaaaaaaa-cccc-dddd-eeee-ffffffffffff:10';
begin;
commit;
set gtid_next=automatic;
start slave;
```

其中，前三条语句的作用，是通过提交一个空事务，把这个GTID加到实例X的GTID集合中。如 图5所示，就是执行完这个空事务之后的showmaster status的结果。

<img src="MYSQL实战45讲.assets/image-20250225194050749.png" alt="image-20250225194050749" style="zoom:50%;" />

可以看到实例X的Executed_Gtid_set里面，已经加入了这个GTID。

这样，我再执行start slave命令让同步线程执行起来的时候，虽然实例X上还是会继续执行实例Y 传过来的事务，但是由于“aaaaaaaa-cccc-dddd-eeee-ffffffffffff:10”已经存在于实例X的GTID集 合中了，所以实例X就会直接跳过这个事务，也就不会再出现主键冲突的错误。

在上面的这个语句序列中，start slave命令之前还有一句set gtid_next=automatic。这句话的作 用是“恢复GTID的默认分配行为”，也就是说如果之后有新的事务再执行，就还是按照原来的分配方式，继续分配gno=3。



## 基于GTID的主备切换

现在，我们已经理解GTID的概念，再一起来看看基于GTID的主备复制的用法。 

在GTID模式下，备库B要设置为新主库A’的从库的语法如下：

```sql
CHANGE MASTER TO
MASTER_HOST=$host_name
MASTER_PORT=$port
MASTER_USER=$user_name
MASTER_PASSWORD=$password
master_auto_position=1
```

其中，master_auto_position=1就表示这个主备关系使用的是GTID协议。**可以看到，前面让我 们头疼不已的MASTER_LOG_FILE和MASTER_LOG_POS参数，已经不需要指定了**。

我们把现在这个时刻，实例A’的GTID集合记为set_a，实例B的GTID集合记为set_b。接下来， 我们就看看现在的主备切换逻辑。

我们在实例B上执行start slave命令，取binlog的逻辑是这样的：

1. 实例B指定主库A’，基于主备协议建立连接。 

2. 实例B把**set_b**发给主库A’。 

3. 实例A’算出set_a与set_b的差集，也就是所有存在于**set_a**，但是不存在于set_b的GITD的 集合，判断A’本地是否包含了这个差集需要的所有binlog事务。

   a. 如果不包含，表示A’已经把实例B需要的binlog给删掉了，直接返回错误； 

   b. 如果确认全部包含，A’从自己的binlog文件里面，找出第一个不在set_b的事务，发给B； 

​	4. 之后就从这个事务开始，往后读文件，按顺序取binlog发给B去执行。

其实，这个逻辑里面包含了一个设计思想：在基于GTID的主备关系里，系统认为只要建立主备关系，就必须保证主库发给备库的日志是完整的。因此，如果实例B需要的日志已经不存在，A’就拒绝把日志发给B。

这跟基于位点的主备协议不同。基于位点的协议，是由备库决定的，备库指定哪个位点，主库就 发哪个位点，不做日志的完整性判断。



基于上面的介绍，我们再来看看引入GTID后，一主多从的切换场景下，主备切换是如何实现的。

由于不需要找位点了，所以从库B、C、D只需要分别执行change master命令指向实例A’即可。 

其实，严谨地说，主备切换不是不需要找位点了，而是找位点这个工作，在实例A’内部就已经自 动完成了。但由于这个工作是自动的，所以对HA系统的开发人员来说，非常友好。

之后这个系统就由新主库A’写入，主库A’的自己生成的binlog中的GTID集合格式是： server_uuid_of_A’:1-M。

如果之前从库B的GTID集合格式是 server_uuid_of_A:1-N， 那么切换之后GTID集合的格式就变 成了server_uuid_of_A:1-N, server_uuid_of_A’:1-M。

当然，主库A’之前也是A的备库，因此主库A’和从库B的GTID集合是一样的。这就达到了我们预 期。



## GTID和在线DDL

接下来，我再举个例子帮你理解GTID。

之前在第22篇文章《MySQL有哪些“饮鸩止渴”提高性能的方法？》中，我和你提到业务高峰期 的慢查询性能问题时，分析到如果是由于索引缺失引起的性能问题，我们可以通过**在线加索引**来解决。但是，考虑到要避免新增索引对主库性能造成的影响，我们**可以先在备库加索引，然后再切换**。

当时我说，在双M结构下，备库执行的DDL语句也会传给主库，为了避免传回后对主库造成影 响，要通过set sql_log_bin=off关掉binlog。

评论区有位同学提出了一个问题：这样操作的话，数据库里面是加了索引，但是binlog并没有记 录下这一个更新，是不是会导致数据和日志不一致？

这个问题提得非常好。当时，我在留言的回复中就引用了GTID来说明。今天，我再和你展开说 明一下。



假设，这两个互为主备关系的库还是实例X和实例Y，且当前主库是X，并且都打开了GTID模 式。这时的主备切换流程可以变成下面这样：

- 在实例X上执行stop slave。 
- 在实例Y上执行DDL语句。注意，这里并不需要关闭binlog。 
- 执行完成后，查出这个DDL语句对应的GTID，并记为 server_uuid_of_Y:gno。 
- 到实例X上执行以下语句序列，这样做的目的在于，既可以让实例Y的更新有binlog记录，同时也可以确保不会在实例X上执行这 条更新。

```sql
set GTID_NEXT="server_uuid_of_Y:gno";
begin;
commit;
set gtid_next=automatic;
start slave;
```

- 接下来，执行完主备切换，然后照着上述流程再执行一遍即可。



## 小结

在今天这篇文章中，我先和你介绍了一主多从的主备切换流程。

在这个过程中，从库找新主库的位点是一个痛点。由此，我们引出了**MySQL 5.6**版本引入的GTID模式，介绍了GTID的基本概念和用法。

可以看到，在GTID模式下，一主多从切换就非常方便了。 因此，如果你使用的MySQL版本支持GTID的话，我都建议你尽量使用GTID模式来做一主多从的切换。 在下一篇文章中，我们还能看到GTID模式在读写分离场景的应用。



### 思考题

你在GTID模式下设置主从关系的时候，从库执行start slave命令后，主库发现需要的binlog已经 被删除掉了，导致主备创建不成功。这种情况下，你觉得可以怎么处理呢？

> 回答

上期给你留的问题是，在GTID模式下，如果一个新的从库接上主库，但是需要的binlog已经没 了，要怎么做？ @某、人同学给了很详细的分析，我把他的回答略做修改贴过来。

1. 如果业务允许主从不一致的情况，那么可以在主库上先执行showglobal variables like ‘gtid_purged’，得到主库已经删除的GTID集合，假设是gtid_purged1；然后先在从库上执行 reset master，再执行set global gtid_purged =‘gtid_purged1’；最后执行start slave，就会从 主库现存的binlog开始同步。binlog缺失的那一部分，数据在从库上就可能会有丢失，造成 主从不一致。
2. 如果需要主从数据一致的话，最好还是通过重新搭建从库来做。 
3. 如果有其他的从库保留有全量的binlog的话，可以把新的从库先接到这个保留了全量binlog 的从库，追上日志以后，如果有需要，再接回主库。

4. 如果binlog有备份的情况，可以先在从库上应用缺失的binlog，然后再执行start slave。

   

# 28 | 读写分离有哪些坑？



在上一篇文章中，我和你介绍了一主多从的结构以及切换流程。今天我们就继续聊聊一主多从架 构的应用场景：读写分离，以及怎么处理主备延迟导致的读写分离问题。

我们在上一篇文章中提到的一主多从的结构，其实就是读写分离的基本结构了。这里，我再把这 张图贴过来，方便你理解。

<img src="MYSQL实战45讲.assets/image-20250225195251807.png" alt="image-20250225195251807" style="zoom:50%;" />

读写分离的主要目标就是分摊主库的压力。图1中的结构是客户端（client）主动做负载均衡，这 种模式下一般会把数据库的连接信息放在客户端的连接层。也就是说，由客户端来选择后端数据 库进行查询。

还有一种架构是，在MySQL和客户端之间有一个中间代理层proxy，客户端只连接proxy， 由 proxy根据请求类型和上下文决定请求的分发路由。

<img src="MYSQL实战45讲.assets/image-20250225195326095.png" alt="image-20250225195326095" style="zoom: 67%;" />



接下来，我们就看一下客户端直连和带proxy的读写分离架构，各有哪些特点。 

1. 客户端直连方案，因为少了一层proxy转发，所以查询性能稍微好一点儿，并且整体架构简单，排查问题更方便。但是这种方案，由于要了解后端部署细节，所以在出现主备切换、库迁移等操作的时候，客户端都会感知到，并且需要调整数据库连接信息。 你可能会觉得这样客户端也太麻烦了，信息大量冗余，架构很丑。其实也未必，一般采用这样的架构，一定会伴随一个负责管理后端的组件，比如Zookeeper，尽量让业务端只专注于 业务逻辑开发。 
2. 带proxy的架构，对客户端比较友好。客户端不需要关注后端细节，连接维护、后端信息维护等工作，都是由proxy完成的。但这样的话，对后端维护团队的要求会更高。而且，proxy 也需要有高可用架构。因此，带proxy架构的整体就相对比较复杂。

理解了这两种方案的优劣，具体选择哪个方案就取决于数据库团队提供的能力了。但目前看，趋势是往带proxy的架构方向发展的。

但是，不论使用哪种架构，你都会碰到我们今天要讨论的问题：由于主从可能存在延迟，客户端 执行完一个更新事务后马上发起查询，如果查询选择的是从库的话，就有可能读到刚刚的事务更 新之前的状态。

这种“在从库上会读到系统的一个过期状态”的现象，在这篇文章里，我们暂且称之为“**过期读**”。



前面我们说过了几种可能导致主备延迟的原因，以及对应的优化策略，但是主从延迟还是不能 100%避免的。

不论哪种结构，客户端都希望查询从库的数据结果，跟查主库的数据结果是一样的。

接下来，我们就来讨论怎么处理过期读问题。 这里，我先把文章中涉及到的**处理过期读的方案**汇总在这里，以帮助你更好地理解和掌握全文的知识脉络。这些方案包括：

- 强制走主库方案； 
- sleep方案； 
- 判断主备无延迟方案； 
- 配合semi-sync方案； 
- 等主库位点方案； 
- 等GTID方案

## 处理过期读的方案

### 强制走主库方案

强制走主库方案其实就是，将查询请求做分类。通常情况下，我们可以将查询请求分为这么两类：

1. 对于必须要拿到最新结果的请求，强制将其发到主库上。比如，在一个交易平台上，卖家发 布商品以后，马上要返回主页面，看商品是否发布成功。那么，这个请求需要拿到最新的结 果，就必须走主库。 
2. 对于可以读到旧数据的请求，才将其发到从库上。在这个交易平台上，买家来逛商铺页面， 就算晚几秒看到最新发布的商品，也是可以接受的。那么，这类请求就可以走从库。

你可能会说，这个方案是不是有点畏难和取巧的意思，但其实这个方案是用得最多的。

当然，这个方案最大的问题在于，有时候你会碰到“所有查询都不能是过期读”的需求，比如一些 金融类的业务。这样的话，你就要放弃读写分离，所有读写压力都在主库，等同于放弃了扩展性。

因此接下来，我们来讨论的话题是：**可以支持读写分离的场景下，有哪些解决过期读的方案，并分析各个方案的优缺点**。



### Sleep 方案

主库更新后，读从库之前先sleep一下。具体的方案就是，类似于执行一条select sleep(1)命令。 这个方案的假设是，大多数情况下主备延迟在1秒之内，做一个sleep可以有很大概率拿到最新的 数据。

这个方案给你的第一感觉，很可能是不靠谱儿，应该不会有人用吧？并且，你还可能会说，直接 在发起查询时先执行一条sleep语句，用户体验很不友好啊。



但，这个思路确实可以在一定程度上解决问题。为了看起来更靠谱儿，我们可以换一种方式。 以卖家发布商品为例，商品发布后，用Ajax（Asynchronous JavaScript +XML，异步JavaScript 和XML）直接把客户端输入的内容作为“新的商品”显示在页面上，而不是真正地去数据库做查 询。



这样，卖家就可以通过这个显示，来确认产品已经发布成功了。等到卖家再刷新页面，去查看商 品的时候，其实已经过了一段时间，也就达到了sleep的目的，进而也就解决了过期读的问题。（客户端将add请求的响应数据直接展示而不是去拉下list，也是类似的思想）



也就是说，这个sleep方案确实解决了类似场景下的过期读问题。但，从严格意义上来说，这个 方案存在的问题就是不精确。这个不精确包含了两层意思：

1. 如果这个查询请求本来0.5秒就可以在从库上拿到正确结果，也会等1秒； 
2. 如果延迟超过1秒，还是会出现过期读。

看到这里，你是不是有一种“你是不是在逗我”的感觉，这个改进方案虽然可以解决类似Ajax场景 下的过期读问题，但还是怎么看都不靠谱儿。别着急，接下来我就和你介绍一些更准确的方案。



### 判断主备无延迟方案

要确保备库无延迟，通常有三种做法。

通过前面的第25篇文章，我们知道show slave status结果里的`seconds_behind_master`参数的 值，可以用来衡量主备延迟时间的长短。

> **第一种确保主备无延迟的方法是，每次从库执行查询请求前，先判断 seconds_behind_master是否已经等于0**。

如果还不等于0 ，那就必须等到这个参数变为0才能执行查询请求。

seconds_behind_master的单位是秒，如果你觉得精度不够的话，还可以采用对比位点和GTID 的方法来确保主备无延迟，也就是我们接下来要说的第二和第三种方法。

<img src="MYSQL实战45讲.assets/image-20250225200241120.png" alt="image-20250225200241120" style="zoom:50%;" />

现在，我们就通过这个结果，来看看具体如何通过对比位点和GTID来确保主备无延迟。



> **第二种方法，对比位点确保主备无延迟**

- Master_Log_File和Read_Master_Log_Pos，表示的是读到的主库的最新位点； 
- Relay_Master_Log_File和Exec_Master_Log_Pos，表示的是备库执行的最新位点。

如果Master_Log_File和Relay_Master_Log_File、Read_Master_Log_Pos和 Exec_Master_Log_Pos这两组值完全相同，就表示接收到的日志已经同步完成。

> 第三种方法，对比GTID集合确保主备无延迟

- Auto_Position=1 ，表示这对主备关系使用了GTID协议。 
- Retrieved_Gtid_Set，是备库收到的所有日志的GTID集合； 
- Executed_Gtid_Set，是备库所有已经执行完成的GTID集合。

如果这两个集合相同，也表示备库接收到的日志都已经同步完成。

可见，对比位点和对比GTID这两种方法，都要比判断seconds_behind_master是否为0更准确。

在执行查询请求之前，先判断从库是否同步完成的方法，相比于sleep方案，准确度确实提升了 不少，但还是没有达到“精确”的程度。为什么这么说呢？



我们现在一起来回顾下，一个事务的binlog在主备库之间的状态：

1. 主库执行完成，写入binlog，并反馈给客户端；
2. binlog被从主库发送给备库，备库收到； 
3. 在备库执行binlog完成。

我们上面判断主备无延迟的逻辑，是“备库收到的日志都执行完成了”。但是，从binlog在主备之 间状态的分析中，**不难看出还有一部分日志，处于客户端已经收到提交确认，而备库还没收到日志的状态**。

如图4所示就是这样的一个状态。

<img src="MYSQL实战45讲.assets/image-20250225200634975.png" alt="image-20250225200634975" style="zoom: 67%;" />

这时，主库上执行完成了三个事务trx1、trx2和trx3，其中： 

1. trx1和trx2已经传到从库，并且已经执行完成了； 
2. trx3在主库执行完成，并且已经回复给客户端，但是还没有传到从库中。

如果这时候你在从库B上执行查询请求，按照我们上面的逻辑，从库认为已经没有同步延迟，但 还是查不到trx3的。严格地说，就是出现了过期读。

那么，这个问题有没有办法解决呢？



### 配合semi-sync

要解决这个问题，就要引入半同步复制，也就是semi-sync replication。

semi-sync做了这样的设计：

1. 事务提交的时候，主库把binlog发给从库；
2. **从库收到binlog以后，发回给主库一个ack，表示收到了**； 
3. 主库收到这个ack以后，才能给客户端返回“事务完成”的确认。

也就是说，如果启用了semi-sync，就表示所有给客户端发送过确认的事务，都确保了备库已经收到了这个日志。

在第25篇文章的评论区，有同学问到：如果主库掉电的时候，有些binlog还来不及发给从库，会不会导致系统数据丢失？

答案是，**如果使用的是普通的异步复制模式，就可能会丢失，但semi-sync就可以解决这个问题**。

这样，semi-sync配合前面关于位点的判断，就能够确定在从库上执行的查询请求，可以避免过期读。

但是，semi-sync+位点判断的方案，只对一主一备的场景是成立的。在一主多从场景中，主库只 要等到一个从库的ack，就开始给客户端返回确认。这时，在从库上执行查询请求，就有两种情况：

1. 如果查询是落在这个响应了ack的从库上，是能够确保读到最新数据； 
2. 但如果是查询落到其他从库上，它们可能还没有收到最新的日志，就会产生过期读的问题。 

其实，判断同步位点的方案还有另外一个潜在的问题，即：如果在业务更新的高峰期，主库的位点或者GTID集合更新很快，那么上面的两个位点等值判断就会一直不成立，很可能出现从库上迟迟无法响应查询请求的情况。



实际上，回到我们最初的业务逻辑里，当发起一个查询请求以后，我们要得到准确的结果，其实 并不需要等到“主备完全同步”

为什么这么说呢？我们来看一下这个时序图。

<img src="MYSQL实战45讲.assets/image-20250226122823567.png" alt="image-20250226122823567" style="zoom:50%;" />



图5所示，就是等待位点方案的一个bad case。图中备库B下的虚线框，分别表示relaylog和 binlog中的事务。可以看到，图5中从状态1 到状态4，一直处于延迟一个事务的状态。

备库B一直到状态4都和主库A存在延迟，如果用上面必须等到无延迟才能查询的方案，select语 句直到状态4都不能被执行。

但是，其实客户端是在发完trx1更新后发起的select语句，我们只需要确保trx1已经执行完成就可 以执行select语句了。也就是说，如果在状态3执行查询请求，得到的就是预期结果了。

到这里，我们小结一下，semi-sync配合判断主备无延迟的方案，存在两个问题：

1. 一主多从的时候，在某些从库执行查询请求会存在过期读的现象； 
2. 在持续延迟的情况下，可能出现过度等待的问题。

接下来，我要和你介绍的**等主库位点方案，就可以解决这两个问题**。



### 等主库位点方案

要理解等主库位点方案，我需要先和你介绍一条命令：

```sql
select master_pos_wait(file, pos[, timeout]);
```



这条命令的逻辑如下： 

1. 它是在从库执行的； 
2. 参数file和pos指的是主库上的文件名和位置； 
3. timeout可选，设置为正整数N表示这个函数最多等待N秒。

这个命令正常返回的结果是一个正整数M，表示从命令开始执行，到应用完file和pos表示的 binlog位置，**执行了多少事务**。



当然，除了正常返回一个正整数M外，这条命令还会返回一些其他结果，包括：

1. 如果执行期间，备库同步线程发生异常，则返回NULL； 
2. 如果等待超过N秒，就返回-1； 
3. 如果刚开始执行的时候，就发现已经执行过这个位置了，则返回0。

对于图5中先执行trx1，再执行一个查询请求的逻辑，要保证能够查到正确的数据，我们可以使 用这个逻辑：

1. **trx1事务更新完成后，马上执行show master status得到当前主库执行到的File和Position**； 
2. 选定一个从库执行查询语句； 
3. 在从库上执行select master_pos_wait(File, Position, 1)； 
4. 如果返回值是>=0的正整数，则在这个从库执行查询语句； 
5. 否则，到主库执行查询语句。



我把上面这个流程画出来。

<img src="MYSQL实战45讲.assets/image-20250227122228458.png" alt="image-20250227122228458" style="zoom:50%;" />



这里我们假设，这条select查询最多在从库上等待1秒。那么，如果1秒内master_pos_wait返回 一个大于等于0的整数，就确保了从库上执行的这个查询结果一定包含了trx1的数据。



步骤5到主库执行查询语句，是这类方案常用的**退化机制**。因为从库的延迟时间不可控，不能无 限等待，所以如果等待超时，就应该放弃，然后到主库去查。

你可能会说，如果所有的从库都延迟超过1秒了，那查询压力不就都跑到主库上了吗？确实是这样。

但是，按照我们设定不允许过期读的要求，就只有两种选择，**一种是超时放弃，一种是转到主库查询**。具体怎么选择，就需要业务开发同学做好**限流策略**了。



### GTID方案

如果你的数据库开启了GTID模式，对应的也有等待GTID的方案。

MySQL中同样提供了一个类似的命令：

```sql
select wait_for_executed_gtid_set(gtid_set, 1);
```

这条命令的逻辑是： 

1. 等待，直到这个库执行的事务中包含传入的gtid_set，返回0； 
2. 超时返回1。

在前面等位点的方案中，我们执行完事务后，还要主动去主库执行show master status。

而 **MySQL 5.7.6版本开始，允许在执行完更新类事务后，把这个事务的GTID返回给客户端，这样 等GTID的方案就可以减少一次查询**。



这时，等GTID的执行流程就变成了：

1. trx1事务更新完成后，从返回包直接获取这个事务的GTID，记为gtid1； 
2. 选定一个从库执行查询语句； 
3. 在从库上执行 select wait_for_executed_gtid_set(gtid1, 1)； 
4. 如果返回值是0，则在这个从库执行查询语句； 
5. 否则，到主库执行查询语句。

跟等主库位点的方案一样，等待超时后是否直接到主库查询，需要业务开发同学来做限流考虑。 我把这个流程图画出来。

<img src="MYSQL实战45讲.assets/image-20250227122626140.png" alt="image-20250227122626140" style="zoom:50%;" />

在上面的第一步中，trx1事务更新完成后，从返回包直接获取这个事务的GTID。问题是，怎么能 够让MySQL在执行事务后，返回包中带上GTID呢？

**你只需要将参数`session_track_gtids`设置为OWN_GTID，然后通过API接口 `mysql_session_track_get_first`从返回包解析出GTID的值即可**。



在专栏的第一篇文章中，我介绍mysql_reset_connection的时候，评论区有同学留言问这类接口 应该怎么使用。

这里我再回答一下。其实，MySQL并没有提供这类接口的SQL用法，是提供给程序的**API**(https://dev.mysql.com/doc/refman/5.7/en/c-api-functions.html)。



比如，为了让客户端在事务提交后，返回的GITD能够在客户端显示出来，我对**MySQL客户端代码**做了点修改，如下所示：

<img src="MYSQL实战45讲.assets/image-20250227122848607.png" alt="image-20250227122848607" style="zoom:50%;" />

这样，就可以看到语句执行完成，显示出GITD的值。

<img src="MYSQL实战45讲.assets/image-20250227122911447.png" alt="image-20250227122911447" style="zoom:50%;" />

当然了，这只是一个例子。你要使用这个方案的时候，还是应该在你的客户端代码中调用 mysql_session_track_get_first这个函数。



## 小结

在今天这篇文章中，我跟你介绍了一主多从做读写分离时，可能碰到过期读的原因，以及几种应对的方案。

这几种方案中，有的方案看上去是做了妥协，有的方案看上去不那么靠谱儿，但都是有实际应用场景的，你需要根据业务需求选择。

即使是最后等待位点和等待GTID这两个方案，虽然看上去比较靠谱儿，但仍然存在需要权衡的情况。如果所有的从库都延迟，那么请求就会全部落到主库上，这时候会不会由于压力突然增 大，把主库打挂了呢？ 

其实，在实际应用中，这几个方案是可以混合使用的。

比如，**先在客户端对请求做分类，区分哪些请求可以接受过期读，而哪些请求完全不能接受过期读**；然后，对于不能接受过期读的语句，再使用等GTID或等位点的方案。



但话说回来，过期读在本质上是由一写多读导致的。在实际应用中，可能会有别的不需要等待就 可以水平扩展的数据库方案，但这往往是用牺牲写性能换来的，也就是需要在读性能和写性能中取权衡。



### 思考题

假设你的系统采用了我们文中介绍的最后一个方案，也就是等GTID的方案，现在你要对主库的 一张大表做DDL，可能会出现什么情况呢？为了避免这种情况，你会怎么做呢？

> 回答

假设，这条语句在主库上要执行10分钟，提交后传到备库就要10分钟（典型的大事务）。那 么，在主库DDL之后再提交的事务的GTID，去备库查的时候，就会等10分钟才出现。 这样，这个读写分离机制在这10分钟之内都会超时，然后走主库。



这种预期内的操作，应该在业务低峰期的时候，确保主库能够支持所有业务查询，然后把读请求 都切到主库，再在主库上做DDL。等备库延迟追上以后，再把读请求切回备库。



通过这个思考题，我主要想让关注的是，大事务对等位点方案的影响。 当然了，使用gh-ost方案来解决这个问题也是不错的选择。



# 29 | 如何判断一个数据库是不是出问题了？

我在第25和27篇文章中，和你介绍了主备切换流程。通过这些内容的讲解，你应该已经很清楚 了：在一主一备的双M架构里，主备切换只需要把客户端流量切到备库；而在一主多从架构里， 主备切换除了要把客户端流量切到备库外，还需要把从库接到新主库上。



主备切换有两种场景，一种是主动切换，一种是被动切换。而其中被动切换，往往是因为主库出问题了，由HA系统（高可用系统）发起的。

这也就引出了我们今天要讨论的问题：怎么判断一个主库出问题了？

你一定会说，这很简单啊，连上MySQL，执行个select 1就好了。但是select 1成功返回了，就表示主库没问题吗？



## select 1判断

实际上，select 1成功返回，只能说明这个库的进程还在，并不能说明主库没问题。现在，我们来看一下这个场景。

```sql
set global innodb_thread_concurrency=3;
CREATE TABLE `t` (
    `id` int(11) NOTNULL,
    `c` int(11) DEFAULTNULL,
    PRIMARY KEY (`id`)
) ENGINE=InnoDB;
insert into t values(1,1)

```

<img src="MYSQL实战45讲.assets/image-20250228180921732.png" alt="image-20250228180921732" style="zoom:50%;" />



我们设置`innodb_thread_concurrency`参数的目的是，控制InnoDB的并发线程上限。

也就是说， 一旦并发线程数达到这个值，InnoDB在接收到新请求的时候，就会进入等待状态，直到有线程退出。

这里，我把innodb_thread_concurrency设置成3，表示InnoDB只允许3个线程并行执行。

而在我们的例子中，前三个session 中的sleep(100)，使得这三个语句都处于“执行”状态，以此来模拟大查询。



你看到了， session D里面，select 1是能执行成功的，但是查询表t的语句会被堵住。也就是 说，如果这时候我们用select 1来检测实例是否正常的话，是检测不出问题的。

在InnoDB中，innodb_thread_concurrency这个参数的默认值是0，表示不限制并发线程数量。 但是，不限制并发线程数肯定是不行的。因为，一个机器的CPU核数有限，线程全冲进来，上下 文切换的成本就会太高。

所以，通常情况下，我们建议把innodb_thread_concurrency设置为64~128之间的值。这时，你 一定会有疑问，并发线程上限数设置为128够干啥，线上的并发连接数动不动就上千了。



产生这个疑问的原因，是搞混了**并发连接和并发查询**。

并发连接和并发查询，并不是同一个概念。你在show process list的结果里，看到的几千个连 接，指的就是并发连接。而“当前正在执行”的语句，才是我们所说的并发查询。

并发连接数达到几千个影响并不大，就是多占一些内存而已。我们应该关注的是并发查询，因为 并发查询太高才是CPU杀手。这也是为什么我们需要设置innodb_thread_concurrency参数的原因。



然后，你可能还会想起我们在第7篇文章中讲到的热点更新和死锁检测的时候，如果把 innodb_thread_concurrency设置为128的话，那么出现同一行热点更新的问题时，是不是很快就 把128消耗完了，这样整个系统是不是就挂了呢？ ==> 不是

实际上，**在线程进入锁等待以后，并发线程的计数会减一，也就是说等行锁（也包括间隙 锁）的线程是不算在128里面的**。



MySQL这样设计是非常有意义的。因为，进入锁等待的线程已经不吃CPU了；更重要的是，必 须这么设计，才能避免整个系统锁死。



为什么呢？假设处于锁等待的线程也占并发线程的计数，你可以设想一下这个场景：

1. 线程1执行begin; update t set c=c+1 where id=1, 启动了事务trx1， 然后保持这个状态。这时候，线程处于空闲状态，不算在并发线程里面。 
2. 线程2到线程129都执行 update t set c=c+1 where id=1; 由于等行锁，进入等待状态。这样就有128个线程处于等待状态；
3. 如果处于锁等待状态的线程计数不减一，InnoDB就会认为线程数用满了，会阻止其他语句 进入引擎执行，这样线程1不能提交事务。而另外的128个线程又处于锁等待状态，整个系统就堵住了。



下图2显示的就是这个状态。

<img src="MYSQL实战45讲.assets/image-20250228181444867.png" alt="image-20250228181444867" style="zoom: 67%;" />

这时候InnoDB不能响应任何请求，整个系统被锁死。而且，由于所有线程都处于等待状态，此时占用的CPU却是0，而这明显不合理。所以，我们说InnoDB在设计时，遇到进程进入锁等待的情况时，将并发线程的计数减1的设计，是合理而且是必要的。

虽然说等锁的线程不算在并发线程计数里，但如果它在真正地执行查询，就比如我们上面例子中 前三个事务中的select sleep(100) fromt，还是要算进并发线程的计数的。



在这个例子中，同时在执行的语句超过了设置的innodb_thread_concurrency的值，这时候系统 其实已经不行了，但是通过select 1来检测系统，会认为系统还是正常的。

因此，我们使用select 1的判断逻辑要修改一下。



## 查表判断

为了能够检测InnoDB并发线程数过多导致的系统不可用情况，我们需要找一个访问InnoDB的场景。

一般的做法是，在系统库（mysql库）里创建一个表，比如命名为health_check，里面只放 一行数据，然后定期执行：

```
mysql> select * from mysql.health_check;
```

使用这个方法，我们可以检测出由于并发线程过多导致的数据库不可用的情况。

但是，我们马上还会碰到下一个问题，即：**空间满了以后，这种方法又会变得不好使**。

我们知道，**更新事务要写binlog，而一旦binlog所在磁盘的空间占用率达到100%，那么所有的更新语句和事务提交的commit语句就都会被堵住**。但是，系统这时候还是可以正常读数据的。

因此，我们还是把这条监控语句再改进一下。接下来，我们就看看把查询语句改成更新语句后的 效果。



## 更新判断

既然要更新，就要放个有意义的字段，常见做法是放一个timestamp字段，用来表示最后一次执 行检测的时间。这条更新语句类似于：

```sql
mysql> update mysql.health_check set t_modified=now();
```

节点可用性的检测都应该包含主库和备库。如果用更新来检测主库的话，那么备库也要进行更新检测。



但，备库的检测也是要写binlog的。由于我们一般会把数据库A和B的主备关系设计为双M结构， 所以在备库B上执行的检测命令，也要发回给主库A。

但是，如果主库A和备库B都用相同的更新命令，就可能出现行冲突，也就是可能会导致主备同 步停止。所以，现在看来mysql.health_check 这个表就不能只有一行数据了。



为了让主备之间的更新不产生冲突，我们可以在mysql.health_check表上存入多行数据，并用 A、B的server_id做主键。

```sql
mysql> CREATE TABLE `health_check` (
    `id` int(11) NOTNULL,
    `t_modified` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (`id`)
) ENGINE=InnoDB;

/* 检测命令 */
insert into mysql.health_check(id, t_modified) values (@@server_id, now()) on duplicate key update t_modified=now();
```



由于MySQL规定了主库和备库的server_id必须不同（否则创建主备关系的时候就会报错），这样就可以保证主、备库各自的检测命令不会发生冲突。

更新判断是一个相对比较常用的方案了，不过依然存在一些问题。其中，**“判定慢”**一直是让DBA头疼的问题。



你一定会疑惑，更新语句，如果失败或者超时，就可以发起主备切换了，为什么还会有判定 慢的问题呢？

其实，这里涉及到的是服务器IO资源分配的问题。



首先，所有的检测逻辑都需要一个超时时间N。执行一条update语句，超过N秒后还不返回，就认为系统不可用。

你可以设想一个日志盘的IO利用率已经是100%的场景。这时候，整个系统响应非常慢，已经需要做主备切换了。



但是你要知道，IO利用率100%表示系统的IO是在工作的，每个请求都有机会获得IO资源，执行自己的任务。而我们的检测使用的update命令，需要的资源很少，所以可能在拿到IO资源的时 候就可以提交成功，并且在超时时间N秒未到达之前就返回给了检测系统。

检测系统一看，update命令没有超时，于是就得到了“系统正常”的结论。

也就是说，这时候在业务系统上正常的SQL语句已经执行得很慢了，但是DBA上去一看，HA系 统还在正常工作，并且认为主库现在处于可用状态。



之所以会出现这个现象，根本原因是我们上面说的所有方法，都是基于外部检测的。**外部检测天然有一个问题，就是随机性**。

因为，外部检测都需要定时轮询，所以系统可能已经出问题了，但是却需要等到下一个检测发起 执行语句的时候，我们才有可能发现问题。而且，如果你的运气不够好的话，可能第一次轮询还 不能发现，这就会导致切换慢的问题。

所以，接下来我要再和你介绍一种在MySQL内部发现数据库问题的方法。



## 内部统计

针对磁盘利用率这个问题，如果MySQL可以告诉我们，内部每一次IO请求的时间，那我们判断数据库是否出问题的方法就可靠得多了。

其实，MySQL 5.6版本以后提供的performance_schema库，就在file_summary_by_event_name 表里统计了每次IO请求的时间。

file_summary_by_event_name表里有很多行数据，我们先来看看 event_name='wait/io/file/innodb/innodb_log_file’这一行。

<img src="MYSQL实战45讲.assets/image-20250228182921633.png" alt="image-20250228182921633" style="zoom: 67%;" />



图中这一行表示统计的是redo log的写入时间，第一列EVENT_NAME 表示统计的类型。

接下来的三组数据，显示的是redo log操作的时间统计。

第一组五列，是所有IO类型的统计。其中，COUNT_STAR是所有IO的总次数，接下来四列是具 体的统计项， 单位是皮秒；前缀SUM、MIN、AVG、MAX，顾名思义指的就是总和、最小值、 平均值和最大值。



第二组六列，是读操作的统计。最后一列SUM_NUMBER_OF_BYTES_READ统计的是，总共 从redo log里读了多少个字节。

第三组六列，统计的是写操作。

最后的第四组数据，是对其他类型数据的统计。在redo log里，你可以认为它们就是对fsync的统 计。



在performance_schema库的file_summary_by_event_name表里，binlog对应的是event_name = "wait/io/file/sql/binlog"这一行。各个字段的统计逻辑，与redo log的各个字段完全相同。这里，我 就不再赘述了。



因为我们每一次操作数据库，performance_schema都需要额外地统计这些信息，所以我们打开这个统计功能是有性能损耗的。

我的测试结果是，如果打开所有的performance_schema项，**性能大概会下降10%左右**。所以， 我建议你只打开自己需要的项进行统计。你可以通过下面的方法打开或者关闭某个具体项的统 计。



如果要打开redo log的时间监控，你可以执行这个语句

```sql
mysql> update setup_instruments set ENABLED='YES', Timed='YES' where name like '%wait/io/file/innodb/innodb_log_file%';

mysql> select * from  performance_schema.setup_instruments where name like '%wait/io/file/innodb/innodb_log_file';
+-------------------------------------+---------+-------+------------+------------+---------------+
| NAME                                | ENABLED | TIMED | PROPERTIES | VOLATILITY | DOCUMENTATION |
+-------------------------------------+---------+-------+------------+------------+---------------+
| wait/io/file/innodb/innodb_log_file | YES     | YES   |            |          0 | NULL          |
+-------------------------------------+---------+-------+------------+------------+---------------+
1 row in set (0.00 sec)
```



假设，现在你已经开启了redo log和binlog这两个统计信息，那要怎么把这个信息用在实例状态诊断上呢？

很简单，你可以通过MAX_TIMER的值来判断数据库是否出问题了。比如，你可以设定阈值，单次IO请求时间超过200毫秒属于异常，然后使用类似下面这条语句作为检测逻辑。

```sql
mysql> select event_name,MAX_TIMER_WAIT FROM performance_schema.file_summary_by_event_name where event_name = 'wait/io/file/innodb/innodb_log_file' and MAX_TIMER_WAIT > 200000;
```

发现异常后，取到你需要的信息，再通过下面这条语句：

```
mysql> truncate table performance_schema.file_summary_by_event_name;
```

把之前的统计信息清空。这样如果后面的监控中，再次出现这个异常，就可以加入监控累积值 了。



## 小结

今天，我和你介绍了检测一个MySQL实例健康状态的几种方法，以及各种方法存在的问题和演进的逻辑。

你看完后可能会觉得，select 1这样的方法是不是已经被淘汰了呢，但实际上使用非常广泛的 MHA（MasterHigh Availability），默认使用的就是这个方法。

MHA中的另一个可选方法是只做连接，就是 “如果连接成功就认为主库没问题”。不过据我所 知，选择这个方法的很少。

其实，每个改进的方案，都会增加额外损耗，并不能用“对错”做直接判断，需要你根据业务实际 情况去做权衡。

我个人比较倾向的方案，是优先考虑update系统表，然后再配合增加检测performance_schema 的信息。



### 思考题

今天，我想问你的是：业务系统一般也有高可用的需求，在你开发和维护过的服务中，你是怎么判断服务有没有出问题的呢？

> 回答

我在上一篇文章最后留给的问题，是分享一下你关于业务监控的处理经验。 在这篇文章的评论区，很多同学都分享了不错的经验。这里，我就选择几个比较典型的留言，和你分享吧：

@老杨同志 回答得很详细。他的主要思路就是关于服务状态和服务质量的监控。其中，服务状态的监控，一般都可以用外部系统来实现；而服务的质量的监控，就要通过**接口的响应**时间来统计。

@Ryoma 同学，提到服务中使用了healthCheck来检测，其实跟我们文中提到的select 1的模 式类似。

@强哥 同学，按照监控的对象，监控分成了基础监控、服务监控和业务监控，并分享了每 种监控需要关注的对象。



# 30 | 答疑文章（二）：用动态的观点看加锁

> 后续看

在第20和21篇文章中，我和你介绍了InnoDB的间隙锁、next-key lock，以及加锁规则。在这两 篇文章的评论区，出现了很多高质量的留言。我觉得通过分析这些问题，可以帮助你加深对加锁 规则的理解。 所以，我就从中挑选了几个有代表性的问题，构成了今天这篇答疑文章的主题，即：用动态的观点看加锁。







## 不等号条件里的等值查询

## 等值查询的过程

## 怎么看死锁？

## 怎么看锁等待？

## update的例子





# 31 | 误删数据后除了跑路，还能怎么办？

今天我要和你讨论的是一个沉重的话题：误删数据。

在前面几篇文章中，我们介绍了MySQL的高可用架构。当然，传统的高可用架构是不能预防误 删数据的，因为主库的一个drop table命令，会通过binlog传给所有从库和级联从库，进而导致整 个集群的实例都会执行这个命令。



虽然我们之前遇到的大多数的数据被删，都是运维同学或者DBA背锅的。但实际上，只要有数 据操作权限的同学，都有可能踩到误删数据这条线。



今天我们就来聊聊误删数据前后，我们可以做些什么，减少误删数据的风险，和由误删数据带来的损失。 

为了找到解决误删数据的更高效的方法，我们需要先对和MySQL相关的误删数据，做下分类：

1. 使用delete语句误删数据行； 
2. 使用drop table或者truncate table语句误删数据表； 
3. 使用drop database语句误删数据库； 
4. 使用rm命令误删整个MySQL实例。

## 误删行

在第24篇文章中，我们提到如果是使用delete语句误删了数据行，可以用Flashback工具通过闪回把数据恢复回来。

Flashback恢复数据的原理，是修改binlog的内容，拿回原库重放。而能够使用这个方案的前提 是，需要确保binlog_format=row和 binlog_row_image=FULL。

具体恢复数据时，对单个事务做如下处理：

1. 对于insert语句，对应的binlog event类型是Write_rows event，把它改成Delete_rows event 即可； 
2. 同理，对于delete语句，也是将Delete_rows event改为Write_rows event； 
3. 而如果是Update_rows的话，binlog里面记录了数据行修改前和修改后的值，对调这两行的 位置即可。

如果误操作不是一个（事务），而是多个，会怎么样呢？比如下面三个事务：

```
(A)delete ...
(B)insert ...
(C)update ...
```

现在要把数据库恢复回这三个事务操作之前的状态，用Flashback工具解析binlog后，写回主库 的命令是：

```
(reverse C)update ...
(reverse B)delete ...
(reverseA)insert ...
```

也就是说，如果误删数据涉及到了多个事务的话，需要将事务的顺序调过来再执行。



**需要说明的是，我不建议你直接在主库上执行这些操作**。 

**恢复数据比较安全的做法，是恢复出一个备份，或者找一个从库作为临时库，在这个临时库上执行这些操作，然后再将确认过的临时库的数据，恢复回主库**。



为什么要这么做呢？

这是因为，一个在执行线上逻辑的主库，数据状态的变更往往是有关联的。可能由于发现数据问 题的时间晚了一点儿，就导致已经在之前误操作的基础上，业务代码逻辑又继续修改了其他数 据。所以，如果这时候单独恢复这几行数据，而又未经确认的话，就可能会出现对数据的二次破坏。



当然，我们不止要说误删数据的事后处理办法，**更重要是要做到事前预防**。我有以下两个建议：

1. 把sql_safe_updates参数设置为on。这样一来，如果我们忘记在delete或者update语句中写 where条件，或者where条件里面没有包含索引字段的话，这条语句的执行就会报错。
2. 代码上线前，必须经过SQL审计。

如果你确定这个删除操作没问题的话，可以在delete语句中加上where条件，比如where id>=0。

但是，delete全表是很慢的，需要生成回滚日志、写redo、写binlog。所以，从性能角度考虑， 你应该优先考虑使用truncate table或者drop table命令。

> `TRUNCATE TABLE` 和 `DROP TABLE` 是用于删除数据库表的两个不同的命令，它们之间有以下区别：
>
> 1. 功能：`TRUNCATE TABLE` 用于删除表中的所有数据，但保留表的结构和定义。它将重置表的自增计数器，并释放表占用的存储空间。而 `DROP TABLE` 则完全删除整个表，包括表的结构、定义和数据，同时也会释放表占用的存储空间。
> 2. 权限：执行 `TRUNCATE TABLE` 需要对表具有 `TRUNCATE` 权限，而执行 `DROP TABLE` 需要对表具有 `DROP` 权限。
> 3. 回滚：`TRUNCATE TABLE` 操作无法回滚，一旦执行完成，数据将无法恢复。而 `DROP TABLE` 可以在某些情况下使用事务进行回滚，以恢复被删除的表。
> 4. 依赖关系：`TRUNCATE TABLE` 不会触发与表相关的触发器、约束和索引的操作。而 `DROP TABLE` 将删除表及其相关的触发器、约束和索引。
> 5. 速度：由于 `TRUNCATE TABLE` 只删除表中的数据而不删除表的结构，因此通常比 `DROP TABLE` 更快。
>
> 根据您的需求，选择适合的命令。如果您只想删除表中的数据而保留表的结构，可以使用 `TRUNCATE TABLE`。如果您想完全删除表，包括表的结构和定义，可以使用 `DROP TABLE`。
>
> 请注意，在执行这些命令之前，请确保您理解其影响，并在生产环境中谨慎操作。在执行任何删除操作之前，建议先备份重要的数据。



使用delete命令删除的数据，你还可以用Flashback来恢复。而使用truncate /drop table和drop database命令删除的数据，就没办法通过Flashback来恢复了。为什么呢？

**这是因为，即使我们配置了binlog_format=row，执行这三个命令时，记录的binlog还是 statement格式。binlog里面就只有一个truncate/drop 语句，这些信息是恢复不出数据的**。



那么，如果我们真的是使用这几条命令误删数据了，又该怎么办呢？



## 误删库/表

这种情况下，要想恢复数据，就**需要使用全量备份，加增量日志的方式了**。

这个方案要求**线上有定期的全量备份**，并且**实时备份binlog**。

在这两个条件都具备的情况下，假如有人中午12点误删了一个库，恢复数据的流程如下：

1. 取最近一次全量备份，假设这个库是一天一备，上次备份是当天0点； 
2. 用备份恢复出一个临时库； 
3. 从日志备份里面，取出凌晨0点之后的日志； 
4. 把这些日志，**除了误删除数据的语句外**，全部应用到临时库。

这个流程的示意图如下所示：

<img src="MYSQL实战45讲.assets/image-20250304190555355.png" alt="image-20250304190555355" style="zoom:50%;" />

关于这个过程，我需要和你说明如下几点：

1. 为了加速数据恢复，如果这个临时库上有多个数据库，你可以在使用mysqlbinlog命令时，加 上一个**–database参数**，用来指定误删表所在的库。这样，就避免了在恢复数据时还要应用 其他库日志的情况。

2. 在应用日志的时候，需要跳过12点误操作的那个语句的binlog：

   - 如果原实例没有使用GTID模式，只能在应用到包含12点的binlog文件的时候，先用– stop-position参数执行到误操作之前的日志，然后再用–start-position从误操作之后的日 志继续执行；
   - 如果实例使用了GTID模式，就方便多了。假设误操作命令的GTID是gtid1，那么只需要 执行set gtid_next=gtid1;begin;commit; 先把这个GTID加到临时实例的GTID集合，之后 按顺序执行binlog的时候，就会自动跳过误操作的语句。

   

不过，即使这样，使用mysqlbinlog方法恢复数据还是不够快，主要原因有两个：

1. 如果是误删表，最好就是只恢复出这张表，也就是只重放这张表的操作，但是mysqlbinlog工 具并不能指定只解析一个表的日志；
2. 用mysqlbinlog解析出日志应用，应用日志的过程就只能是单线程。我们在第26篇文章中介 绍的那些并行复制的方法，在这里都用不上。

**一种加速的方法是，在用备份恢复出临时实例之后，将这个临时实例设置成线上备库的从库**， 这样：

1. 在start slave之前，先通过执行 change replication filter replicate_do_table = (tbl_name) 命令，就可以让临时库只同步误操 作的表； 
2. 这样做也可以用上并行复制技术，来加速整个数据恢复过程。



这个过程的示意图如下所示。

<img src="MYSQL实战45讲.assets/image-20250304190928482.png" alt="image-20250304190928482" style="zoom:50%;" />

可以看到，图中binlog备份系统到线上备库有一条虚线，是指如果由于时间太久，备库上已经删 除了临时实例需要的binlog的话，我们可以从binlog备份系统中找到需要的binlog，再放回备库 中。

假设，我们发现当前临时实例需要的binlog是从master.000005开始的，但是在备库上执行show binlogs 显示的最小的binlog文件是master.000007，意味着少了两个binlog文件。这时，我们就 需要去binlog备份系统中找到这两个文件。

把之前删掉的binlog放回备库的操作步骤，是这样的：

1. 从备份系统下载master.000005和master.000006这两个文件，放到备库的日志目录下； 
2. 打开日志目录下的master.index文件，在文件开头加入两行，内容分别是 “./master.000005”和“./master.000006”; 
3. 重启备库，目的是要让备库重新识别这两个日志文件； 
4. 现在这个备库上就有了临时库需要的所有binlog了，建立主备关系，就可以正常同步了。

不论是把mysqlbinlog工具解析出的binlog文件应用到临时库，还是把临时库接到备库上，这两个 方案的共同点是：误删库或者表后，恢复数据的思路主要就是通过备份，再加上应用binlog的方 式。

也就是说，这两个方案都要求备份系统定期备份全量日志，而且需要确保binlog在被从本地删除 之前已经做了备份。

但是，一个系统不可能备份无限的日志，你还需要根据成本和磁盘空间资源，设定一个日志保留 的天数。如果你的DBA团队告诉你，可以保证把某个实例恢复到半个月内的任意时间点，这就 表示备份系统保留的日志时间就至少是半个月。

另外，我建议你不论使用上述哪种方式，都要把这个数据恢复功能做成自动化工具，并且经常拿 出来演练。为什么这么说呢？

这里的原因，主要包括两个方面：

1. 虽然“发生这种事，大家都不想的”，但是万一出现了误删事件，能够快速恢复数据，将损失 降到最小，也应该不用跑路了。 
2. 而如果临时再手忙脚乱地手动操作，最后又误操作了，对业务造成了二次伤害，那就说不过 去了。

## 延迟复制备库

虽然我们可以通过利用并行复制来加速恢复数据的过程，但是这个方案仍然存在“恢复时间不可 控”的问题。

如果一个库的备份特别大，或者误操作的时间距离上一个全量备份的时间较长，比如一周一备的 实例，在备份之后的第6天发生误操作，那就需要恢复6天的日志，这个恢复时间可能是要按天 来计算的。

那么，我们有什么方法可以缩短恢复数据需要的时间呢？

如果有非常核心的业务，不允许太长的恢复时间，我们可以考虑**搭建延迟复制的备库**。这个功 能是MySQL 5.6版本引入的。

一般的主备复制结构存在的问题是，如果主库上有个表被误删了，这个命令很快也会被发给所有 从库，进而导致所有从库的数据表也都一起被误删了。

延迟复制的备库是一种特殊的备库，通过 CHANGE MASTER TOMASTER_DELAY =N命令， 可以指定这个备库持续保持跟主库有N秒的延迟。

比如你把N设置为3600，这就代表了如果主库上有数据被误删了，并且在1小时内发现了这个误 操作命令，这个命令就还没有在这个延迟复制的备库执行。这时候到这个备库上执行stop slave，再通过之前介绍的方法，跳过误操作命令，就可以恢复出需要的数据。



## 预防误删库/表的方法

虽然常在河边走，很难不湿鞋，但终究还是可以找到一些方法来避免的。所以这里，我也会给你 一些减少误删操作风险的建议。

第一条建议是，**账号分离**。这样做的目的是，避免写错命令。比如：

- 我们只给业务开发同学DML权限，而不给truncate/drop权限。而如果业务开发人员有DDL需 求的话，也可以通过开发管理系统得到支持。 
- 即使是DBA团队成员，日常也都规定只使用只读账号，必要的时候才使用有更新权限的账号。

第二条建议是，**制定操作规范**。这样做的目的，是避免写错要删除的表名。比如：

- **在删除数据表之前，必须先对表做改名操作。**然后，观察一段时间，确保对业务无影响以后 再删除这张表。 
- 改表名的时候，要求给表名**加固定的后缀**（比如加_to_be_deleted)，然后删除表的动作必须 通过管理系统执行。并且，管理系删除表的时候，只能删除固定后缀的表。







## rm删除数据

其实，对于一个有高可用机制的MySQL集群来说，最不怕的就是rm删除数据了。

只要不是恶意地把整个集群删除，而只是删掉了其中某一个节点的数据的话，HA系统就会开始工作，选出一 个新的主库，从而保证整个集群的正常工作。



这时，你要做的就是在这个节点上把数据恢复回来，再接入整个集群。

当然了，现在不止是DBA有自动化系统，SA（系统管理员）也有自动化系统，所以也许一个批 量下线机器的操作，会让你整个MySQL集群的所有节点都全军覆没。

应对这种情况，我的建议只能是说尽量把你的备份跨机房，或者最好是跨城市保存。



## 小结

今天，我和你讨论了误删数据的几种可能，以及误删后的处理方法。

但，我要强调的是，预防远比处理的意义来得大。

另外，在MySQL的集群方案中，会时不时地用到备份来恢复实例，因此定期检查备份的有效性 也很有必要。

如果你是业务开发同学，你可以用show grants命令查看账户的权限，如果权限过大，可以建议 DBA同学给你分配权限低一些的账号；你也可以评估业务的重要性，和DBA商量备份的周期、 是否有必要创建延迟复制的备库等等。

```sql
mysql> show grants;
+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Grants for root@%                                                                                                                                                                                                                                                                                                                                                         |
+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| GRANT SELECT, INSERT, UPDATE, DELETE, CREATE, DROP, RELOAD, PROCESS, REFERENCES, INDEX, ALTER, SHOW DATABASES, CREATE TEMPORARY TABLES, LOCK TABLES, EXECUTE, REPLICATION SLAVE, REPLICATION CLIENT, CREATE VIEW, SHOW VIEW, CREATE ROUTINE, ALTER ROUTINE, CREATE USER, EVENT, TRIGGER, CREATE TABLESPACE, CREATE ROLE, DROP ROLE ON *.* TO `root`@`%` WITH GRANT OPTION |
| GRANT APPLICATION_PASSWORD_ADMIN,AUDIT_ABORT_EXEMPT,AUTHENTICATION_POLICY_ADMIN,FIREWALL_EXEMPT,FLUSH_OPTIMIZER_COSTS,FLUSH_STATUS,FLUSH_TABLES,FLUSH_USER_RESOURCES,GROUP_REPLICATION_STREAM,PASSWORDLESS_USER_ADMIN,READ_MASK,ROLE_ADMIN,SENSITIVE_VARIABLES_OBSERVER,SHOW_ROUTINE,XA_RECOVER_ADMIN ON *.* TO `root`@`%` WITH GRANT OPTION                              |
+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
2 rows in set (0.00 sec)
```

数据和服务的可靠性不止是运维团队的工作，最终是各个环节一起保障的结果。

### 问题

今天的课后话题是，回忆下你亲身经历过的误删数据事件吧，你用了什么方法来恢复数据呢？你 在这个过程中得到的经验又是什么呢？

> 回答

@苍茫 同学提到了一个例子，我觉得值得跟大家分享一下。运维的同学直接拷贝文本去执 行，SQL语句截断，导致数据库执行出错。

从浏览器拷贝文本执行，是一个非常不规范的操作。除了这个例子里面说的SQL语句截断问题， 还可能存在乱码问题。

一般这种操作，如果脚本的开发和执行不是同一个人，需要开发同学把脚本放到git上，然后把 git地址，以及文件的md5发给运维同学。

这样就要求运维同学在执行命令之前，确认要执行的文件的md5，跟之前开发同学提供的md5相 同才能继续执行。



@linhui0705 同学提到的“四个脚本”的方法，我非常推崇。这四个脚本分别是：备份脚本、 执行脚本、验证脚本和回滚脚本。如果能够坚持做到，即使出现问题，也是可以很快恢复的，一 定能降低出现故障的概率。 不过，这个方案最大的敌人是这样的思想：这是个小操作，不需要这么严格。



@Knight²º¹ 给了一个保护文件的方法，我之前没有用过这种方法，不过这确实是一个不错的 思路。





# 32 | 为什么还有kill不掉的语句？



# 33 | 我查这么多数据，会不会把数据库内存打爆？



# 34.到底可不可以使用join？

在实际生产中，关于join语句使用的问题，一般会集中在以下两类：

1. 我们DBA不让使用join，使用join有什么问题呢？ 
2. 如果有两个大小不同的表做join，应该用哪个表做驱动表呢？



今天这篇文章，我就先跟你说说**join语句到底是怎么执行的，然后再来回答这两个问题**。 为了便于量化分析，我还是创建两个表t1和t2来和你说明。

```sql
CREATE TABLE `t2` (
    `id` int(11) NOT NULL,
    `a` int(11) DEFAULT NULL,
    `b` int(11) DEFAULT NULL,
    PRIMARY KEY (`id`),
    KEY `a` (`a`)
) ENGINE=InnoDB;

drop procedure idata;
delimiter ;;
create procedure idata()
begin
    declare i int;
    set i=1;
    while(i<=1000)do
        insert into t2 values(i, i, i);
        set i=i+1;
    end while;
end;;
delimiter ;
call idata();

create table t1 like t2;
insert into t1 (select * from t2 where id<=100);

```

可以看到，这两个表都有一个主键索引id和一个索引a，字段b上无索引。存储过程idata()往表t2 里插入了1000行数据，在表t1里插入的是100行数据。



## Index Nested-Loop Join

> 索引嵌套循环联接

我们来看一下这个语句：

```sql
mysql> select * from t1 straight_join t2 on (t1.a=t2.a) limit 1;
+----+------+------+----+------+------+
| id | a    | b    | id | a    | b    |
+----+------+------+----+------+------+
|  1 |    1 |    1 |  1 |    1 |    1 |
+----+------+------+----+------+------+
1 row in set (0.00 sec)
```

如果直接使用join语句，MySQL优化器可能会选择表t1或t2作为驱动表，这样会影响我们分析 SQL语句的执行过程。所以，为了便于分析执行过程中的性能问题，我改用**straight_join让 MySQL使用固定的连接方式**执行查询，这样优化器只会按照我们指定的方式去join。在这个语句里，t1 是驱动表，t2是被驱动表。

现在，我们来看一下这条语句的explain结果。

<img src="MYSQL实战45讲.assets/image-20250307192227660.png" alt="image-20250307192227660" style="zoom: 33%;" />

```sql
explain select * from t1 straight_join t2 on (t1.a=t2.a);
```

可以看到，在这条语句里，被驱动表t2的字段a上有索引，join过程用上了这个索引，因此这个语句的执行流程是这样的：

1. 从表t1中读入一行数据 R；
2. 从数据行R中，取出a字段到表t2里去查找； 
3. 取出表t2中满足条件的行，跟R组成一行，作为结果集的一部分； 
4. 重复执行步骤1到3，直到表t1的末尾循环结束。

这个过程是先遍历表t1，然后根据从表t1中取出的每行数据中的a值，去表t2中查找满足条件的记录。

在形式上，这**个过程就跟我们写程序时的嵌套查询类似(两层for循环）**，并且**可以用上被驱动表的索引**， 所以我们称之为“IndexNested-Loop Join”，简称NLJ。

它对应的流程图如下所示：

<img src="MYSQL实战45讲.assets/image-20250307192706869.png" alt="image-20250307192706869" style="zoom:50%;" />





在这个流程里： 

1. 对驱动表t1做了全表扫描，这个过程需要扫描100行；
2. 而对于每一行R，根据a字段去表t2查找，**走的是树搜索过程**。由于我们构造的数据都是一一 对应的，因此每次的搜索过程都只扫描一行，也是总共扫描100行； 
3. 所以，整个执行流程，总扫描行数是200。



现在我们知道了这个过程，再试着回答一下文章开头的两个问题。

> 先看第一个问题：能不能使用join?

假设不使用join，那我们就只能用单表查询。我们看看上面这条语句的需求，用单表查询怎么实现。

1. 执行select * from t1，查出表t1的所有数据，这里有100行；
2. 循环遍历这100行数据：
   1. 从每一行R取出字段a的值$R.a； 
   2. 执行select * from t2 where a=$R.a； 
   3. 把返回的结果和R构成结果集的一行。

可以看到，在这个查询过程，也是扫描了200行，但是总共执行了101条语句，比直接join多了 100次交互。除此之外，客户端还要自己拼接SQL语句和结果。

显然，这么做还不如直接join好。



> 我们再来看看第二个问题：怎么选择驱动表？

在这个join语句执行过程中，**驱动表是走全表扫描，而被驱动表是走树搜索**。==》驱动表选择小表

假设被驱动表的行数是M。每次在被驱动表查一行数据，要先搜索索引a，再搜索主键索引。每 次搜索一棵树近似复杂度是以2为底的M的对数，记为<img src="MYSQL实战45讲.assets/image-20250307193517496.png" alt="image-20250307193517496" style="zoom:50%;" />，所以在被驱动表上查一行的时间复杂度是 2*log M。



假设驱动表的行数是N，执行过程就要扫描驱动表N行，然后对于每一行，到被驱动表上匹配一 次。

因此整个执行过程，近似复杂度是 `N+N*2*log M`。



显然，**N对扫描行数的影响更大，因此应该让小表来做驱动表**。

> 如果你没觉得这个影响有那么“显然”， 可以这么理解：N扩大1000倍的话，扫描行数就会扩大 1000倍；而M扩大1000倍，扫描行数扩大不到10倍。



到这里小结一下，通过上面的分析我们得到了两个结论：

1. 使用join语句，性能比强行拆成多个单表执行SQL语句的性能要好；
2. 如果使用join语句的话，需要让小表做驱动表。



但是，你需要注意，这个结论的前提是“可以使用被驱动表的索引”。

接下来，我们再看看被驱动表用不上索引的情况。



## Simple Nested-Loop Join

现在，我们把SQL语句改成这样：

```sql
select * from t1 straight_join t2 on (t1.a=t2.b);
```

由于表t2的字段b上没有索引，因此再用图2的执行流程时，每次到t2去匹配的时候，就要做一次全表扫描。

![image-20250307194036529](MYSQL实战45讲.assets/image-20250307194036529.png)

你可以先设想一下这个问题，继续使用图2的算法，是不是可以得到正确的结果呢？如果只看结 果的话，这个算法是正确的，而且这个算法也有一个名字，叫做“Simple Nested-Loop Join”。

但是，这样算来，这个SQL请求就要扫描表t2多达100次，总共扫描100*1000=10万行。

这还只是两个小表，如果t1和t2都是10万行的表（当然了，这也还是属于小表的范围），就要扫 描100亿行，这个算法看上去太“笨重”了。



当然，MySQL也没有使用这个Simple Nested-Loop Join算法，而是使用了另一个叫作“Block Nested-Loop Join”的算法，简称BNL。



## Block Nested-Loop Join

这时候，被驱动表上没有可用的索引，算法的流程是这样的：

1. 把表t1的数据读入线程内存join_buffer中，由于我们这个语句中写的是select *，因此是把整 个表t1放入了内存；
2. 扫描表t2，把表t2中的每一行取出来，跟join_buffer中的数据做对比，满足join条件的，作为结果集的一部分返回。

这个过程的流程图如下：

<img src="MYSQL实战45讲.assets/image-20250307194322345.png" alt="image-20250307194322345" style="zoom:50%;" />



对应地，这条SQL语句的explain结果如下所示：

<img src="MYSQL实战45讲.assets/image-20250307194352958.png" alt="image-20250307194352958" style="zoom: 67%;" />



可以看到，在这个过程中，对表t1和t2都做了一次全表扫描，因此总的扫描行数是1100。由于 join_buffer是以无序数组的方式组织的，因此对表t2中的每一行，都要做100次判断，总共需要 在内存中做的判断次数是：100*1000=10万次。



前面我们说过，如果使用Simple Nested-Loop Join算法进行查询，扫描行数也是10万行。因 此，从时间复杂度上来说，这两个算法是一样的。但是，Block Nested-Loop Join算法的这10万 次判断是内存操作，速度上会快很多，性能也更好。



接下来，我们来看一下，在这种情况下，应该选择哪个表做驱动表。

假设小表的行数是N，大表的行数是M，那么在这个算法里：

1. 两个表都做一次全表扫描，所以总的扫描行数是M+N； 
2. 内存中的判断次数是M*N。 

可以看到，**调换这两个算式中的M和N没差别，因此这时候选择大表还是小表做驱动表，执行耗时是一样的**。



然后，你可能马上就会问了，这个例子里表t1才100行，要是表t1是一个大表，**join_buffer放不下怎么办呢**？

join_buffer的大小是由参数`join_buffer_size`设定的，默认值是256k。

**如果放不下表t1的所有数 据话，策略很简单，就是分段放**。我把join_buffer_size改成1200，再执行：

```sql
select * from t1 straight_join t2 on (t1.a=t2.b)
```

执行过程就变成了：

1. 扫描表t1，顺序读取数据行放入join_buffer中，放完第88行join_buffer满了，继续第2步； 
2. 扫描表t2，把t2中的每一行取出来，跟join_buffer中的数据做对比，满足join条件的，作为结果集的一部分返回； 
3. 清空join_buffer； 
4. 继续扫描表t1，顺序读取最后的12行数据放入join_buffer中，继续执行第2步。



执行流程图也就变成这样：

<img src="MYSQL实战45讲.assets/image-20250307194735158.png" alt="image-20250307194735158" style="zoom:50%;" />

图中的步骤4和5，表示清空join_buffer再复用。

这个流程才体现出了这个算法名字中“Block”的由来，表示“**分块去join**”。

可以看到，这时候由于表t1被分成了两次放入join_buffer中，导致表t2会被扫描两次。虽然分成 两次放入join_buffer，但是判断等值条件的次数还是不变的，依然是(88+12)*1000=10万次。

我们再来看下，在这种情况下驱动表的选择问题。

假设，驱动表的数据行数是N，需要分K段才能完成算法流程，被驱动表的数据行数是M。

注意，这里的K不是常数，N越大K就会越大，因此把K表示为λ*N，显然λ的取值范围是(0,1)。



所以，在这个算法的执行过程中： 

1. 扫描行数是 N+λ*N*M； 
2. 内存判断 N*M次。

显然，内存判断次数是不受选择哪个表作为驱动表影响的。而考虑到扫描行数，在M和N大小确 定的情况下，N小一些，整个算式的结果会更小。

所以结论是，应该**让小表当驱动表**。



当然，你会发现，在N+λ*N*M这个式子里，λ才是影响扫描行数的关键因素，这个值越小越好。

刚刚我们说了N越大，分段数K越大。那么，N固定的时候，什么参数会影响K的大小呢？（也就 是λ的大小）答案是join_buffer_size。join_buffer_size越大，一次可以放入的行越多，分成的段 数也就越少，对被驱动表的全表扫描次数就越少。



这就是为什么，你可能会看到一些建议告诉你，如果你的join语句很慢，就把join_buffer_size改 大。



理解了MySQL执行join的两种算法，现在我们再来试着回答文章开头的两个问题。



> 第一个问题：能不能使用join语句？

1. **如果可以使用IndexNested-Loop Join算法，也就是说可以用上被驱动表上的索引，其实是没问题的**； 
2. 如果使用Block Nested-Loop Join算法，扫描行数就会过多。尤其是在大表上的join操作，这 样可能要扫描被驱动表很多次，会占用大量的系统资源。所以这种join尽量不要用。



所以你在判断要不要使用join语句时，就是看explain结果里面，**Extra字段里面有没有出现“Block Nested Loop”字样**。



> 第二个问题是：如果要使用join，应该选择大表做驱动表还是选择小表做驱动表？

1. 如果是IndexNested-Loop Join算法，应该选择小表做驱动表； 
2. 如果是Block Nested-Loop Join算法： 在join_buffer_size足够大的时候，是一样的； 在join_buffer_size不够大的时候（这种情况更常见），应该选择小表做驱动表。

所以，这个问题的结论就是，总是应该使用小表做驱动表。



当然了，这里我需要说明下，什么叫作“小表”。

我们前面的例子是没有加条件的。如果我在语句的where条件加上 t2.id<=50这个限定条件，再来 看下这两条语句：

```sql
select * from t1 straight_join t2 on (t1.b=t2.b) where t2.id<=50;
select * from t2 straight_join t1 on (t1.b=t2.b) where t2.id<=50;
```

注意，为了让两条语句的被驱动表都用不上索引，所以join字段都使用了没有索引的字段b。

但如果是用第二个语句的话，join_buffer只需要放入t2的前50行，显然是更好的。所以这里，“t2 的前50行”是那个相对小的表，也就是“小表”。



我们再来看另外一组例子：

```sql
select t1.b,t2.* from t1 straight_join t2 on (t1.b=t2.b) where t2.id<=100;
select t1.b,t2.* from t2 straight_join t1 on (t1.b=t2.b) where t2.id<=100;
```



这个例子里，表t1 和 t2都是只有100行参加join。但是，这两条语句每次查询放入join_buffer中 的数据是不一样的：

- 表t1只查字段b，因此如果把t1放到join_buffer中，则join_buffer中只需要放入b的值； 
- 表t2需要查所有的字段，因此如果把表t2放到join_buffer中的话，就需要放入三个字段id、a和 b。

这里，我们应该选择表t1作为驱动表。也就是说在这个例子里，**“只需要一列参与join的表t1”是那 个相对小的表**。



所以，更准确地说，在决定哪个表做驱动表的时候，应该是两个表按照各自的条件过滤，过滤完成之后，**计算参与join的各个字段的总数据量**，数据量小的那个表，就是“小表”，应该 作为驱动表。





## 小结

今天，我和你介绍了MySQL执行join语句的两种可能算法，这两种算法是由能否使用被驱动表的 索引决定的。而能否用上被驱动表的索引，对join语句的性能影响很大。



通过对IndexNested-Loop Join和Block Nested-Loop Join两个算法执行过程的分析，我们也得到 了文章开头两个问题的答案：

1. 如果可以使用被驱动表的索引，join语句还是有其优势的； 
2. 不能使用被驱动表的索引，只能使用Block Nested-Loop Join算法，这样的语句就尽量不要使用； 
3. 在使用join的时候，应该让小表做驱动表。



### 思考题

我们在上文说到，使用Block Nested-Loop Join算法，可能会因为join_buffer不够大，需要对被驱动表做多次全表扫描。



我的问题是，如果被驱动表是一个大表，并且是一个冷数据表，除了查询过程中可能会导致IO压 力大以外，你觉得对这个MySQL服务还有什么更严重的影响吗？（这个问题需要结合上一篇文章的知识点）

> 回答

会在下一篇文章中回答。

这里我再根据评论区留言的情况，简单总结下。根据数据量的大小，有这么两种情况： 

- @长杰 和 @老杨同志 提到了数据量小于old区域内存的情况；
- 这里我再根据评论区留言的情况，简单总结下。根据数据量的大小，有这么两种情况： @长杰 和 @老杨同志 提到了数据量小于old区域内存的情况；

















































# 39.自增主键为什么不是连续的？

在第4篇文章中，我们提到过自增主键，由于自增主键可以让主键索引尽量地保持递增顺序插 入，**避免了页分裂，因此索引更紧凑**。

之前我见过有的业务设计依赖于自增主键的连续性，也就是说，这个设计假设自增主键是连续 的。但实际上，这样的假设是错的，因为**自增主键不能保证连续递增**。

今天这篇文章，我们就来说说这个问题，看看什么情况下自增主键会出现 “空洞”？

为了便于说明，我们创建一个表t，其中id是自增主键字段、c是唯一索引。

```sql
CREATE TABLE `t` (
    `id` int(11) NOTNULLAUTO_INCREMENT,
    `c` int(11) DEFAULTNULL,
    `d` int(11) DEFAULTNULL,
    PRIMARY KEY (`id`),
    UNIQUE KEY `c` (`c`)
) ENGINE=InnoDB
```

## 自增值保存在哪儿？

在这个空表t里面执行insert into t values(null, 1, 1);插入一行数据，再执行showcreate table命令，就可以看到如下图所示的结果：

<img src="MYSQL实战45讲.assets/image-20250305201954964.png" alt="image-20250305201954964" style="zoom:50%;" />

可以看到，表定义里面出现了一个AUTO_INCREMENT=2，表示下一次插入数据时，如果需要 自动生成自增值，会生成id=2。

其实，这个输出结果容易引起这样的误解：自增值是保存在表结构定义里的。实际上，表的结构定义存放在后缀名为.frm的文件中，但是并不会保存自增值。

不同的引擎对于自增值的保存策略不同。

- **MyISAM引擎的自增值保存在数据文件中**。
-  **InnoDB引擎的自增值，其实是保存在了内存里，并且到了MySQL 8.0版本后，才有了“自增值持久化”的能力**，也就是才实现了“如果发生重启，表的自增值可以恢复为MySQL重启前的值”，具体情况是：
  - 在MySQL 5.7及之前的版本，自增值保存在内存里，并没有持久化。每次重启后，第一 次打开表的时候，都会去找自增值的最大值max(id)，然后将max(id)+1作为这个表当前的 自增值。 举例来说，如果一个表当前数据行里最大的id是10，AUTO_INCREMENT=11。**这时候， 我们删除id=10的行，AUTO_INCREMENT还是11**。但如果马上重启实例，重启后这个表 的AUTO_INCREMENT就会变成10。 也就是说，MySQL重启可能会修改一个表的AUTO_INCREMENT的值。 
  - 在MySQL 8.0版本，将自增值的变更记录在了redo log中，重启的时候依靠redo log恢复 重启之前的值。

理解了MySQL对自增值的保存策略以后，我们再看看自增值修改机制。



## 自增值修改机制

在MySQL里面，如果字段id被定义为AUTO_INCREMENT，在插入一行数据的时候，自增值的行为如下：

1. 如果插入数据时id字段指定为0、null 或未指定值，那么就把这个表当前的 AUTO_INCREMENT值填到自增字段； 
2. 如果插入数据时id字段指定了具体的值，就直接使用语句里指定的值。

根据要插入的值和当前自增值的大小关系，自增值的变更结果也会有所不同。假设，某次要插入 的值是X，当前的自增值是Y。

1. 如果X< Y，那么这个表的自增值不变；
2. 如果X≥Y，就需要把当前自增值修改为新的自增值。

新的自增值生成算法是：从auto_increment_offset开始，以auto_increment_increment为步长，持续叠加，直到找到第一个大于X的值，作为新的自增值。

其中，auto_increment_offset 和 auto_increment_increment是两个系统参数，分别用来表示自 增的初始值和步长，默认值都是1。

> 备注：在一些场景下，使用的就不全是默认值。比如，双M的主备结构里要求双写的时候，我 们就可能会设置成auto_increment_increment=2，让一个库的自增id都是奇数，另一个库的自 增id都是偶数，避免两个库生成的主键发生冲突。

当auto_increment_offset和auto_increment_increment都是1的时候，新的自增值生成逻辑很简 单，就是： 

1. 如果准备插入的值>=当前自增值，新的自增值就是“准备插入的值+1”； 
2. 否则，自增值不变。

这就引入了我们文章开头提到的问题，在这两个参数都设置为1的时候，自增主键id却不能保证 是连续的，这是什么原因呢？



## 自增值的修改时机

要回答这个问题，我们就要看一下自增值的修改时机。

假设，表t里面已经有了(1,1,1)这条记录，这时我再执行一条插入数据命令：

```sql
insert into t values(null, 1, 1);
```

这个语句的执行流程就是：

1. 执行器调用InnoDB引擎接口写入一行，传入的这一行的值是(0,1,1); 
2. InnoDB发现用户没有指定自增id的值，获取表t当前的自增值2； 
3. 将传入的行的值改成(2,1,1); 
4. 将表的自增值改成3； 
5. 继续执行插入数据操作，由于已经存在c=1的记录，所以**报Duplicate keyerror**，语句返回。

对应的执行流程图如下：

<img src="MYSQL实战45讲.assets/image-20250305202824777.png" alt="image-20250305202824777" style="zoom:50%;" />



可以看到，这个表的自增值改成3，是在真正执行插入数据的操作之前。这个语句真正执行的时 候，因为碰到唯一键c冲突，所以id=2这一**行并没有插入成功，但也没有将自增值再改回去**。

所以，在这之后，再插入新的数据行时，拿到的自增id就是3。也就是说，出现了自增主键不连续的情况。

如图3所示就是完整的演示结果。

<img src="MYSQL实战45讲.assets/image-20250305202929539.png" alt="image-20250305202929539" style="zoom:50%;" />

可以看到，这个操作序列复现了一个自增主键id不连续的现场(没有id=2的行）。可见，唯一键 冲突是导致自增主键id不连续的第一种原因。



同样地，**事务回滚也会产生类似的现象，这就是第二种原因**。 下面这个语句序列就可以构造不连续的自增id，你可以自己验证一下。

```sql
insert into t values(null,1,1);
begin;
insert into t values(null,2,2);
rollback;
insert into t values(null,2,2);
//插入的行是(3,2,2)
```

你可能会问，为什么在出现唯一键冲突或者回滚的时候，MySQL没有把表t的自增值改回去呢？ 如果把表t的当前自增值从3改回2，再插入新数据的时候，不就可以生成id=2的一行数据了吗？ 

其实，**MySQL这么设计是为了提升性能**。接下来，我就跟你分析一下这个设计思路，看看自增值为什么不能回退。



假设有两个并行执行的事务，在申请自增值的时候，为了避免两个事务申请到相同的自增id，肯定要加锁，然后顺序申请。

1. 假设事务A申请到了id=2， 事务B申请到id=3，那么这时候表t的自增值是4，之后继续执行。
2. 事务B正确提交了，但事务A出现了唯一键冲突。
3. 如果允许事务A把自增id回退，也就是把表t的当前自增值改回2，那么就会出现这样的情 况：表里面已经有id=3的行，而当前的自增id值是2。
4. 接下来，继续执行的其他事务就会申请到id=2，然后再申请到id=3。这时，就会出现插入语 句报错“主键冲突”。

而为了解决这个主键冲突，有两种方法：

1. 每次申请id之前，先判断表里面是否已经存在这个id。如果存在，就跳过这个id。但是，这 个方法的成本很高。因为，本来申请id是一个很快的操作，现在还要再去主键索引树上判断 id是否存在。
2. 把自增id的锁范围扩大，必须等到一个事务执行完成并提交，下一个事务才能再申请自增 id。这个方法的问题，就是锁的粒度太大，系统并发能力大大下降。

可见，这两个方法都会导致性能问题。造成这些麻烦的罪魁祸首，就是我们假设的这个“允许自 增id回退”的前提导致的。

因此，InnoDB放弃了这个设计，语句执行失败也不回退自增id。也正是因为这样，所以**才只保证了自增id是递增的，但不保证是连续的**。



## 自增锁的优化

可以看到，自增id锁并不是一个事务锁，而是每次申请完就马上释放，以便允许别的事务再申 请。其实，在MySQL 5.1版本之前，并不是这样的。

接下来，我会先给你介绍下自增锁设计的历史，这样有助于你分析接下来的一个问题。

在MySQL 5.0版本的时候，自增锁的范围是**语句级别**。也就是说，如果一个语句申请了一个表自增锁，这个锁会等语句执行结束以后才释放。显然，这样设计会影响并发度。

MySQL 5.1.22版本引入了一个新策略，新增参数`innodb_autoinc_lock_mode`，默认值是1。

1. 这个参数的值被设置为0时，表示采用之前MySQL 5.0版本的策略，即语句执行结束后才释放锁； 
2. 这个参数的值被设置为1时： 普通insert语句，自增锁在申请之后就马上释放； 类似insert …select这样的批量插入数据的语句，自增锁还是要等语句结束后才被释放； 
3. 这个参数的值被设置为2时，所有的申请自增主键的动作都是申请后就释放锁。

> `NSERT ... SELECT` 语句用于将查询结果插入到另一个表中，实现批量插入数据的操作。以下是一个示例：
>
> ```sql
> INSERT INTO table2 (column1, column2, column3)
> SELECT column1, column2, column3
> FROM table1
> WHERE condition;
> ```

你一定有两个疑问：为什么默认设置下，insert …select 要使用语句级的锁？为什么这个参 数的默认值不是2？

答案是，**这么设计还是为了数据的一致性**。

我们一起来看一下这个场景：

<img src="MYSQL实战45讲.assets/image-20250306122055669.png" alt="image-20250306122055669" style="zoom:50%;" />



在这个例子里，我往表t1中插入了4行数据，然后创建了一个相同结构的表t2，然后两个session 同时执行向表t2中插入数据的操作。

你可以设想一下，如果session B是申请了自增值以后马上就释放自增锁，那么就可能出现这样的情况：

- session B先插入了两个记录，(1,1,1)、(2,2,2)； 
- 然后，session A来申请自增id得到id=3，插入了（3,5,5)； 
- 之后，session B继续执行，插入两条记录(4,3,3)、 (5,4,4)。

你可能会说，这也没关系吧，毕竟session B的语义本身就没有要求表t2的所有行的数据都跟 session A相同。

是的，从数据逻辑上看是对的。但是，如果我们现在的binlog_format=statement (陈诉，会如实记录执行的语句)，你可以设想下，binlog会怎么记录呢？

由于两个session是同时执行插入数据命令的，所以binlog里面对表t2的更新日志只有两种情况： 要么先记session A的，要么先记session B的。

但不论是哪一种，这个binlog拿去从库执行，或者用来恢复临时实例，备库和临时实例里面，session B这个语句执行出来，生成的结果里面，id都是连续的。这时，这个库就发生了数据不一致（主从库的数据不一致）。



你可以分析一下，出现这个问题的原因是什么？

其实，这是因为原库session B的insert语句，生成的id不连续。

这个不连续的id，用statement格 式的binlog来串行执行，是执行不出来的。

而要解决这个问题，有两种思路： 

1. 一种思路是，让原库的批量插入数据语句，固定生成连续的id值。所以，自增锁直到语句执行结束才释放，就是为了达到这个目的。 
2. 另一种思路是，在binlog里面把插入数据的操作都如实记录进来，到备库执行的时候，不再 依赖于自增主键去生成。这种情况，其实就是innodb_autoinc_lock_mode设置为2，同时 binlog_format设置为row。

因此，在生产上，尤其是有insert …select这种批量插入数据的场景时，从并发插入数据性 能的角度考虑，

我建议你这样设置：innodb_autoinc_lock_mode=2 ，并且 binlog_format=row.这样做，既能提升并发性，又不会出现数据一致性问题。

需要注意的是，我这里说的批量插入数据，**包含的语句类型是insert …select、replace … select和load data语句**。



但是，在普通的insert语句里面包含多个value值的情况下，即使innodb_autoinc_lock_mode设置 为1，也不会等语句执行完成才释放锁。因为这类语句在申请自增id的时候，是可以精确计算出 需要多少个id的，然后一次性申请，申请完成后锁就可以释放了。

也就是说，批量插入数据的语句，之所以需要这么设置，是因为“不知道要预先申请多少个id”。



既然预先不知道要申请多少个自增id，那么一种直接的想法就是需要一个时申请一个。但如果一 个select …insert语句要插入10万行数据，按照这个逻辑的话就要申请10万次。显然，这种申请 自增id的策略，在大批量插入数据的情况下，不但速度慢，还会影响并发插入的性能。



因此，对于批量插入数据的语句，MySQL有一个批量申请自增id的策略（指数级别增长）：

1. 语句执行过程中，第一次申请自增id，会分配1个；
2. 1个用完以后，这个语句第二次申请自增id，会分配2个； 
3. 2个用完以后，还是这个语句，第三次申请自增id，会分配4个； 
4. 依此类推，同一个语句去申请自增id，每次申请到的自增id个数都是上一次的两倍。



举个例子，我们一起看看下面的这个语句序列：

```sql
insert into t values(null, 1,1);
insert into t values(null, 2,2);
insert into t values(null, 3,3);
insert into t values(null, 4,4);
create table t2 like t;
insert into t2(c,d) select c,d from t;
insert into t2 values(null, 5,5);
```

insert…select，实际上往表t2中插入了4行数据。但是，这四行数据是分三次申请的自增id，第一 次申请到了id=1，第二次被分配了id=2和id=3， 第三次被分配到id=4到id=7。

由于这条语句实际只用上了4个id，所以id=5到id=7就被浪费掉了。之后，再执行insert into t2 values(null, 5,5)，实际上插入的数据就是（8,5,5)。

**这是主键id出现自增id不连续的第三种原因：批量插入语句会指数递增申请自增id，多申请的不会回退**。



## 小结

今天，我们从“自增主键为什么会出现不连续的值”这个问题开始，首先讨论了自增值的存储。

在MyISAM引擎里面，自增值是被写在数据文件上的。而在InnoDB中，自增值是被记录在内存 的。MySQL直到8.0版本，才给InnoDB表的自增值加上了持久化的能力，确保重启前后一个表的 自增值不变。



然后，我和你分享了在一个语句执行过程中，自增值改变的时机，分析了为什么MySQL在事务 回滚的时候不能回收自增id。

MySQL 5.1.22版本开始引入的参数innodb_autoinc_lock_mode，控制了自增值申请时的锁范 围。从并发性能的角度考虑，我建议你将其设置为2，同时将binlog_format设置为row。我在前 面的文章中其实多次提到，binlog_format设置为row，是很有必要的。今天的例子给这个结论多 了一个理由。



### 思考题

在最后一个例子中，执行insert into t2(c,d) select c,d fromt;这个语句的时候，如果隔离级别是可 重复读（repeatable read），binlog_format=statement。这个语句会对表t的所有记录和间隙加 锁。 你觉得为什么需要这么做呢？

> 回答

在下期文章中回答。 

有同学提到，如果在insert …select 执行期间有其他线程操作原表，会导致逻辑错误。其实，这 是不会的，如果不加锁，就是快照读。 

一条语句执行期间，它的一致性视图是不会修改的，所以即使有其他事务修改了原表的数据，也不会影响这条语句看到的数据。































# 43.要不要使用分区表？

我经常被问到这样一个问题：分区表有什么问题，为什么公司规范不让使用分区表呢？今天，我 们就来聊聊分区表的使用行为，然后再一起回答这个问题。



## 分区表是什么？

为了说明分区表的组织形式，我先创建一个表t：

```sql
CREATE TABLE `t` (
`ftime` datetime NOTNULL,
`c` int(11) DEFAULTNULL,
KEY (`ftime`)
) ENGINE=InnoDB DEFAULTCHARSET=latin1
PARTITION BY RANGE (YEAR(ftime))
(PARTITION p_2017 VALUES LESS THAN (2017) ENGINE = InnoDB,
PARTITION p_2018 VALUES LESS THAN (2018) ENGINE = InnoDB,
PARTITION p_2019 VALUES LESS THAN (2019) ENGINE = InnoDB,
PARTITION p_others VALUES LESS THAN MAXVALUE ENGINE = InnoDB);

insert into t values('2017-4-1',1),('2018-4-1',1);

```

<img src="MYSQL实战45讲.assets/image-20250304192826418.png" alt="image-20250304192826418" style="zoom: 50%;" />

我在表t中初始化插入了两行记录，按照定义的分区规则，这两行记录分别落在p_2018和p_2019 这两个分区上。

可以看到，这个表包含了一个.frm文件和4个.ibd文件，每个分区对应一个.ibd文件。也就是说：

- 对于引擎层来说，这是4个表； 
- 对于Server层来说，这是1个表。

你可能会觉得这两句都是废话。其实不然，这两句话非常重要，可以帮我们理解分区表的执行逻辑。



## 分区表的引擎层行为

我先给你举个在分区表加间隙锁的例子，目的是说明对于InnoDB来说，这是4个表。

<img src="MYSQL实战45讲.assets/image-20250304193106437.png" alt="image-20250304193106437" style="zoom:50%;" />



这里顺便复习一下，我在第21篇文章和你介绍的间隙锁加锁规则。

我们初始化表t的时候，只插入了两行数据， ftime的值分别是，‘2017-4-1’ 和’2018-4-1’ 。 session A的select语句对索引ftime上这两个记录之间的间隙加了锁。如果是一个普通表的话， 那么T1时刻，在表t的ftime索引上，间隙和加锁状态应该是图3这样的。

<img src="MYSQL实战45讲.assets/image-20250304193158697.png" alt="image-20250304193158697" style="zoom:50%;" />



也就是说，‘2017-4-1’ 和’2018-4-1’ 这两个记录之间的间隙是会被锁住的。那么，sesion B的两条 插入语句应该都要进入锁等待状态。

但是，从上面的实验效果可以看出，session B的第一个insert语句是可以执行成功的。这是因 为，对于引擎来说，p_2018和p_2019是两个不同的表，也就是说2017-4-1的下一个记录并不是 2018-4-1，而是p_2018分区的supremum。所以T1时刻，在表t的ftime索引上，间隙和加锁的状 态其实是图4这样的：

<img src="MYSQL实战45讲.assets/image-20250304193245048.png" alt="image-20250304193245048" style="zoom:50%;" />



由于分区表的规则，session A的select语句其实只操作了分区p_2018，因此加锁范围就是图4中 深绿色的部分。

所以，session B要写入一行ftime是2018-2-1的时候是可以成功的，而要写入2017-12-1这个记 录，就要等session A的间隙锁。

图5就是这时候的showengine innodb status的部分结果。

<img src="MYSQL实战45讲.assets/image-20250304193344138.png" alt="image-20250304193344138" style="zoom:50%;" />

看完InnoDB引擎的例子，我们再来一个MyISAM分区表的例子。

我首先用alter table t engine=myisam，把表t改成MyISAM表；然后，我再用下面这个例子说 明，对于MyISAM引擎来说，这是4个表。



<img src="MYSQL实战45讲.assets/image-20250304193438738.png" alt="image-20250304193438738" style="zoom:50%;" />

在session A里面，我用sleep(100)将这条语句的执行时间设置为100秒。由于MyISAM引擎只支 持表锁，所以这条update语句会锁住整个表t上的读。

但我们看到的结果是，session B的第一条查询语句是可以正常执行的，第二条语句才进入锁等 待状态。

这正是因为MyISAM的表锁是在引擎层实现的，session A加的表锁，其实是锁在分区p_2018 上。因此，只会堵住在这个分区上执行的查询，落到其他分区的查询是不受影响的。

看到这里，你可能会说，分区表看来还不错嘛，为什么不让用呢？我们使用分区表的一个重要原 因就是单表过大。那么，如果不使用分区表的话，我们就是要使用手动分表的方式。



接下来，我们一起看看**手动分表和分区表有什么区别**。

比如，按照年份来划分，我们就分别创建普通表t_2017、t_2018、t_2019等等。手工分表的逻 辑，也是找到需要更新的所有分表，然后依次执行更新。在性能上，这和分区表并没有实质的差别。

分区表和手工分表，**一个是由server层来决定使用哪个分区，一个是由应用层代码来决定使用哪个分表**。因此，**从引擎层看，这两种方式也是没有差别的**。



其实这两个方案的区别，主要是在server层上。从server层看，我们就不得不提到分区表一个被广为诟病的问题：打开表的行为。



## 分区策略

**每当第一次访问一个分区表的时候，MySQL需要把所有的分区都访问一遍**。一个典型的报错情 况是这样的：如果一个分区表的分区很多，比如超过了1000个，而MySQL启动的时 候，open_files_limit参数使用的是默认值1024，那么就会在访问这个表的时候，由于需要打开所 有的文件，导致打开表文件的个数超过了上限而报错。



下图就是我创建的一个包含了很多分区的表t_myisam，执行一条插入语句后报错的情况。

<img src="MYSQL实战45讲.assets/image-20250304193746374.png" alt="image-20250304193746374" style="zoom:50%;" />

可以看到，这条insert语句，明显只需要访问一个分区，但语句却无法执行。

这时，**你一定从表名猜到了，这个表我用的是MyISAM引擎。**是的，因为使用InnoDB引擎的 话，并不会出现这个问题。



MyISAM分区表使用的分区策略，我们称为**通用分区策略（generic partitioning）**，每次访问分 区都由server层控制。通用分区策略，是MySQL一开始支持分区表的时候就存在的代码，在文件 管理、表管理的实现上很粗糙，因此有比较严重的性能问题。

从MySQL 5.7.9开始，InnoDB引擎引入了**本地分区策略（native partitioning）**。这个策略是在 InnoDB内部自己管理打开分区的行为。



MySQL从5.7.17开始，将MyISAM分区表标记为即将弃用(deprecated)，意思是“从这个版本开始 不建议这么使用，请使用替代方案。在将来的版本中会废弃这个功能”。

从MySQL 8.0版本开始，就不允许创建MyISAM分区表了，只允许创建已经实现了本地分区策略 的引擎。目前来看，只有InnoDB和NDB这两个引擎支持了本地分区策略。



接下来，我们再看一下分区表在server层的行为。



## 分区表的server层行为

如果从server层看的话，一个分区表就只是一个表。

这句话是什么意思呢？接下来，我就用下面这个例子来和你说明。如图8和图9所示，分别是这个例子的操作序列和执行结果图。

<img src="MYSQL实战45讲.assets/image-20250304194038009.png" alt="image-20250304194038009" style="zoom:50%;" />



<img src="MYSQL实战45讲.assets/image-20250304194058154.png" alt="image-20250304194058154" style="zoom:50%;" />



可以看到，虽然session B只需要操作p_2107这个分区，但是由于session A持有整个表t的MDL 锁，就导致了session B的alter语句被堵住。

这也是DBA同学经常说的，分区表，在做DDL的时候，影响会更大。如果你使用的是普通分 表，那么当你在truncate一个分表的时候，肯定不会跟另外一个分表上的查询语句，出现MDL锁 冲突。



到这里我们小结一下：

1. MySQL在第一次打开分区表的时候，需要访问所有的分区； 
2. 在server层，认为这是同一张表，因此所有分区共用同一个MDL锁； 
3. 在引擎层，认为这是不同的表，因此MDL锁之后的执行过程，会根据分区表规则，只访问必要的分区。

而关于“必要的分区”的判断，就是根据SQL语句中的where条件，结合分区规则来实现的。

比如我们上面的例子中，where ftime=‘2018-4-1’，根据分区规则year函数算出来的值是2018，那么 就会落在p_2019这个分区。

但是，如果这个where 条件改成 where ftime>=‘2018-4-1’，虽然查询结果相同，但是这时候根据 where条件，就要访问p_2019和p_others这两个分区。

如果查询语句的where条件中没有分区key，那就只能访问所有分区了。当然，这并不是分区表 的问题。即使是使用业务分表的方式，where条件中没有使用分表的key，也必须访问所有的分表。

我们已经理解了分区表的概念，那么什么场景下适合使用分区表呢？



## 分区表的应用场景

分区表的一个显而易见的优势是对业务透明，相对于用户分表来说，使用分区表的业务代码更简 洁。还有，分区表可以很方便的清理历史数据。

如果一项业务跑的时间足够长，往往就会有根据时间删除历史数据的需求。这时候，按照时间分区的分区表，就可以直接通过`alter table t drop partition …`这个语法删掉分区，从而删掉过期的历 史数据。

这个alter table t drop partition …操作是直接删除分区文件，效果跟drop普通表类似。与使用 delete语句删除数据相比，优势是速度快、对系统影响小。



## 小结

这篇文章，我主要和你介绍的是server层和引擎层对分区表的处理方式。我希望通过这些介绍， 你能够对是否选择使用分区表，有更清晰的想法。

需要注意的是，我是以范围分区（range）为例和你介绍的。实际上，MySQL还支持hash分区、 list分区等分区方法。你可以在需要用到的时候，再翻翻手册。

```
/*!50100 PARTITION BY KEY (vopenid)
PARTITIONS 2000 */;
```



实际使用时，分区表跟用户分表比起来，有两个绕不开的问题：一个是第一次访问的时候需要访 问所有分区，另一个是共用MDL锁。

因此，**如果要使用分区表，就不要创建太多的分区**。我见过一个用户做了按天分区策略，然后预 先创建了10年的分区。这种情况下，访问分区表的性能自然是不好的。这里有两个问题需要注意：

1. 分区并不是越细越好。实际上，单表或者单分区的数据一千万行，只要没有特别大的索引， 对于现在的硬件能力来说都已经是小表了。

2. 分区也不要提前预留太多，在使用之前预先创建即可。比如，如果是按月分区，每年年底时 再把下一年度的12个新分区创建上即可。对于没有数据的历史分区，要及时的drop掉。

至于分区表的其他问题，比如查询需要跨多个分区取数据，查询性能就会比较慢，基本上就不是分区表本身的问题，而是数据量的问题或者说是使用方式的问题了。

当然，如果你的团队已经维护了成熟的分库分表中间件，用业务分表，对业务开发同学没有额外 的复杂性，对DBA也更直观，自然是更好的。



### 思考题

我们举例的表中没有用到自增主键，假设现在要创建一个自增字段id。

MySQL要求分区表中的主键必须包含分区字段。如果要在表t的基础上做修改，你会怎么定义这个表的主键呢？为什么这 么定义呢？

> 回答

上期的问题是，怎么给分区表t创建自增主键。由于MySQL要求主键包含所有的分区字段，所以 肯定是要创建联合主键的。

这时候就有两种可选：一种是(ftime, id)，另一种是(id, ftime)。

如果从利用率上来看，应该使用(ftime, id)这种模式。因为用ftime做分区key，说明大多数语句都 SET INSERT_ID=2; 语句B； SET INSERT_ID=1; 语句A； 是包含ftime的，使**用这种模式，可以利用前缀索引的规则，减少一个索引**。

这时的建表语句是：

```sql
CREATE TABLE `t` (
    `id` int(11) NOTNULLAUTO_INCREMENT,
    `ftime` datetime NOTNULL,
    `c` int(11) DEFAULTNULL,
    PRIMARY KEY (`ftime`,`id`)
) ENGINE=MyISAM DEFAULTCHARSET=latin1
PARTITION BY RANGE (YEAR(ftime))
(PARTITION p_2017 VALUES LESS THAN (2017) ENGINE = MyISAM,
PARTITION p_2018 VALUES LESS THAN (2018) ENGINE = MyISAM,
PARTITION p_2019 VALUES LESS THAN (2019) ENGINE = MyISAM,
PARTITION p_others VALUES LESS THAN MAXVALUE ENGINE = MyISAM);
```

当然，我的建议是你要尽量使用InnoDB引擎。**InnoDB表要求至少有一个索引，以自增字段作为 第一个字段**，当然，我的建议是你要尽量使用InnoDB引擎。InnoDB表要求至少有一个索引，以自增字段作为 第一个字段，所以需要加一个id的单独索引。。

```sql
CREATE TABLE `t` (
    `id` int(11) NOTNULLAUTO_INCREMENT,
    `ftime` datetime NOTNULL,
    `c` int(11) DEFAULTNULL,
    PRIMARY KEY (`ftime`,`id`),
    KEY `id` (`id`)
) ENGINE=InnoDB DEFAULTCHARSET=latin1
PARTITION BY RANGE (YEAR(ftime))
(PARTITION p_2017 VALUES LESS THAN (2017) ENGINE = InnoDB,
PARTITION p_2018 VALUES LESS THAN (2018) ENGINE = InnoDB,
PARTITION p_2019 VALUES LESS THAN (2019) ENGINE = InnoDB,
PARTITION p_others VALUES LESS THAN MAXVALUE ENGINE = InnoDB)
```

当然把字段反过来，创建成：

```sql
PRIMARY KEY (`id`,`ftime`),
KEY `id` (`ftime`)
```

也是可以的。



































# 待看

34.到底可不可以使用join？

35.join语句怎么优化？

36.为什么临时表可以重名？

37.什么时候会使用内部临时表？

38.都说InnoDB好那还要不要使用Memory引擎？

39.自增主键为什么不是连续的？

40.insert语句的锁为什么这么多？

41.怎么最快地复制一张表？

42.grant之后要跟着flush privileges吗？

44.答疑文章（三）：说一说这些好问题

45.自增id用完怎么办？

结束语.点线网面一起构建MySQL知识网络





